:sectnums:
== Standard JSF components

JSF offers a good selection of predefined components that provide a lot of functionality for creating user interfaces. 
For most use cases, these standard components have the desired behavior, from simple entry buttons to text boxes, to the presentation of data in tabular form. 

All standard JSF UI component classes extend the class javax.faces.component.UIComponentBase, which defines the basic behavior of a UI component. 

The inclusion of a JSF component in a page declaration occurs in facelets and JSP through its tag. 
The tags for the standard JSF components and their appearance as HTML output are in the HTML custom tag library, The core tag library has additional tags that provide base actions independent of a special render kit. 
JSF 2.2: In JSF 2.2, all tag libraries have new namespaces starting with http://xmlns.jcp.org instead of http://java.sun.com, as shown in table: standard-taglibs. 
JSF 2.2 supports both new and old namespaces. However, we recommend switching to the new namespaces for optimum future security. 
In addition, the table shows the prefixes with which the namespaces are usually included in the page declaration.

[options="header",cols="1,1,1"]
|===
|Tag Library   |namespace   |prefix   
//----------------------
|HTML custom tag library   |http://xmlns.jcp.org/jsf/html (from 2.2)   |h   
|   |http://java.sun.com/jsf/html (before 2.2)   |h   
|Core tag library   |http://xmlns.jcp.org/jsf/core (from 2.2)   |f   
|   |http://java.sun.com/jsf/core (before 2.2)   |f   
|===

We have already explained in section Section: Page Declaration Languages ​​in Action how the tag libraries in the Facelets and JSP-based pages look like . 

Hierarchical structure - child components: In order to nest components in one another and thus to build a component tree, the child components are inserted directly into the parent components in a page declaration. Each component manages a list to access these child components. 

Hierarchical structure - Facets: If a child component is to play a special role for the parent component, can - as an alternative to direct embedding as a child element - called Facets be used. 
This can be used to define a specific type or behavior of children elements - for example, a header or footer is included in a table. 
This effect is achieved with the f: facet tag. 
In JSF versions prior to 2.0, if a second component is taken over the facet, this second component will not be displayed - a stumbling block for many JSF users. Facets are identified by name, so they are stored as a map in the parent component.

[options="header",cols="1,1,1"]
|===
|attribute   |Type   |Description  
//----------------------
|id   |string   |Unique identifier of the component; if `id` is not specified, an identifier is generated   
|immediate   |boolean   |If this property is set to `true`, `input and command components` are already processed in phase 2 of the lifecycle.   
|value   |Object   |The value of the component directly as text or as value expression   
|rendered   |boolean   |Determines the visibility of the component   
|converter   |Converter   |Determines the converter for the display   
|validator   |Method expression   |References a validation method   
|styleClass   |string   |CSS class names of the component (separated by spaces) 
|style   |string   |CSS properties for rendered HTML element 
|label   |string   |Description of Error Messages for Input Components (JSF 1.2)
|binding   |string   |Binds the instance of the component to a property of a backing bean   
|===

This relationship show the code examples in section [Section:  MyGourmet 9 : UIData and detailed view] , a table with about Facets describe integrated headers and footers. The columns of the table are executed as child elements. 

Component attributes: The behavior of a component's attributes is adjusted. Attributes such as id or value occur in most standard components. Table fig: component-common-props describes the most common of these attributes. All these attributes (except id and var) can contain a value expression and dynamically access values ​​in the backing beans.

Examples of standard JSF components: The following HTML custom tag library examples are built on MyGourmet. For reasons of clarity, only the changes and expansions relevant to the component just described are depicted in the individual sections. The example MyGourmet 8 in section [Section:  MyGourmet 8 : Standard Components] summarizes all changes to the standard JSF components. The UIData component will be released with MyGourmet 9 in section [Section:  MyGourmet 9 : UIData and detail view] dedicated to a separate example. 

=== Basic Functions of the Core Tag Library

The tags in the core tag library are responsible for the basic functionality independent of special renderers; the functionality is usually provided purely by the tags (possibly together with framework classes of JSF), no custom components are created, but attributes of existing components are set or changed. The following list lists the most important JSF core tags in alphabetical order. The descriptions of each tag are deliberately kept short because many of them are only used in combination with other tags.

* f: actionListener +
Adds an action listener to a component. Details can be found in Section Section: Action Events.
* f: ajax +
Adds Ajax functionality to the view (see chapter Chapter: Ajax and JSF).
* f: attribute, f: attributes + 
Adds an attribute to a component.
* f: convertDateTime +
Adds a DateTime converter to a component. Details can be found in Section Section: Standard Converters.
* f: converter +
Adds a freely selectable converter to a component. Details can be found in Section Section: Custom Converters.
* f: convertNumber +
Adds a Number converter to a component. Details can be found in Section Section: Standard Converters.
* f: event + 
Registers a system event listener on the enclosing component (see section : System Events).
* f: facet +
Adds a component with a specific, named relationship to the parent component. The component nested within the f: facet tag is displayed. Used in more complex components such as h: panelGrid or h: dataTable .
* f: loadBundle +
This localization tag should no longer be used. Alternatives can be found in section Subsec Internationalization of Application Texts .
* f: metadata + 
Defines an area for inserting view parameters with `f:viewParam` and view actions with `f:viewAction`. Must be a child day of `f:view`. Details can be found in Section Section: Bookmarks and GET Requests in JSF .
* f: param +
Adds a parameter to components like h: outputFormat , h: commandLink or h: link .
* f: passThroughAttribute , f: passThroughAttributes + 
Adds single or multiple pass-through attributes to a component (see section Section: HTML5 Pass-Through Attributes).
* f: phaseListener +
Adds a phase listener to the `UIViewRoot`.
* f: resetValues +
Allows you to reset input components (details will follow later in this section).
* f: selectItem, f: selectItems +
Defines single or multiple selection object selections, such as `h:selectOneListbox` or `h:selectManyCheckbox`.
* f: setPropertyActionListener + 
Adds an action listener to a component that sets a managed bean property when submitting the page.
* f: validateBean +
Controls the behavior of the bean validation framework. For more details see Section Section: Bean Validation to JSR-303 .
* f: validateDoubleRange +
Adds a validator to a component that checks a floating-point number for a specific value range (see section Section: Standard Validators).
* f: validateLength +
Adds a validator to a component that validates the length of a string (see section Section: Standard Validators).
* f: validateLongRange +
Adds a validator to a component that checks an integer for a value range (see section Section: Default Validators).
* f: validateRegex + 
Adds a validator to a component that compares a string to a regular expression (see section Section: Default Validators).
* f: validateRequired +
Adds a validator to a component. This checks whether the user has specified a value (see section Section: Standard validators).
* f: validator +
Adds a custom validator registered to the system to a component (see section Section: Custom Validators).
* f: valueChangeListener +
Adds a value change listener to a component. Details can be found in Section Section: Value Change Events.
* f: view +
Defines the root node of the component tree of a page. This tag is necessary for the initialization of the Faces context, but must only be mandatory in JSP pages.
* f: viewActionInserts + 
a view action into the component tree. Must be a child of f: metadata (see section Section: View Actions).
* f: viewParamInserts + 
a view parameter in the component tree. Must be a child of f: metadata (see section Section: View Parameters).

==== Reset components with f:resetValues

JSF 2.2: With the `f:resetValues` ​​tag, JSF 2.2 can elegantly solve a problem that has already been known for some time. In some cases, JSF can not update the value of input components unless explicitly previously reset. f: resetValues adds an action listener to command components that resets all input components whose client IDs are specified in the render attribute. Be sure to use the complete client ID of the components in render.

Listing <<.Example of `f:resetValues`, Example of `f:resetValues`>> shows an example of `f:resetValues`. The action method reset resets the value of the value1 property to 0.

.Example of `f:resetValues`
[source,xhtml]
----
<h:form id="form">
  <h:inputText id="v1" value="#{bean.value1}">
    <f:validateLongRange minimum="10"/>
  </h:inputText>
  <h:commandButton value="Save"/>
  <h:commandButton value="Reset" action="#{bean.reset}"
      immediate="true">
    <f:resetValues render="form:v1"/>
  </h:commandButton>
</h:form>
----

This example works without `f:resetValues`, but only until the user presses the save button with an invalid value for the input field. In this case, the local value of the component remains set and the value updated in the action method is not displayed. With `f:resetValues` that the local value is deleted before JSF performs the action method ensures. In section Section: Reset input fields, this problem is further analyzed for Ajax requests.

=== Form Component

The component `UIForm` with the tag `h:form` is analogous to the form element in HTML and must enclose all input and command components that return data to the application and trigger actions. 

The component itself is rendered as a form element and is not displayed in the browser. A page can contain several `UIForm` components. Listing <<.Example of `h:form`, Example of `h:form`>> shows once again the form from MyGourmet 1 for demonstration.

.Example of `h:form`
[source,xhtml]
----
<h:form id="form">
  <h:panelGrid id="grid" columns="2">
    <h:outputLabel value="First Name:" for="firstName"/>
    <h:inputText id="firstName"
      value="#{customer.firstName}"/>
    <h:outputLabel value="Last Name:" for="lastName"/>
    <h:inputText id="lastName"
      value="#{customer.lastName}"/>
    <h:commandButton id="save" value="Save"
        action="#{customer.save}"/>
  </h:panelGrid>
</h:form>
----

*Hyperlinks:* +
In contrast to the HTML standard, a `UIForm` is also required for the execution of hyperlinks that are inserted into the view with `h:commandLink`. Because Command Link components submit a form when activated, they do not work without enclosing `UIForm`. The link tags `h:outputLink` and `h:link` work without problems even outside a `UIForm`.

=== Command components

`UICommand` is derived from the class `UIComponentBase` and represents a command element in the HTML page. If this command element is activated by the user in the browser, an application-specific action is triggered. The command element can, for example, be displayed as a button `h:commandButton`, menu item or hyperlink `h:commandLink`. Here is a code example of the button component from our example:

[source,xhtml]
----
<h:commandButton action="#{customerBean.save}" value="Save"/>
----

As an example of Command Link component we add the view showCustomer.xhtml in MyGourmet a link to the page editCustomer.xhtml added:

[source,xhtml]
----
<h:commandLink action="/editCustomer.xhtml"
    value="Edit Customer"/>
----

For the link to work, it must be embedded in a `UIForm`. Here's another example of a Command Link component that uses the `rendered` attribute:

[source,xhtml]
----
<h:commandLink id="check" rendered="{cart.numberOfItems > 0}">
  <h:outputText value="#{managedBean.action}"/>
</h:commandLink>
----

`rendered` attribute: In this example, the command link check is not displayed if there are no goods in the shopping cart, or more precisely, if the numberOfItems property of the managed bean cart has the value 0.

=== DataTable component

The `UIData` component with the tag `h:dataTable` iterates over items in a collection of data objects and creates a table in the HTML output. Each element of the referenced collection becomes a table row with a fixed number of columns in the rendered output. The columns themselves and their contents are added to the `UIData` component in the form of nested `UIColumn` components with the `h:column` tag. 

See the listing example for `h:dataTable` for a first example of `h:dataTable` and `h:column` in which a list of persons is output in the form of a table with two columns.

[source,xhtml]
----
<h:dataTable value="#{myBean.persons}" var="person">
  <h:column>
    <h:outputText value="#{person.name}"/>
  </h:column>
  <h:column>
    <h:outputText value="#{person.email}"/>
  </h:column>
</h:dataTable>
----

The list of persons is referenced by a value expression in the value attribute of `h:dataTable`. It comes from the persons property of the managed bean myBean and contains instances of the Person class with the `name` and `email` properties. Listing property persons for `h:dataTable` shows the corresponding code.

[source,java]
----
private List<Person> persons;
public List<Person> getPersons() {
  return persons;
}
----

*JSF 2.2:* JSF supports only a limited set of types in the value attribute of `h:dataTable`. Prior to JSF 2.2, these were essentially arrays, `java.util.List` and the JSF type `javax.faces.model.DataModel`. As of JSF 2.2, `h:dataTable` can handle all types derived from `java.util.Collection`. For example, until version 2.2 it was not possible to work directly with `java.util.Set`. 

During rendering (as in all other phases of the LifeCycle), the `UIData` component now goes through the bound list element by element and makes the current element available under the name defined in the `var` attribute. Each element outputs exactly one line whose contents are defined by the `UIColumn` components inserted with `h:column`. In our example from the listing example for `h:dataTable`, for example, we use the name `person` to access the current person. For each person, the property `name` is displayed in the first column and the property `email` is displayed in the second column. You can see the resulting representation in HTML in Listing Rendered `h:dataTable`.

[source,html]
----
<table>
  <tbody>
    <tr>
      <td>Anna Muster</td>
      <td>anna@muster.at</td>
    </tr>
    <tr>
      <td>Max Muster</td>
      <td>max@muster.at</td>
    </tr>
  </tbody>
</table>
----

Figure <<.Rendered output of `h:dataTable`, Rendered output of `h:dataTable`>> shows how the rendered output of the table looks in the browser.

====
.Rendered output of h: dataTable
image::images/datatable-no-styling.jpg[]
====

*Stamping:* Although the list bound to the component has thousands of entries, only one component instance is inserted in the component tree for each column. When editing the component during its lifecycle - such as during rendering - JSF uses these instances for all rows with the current value. This procedure is called stamping and should guarantee a minimum memory consumption.

The complete example of the `UIData` component is not in MyGourmet 8, but in MyGourmet 9 in section [Section:  MyGourmet 9 : UIData and Detail View]. There, the switching between list and detail view and the deletion and editing of individual addresses from the list will be explained.

==== Extended concepts of h:dataTable

With Facets may `UIData` component and each of its columns with a header and footer are provided. For this, a facet with a distinguished name - header for header and footer added as a child element of the respective component - for footers. In the example, we extend the person table with headings for the table itself and for all its columns. A simple exercise with Facets, as shown in Listing <<.Example for h: dataTable with Facets, Example for `h:dataTable` with Facets>>.

.Example for h: dataTable with Facets
[source,xhtml]
----
<h:dataTable value="#{myBean.persons}" var="person">
  <f:facet name="header">Personen</f:facet>
  <h:column>
    <f:facet name="header">
      <h:outputText value="Name"/>
    </f:facet>
    <h:outputText value="#{person.name}"/>
  </h:column>
  <h:column>
    <f:facet name="header">
      <h:outputText value="E-Mail"/>
    </f:facet>
    <h:outputText value="#{person.email}"/>
  </h:column>
</h:dataTable>
----

Let's take another look at the rendered HTML code. All headings are output as `th` elements in the newly added section `thead` of the table. Headers and footers of the table always span the entire width, which can be seen in the output of the `colspan` attribute set. Each column has its own th element. Otherwise, nothing has changed - as Listing <<.Rendered `h:dataTable` shows with facets, Rendered `h:dataTable` shows with facets>>.

.Rendered `h:dataTable` shows with facets
[source,html]
----
<table>
  <thead>
    <tr>
      <th colspan="2" scope="colgroup">Persons</th>
    </tr>
    <tr>
      <th scope="col">Name</th>
      <th scope="col">E-Mail</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Anna Muster</td>
      <td>anna@muster.at</td>
    </tr>
    <tr>
      <td>Max Muster</td>
      <td>max@muster.at</td>
    </tr>
  </tbody>
</table>
----

*Pagination:* The `UIData` component basically supports displaying a section of a data collection. There are the attributes `first` and `rows`. The display then takes place from the line specified in the first attribute. The rows attribute is used to specify the number of rows. For example, to represent rows 2 through 10 of a table, set `first` to 2 and `rows` to 9. The default value of these two attributes is null, which corresponds to the display of all rows. 

The practice value of the attributes `first` and `rows` is initially rather low, since the JSF standard lacks a Paginator component. For the page-by-page display of data, you must therefore refer to a component library such as PrimeFaces (Section Section: Selecting some PrimeFaces components shows the use of `p:dataTable`) or write your own component.

==== Styling of h:dataTable

Granted, the rendered output in Figure <<.Rendered output from `h:dataTable`, Rendered output from `h:dataTable`>> still looks a bit monotonous, despite the header and footer in its current form. The `DataTable` component provides various attributes to style the table with CSS. In addition to the `styleClass` attribute, which references a CSS class that is valid for displaying the entire table, there are some optional attributes for incorporating CSS classes for other parts of the component:

* `rowClasses` (`h:dataTable`): +
comma-separated names of the CSS style classes for the rows. If several style classes are specified, the attribute is set alternately for the rows. So if two CSS classes ( styleClass1 , styleClass2 ) have been defined, the first line is labeled styleClass1 , the second line is styleClass2 , the third line is styleClass1 again . In the rendered output, the style class is placed in the respective tr element of the line.

* `columnClasses` (`h:dataTable`) : +
Same as `rowClasses`, except that the CSS style class (s) apply to the columns. In the rendered output of the table, these style classes are placed in the individual `td` elements.

* `footerClass` (`h:dataTable` and `h:column`): + 
the CSS class name for the footer (defined by the `Facet` called `footer`). The style class is set in the rendered output for each `td` element of the footer.

* `headerClass` (`h:dataTable` and `h:column`): + 
Name of the CSS style class for the header (defined by the `Facet` named `header`). The style class is set in the rendered output for each th element of the header.

With values ​​for `styleClass` and `headerClass`, the rendered output of the table in the browser could look like as shown in the figure <<.Rendered Output of `h:dataTable`, Rendered Output of `h:dataTable`>>.

====
.Rendered Output of `h:dataTable`
image::images/datatable-styling.jpg[]
====

=== output components

In this section, we focus on components for outputting information. To do this, section [Text output components] first displays components for outputting text-based content. Section [Image Output Component] then presents details on how to output images.

==== Text output components

The `UIOutput` component is used to display output text on a page. The value of this component may be tied to a model object and can not be changed by the user. The HTML tag library of the JSF standard includes the following tags for easy text output:

* h:outputText
* h:outputLabel
* h:outputLink
* h:outputFormat

===== Tag for text output `h:outputText`

`h:outputText` sets the value specified in the value attribute in the HTML-output is displayed. The text is rendered without formatting, unless the style or styleClass attributes refer to CSS styles or CSS classes that affect formatting. Normally, the text of the `UIOutput` component is rendered directly - without any special HTML markup. If HTML attributes such as `id`, `styleClass` or `style` are set, the text in the output is automatically surrounded by a `<span />` element. 

*escape attribute:* HTML or XML formatting in value is lost on output; all special characters in texts are replaced by their HTML entities (eg \verb|>| replaced by \verb|>|). To allow direct output of HTML or XML tags, the `escape` attribute can be set to `false`. Listing <<.examples of `h:outputText`, examples of `h:outputText`>> shows three examples.

.examples of `h:outputText`
[source,xhtml]
----
<h:outputText escape="true"
  value="Hallo liebe <em>Leser</em>"/>
<h:outputText escape="false"
  value="Hallo liebe <em>Leser</em>"/>
<h:outputText escape="false"
  value="<script>alert('Böse')</script>"/>
----

The texts on the first and second `tag` are identical. The `tags` differ only by the attribute `escape`, which is once set to `true` and once to `false`. How this affects the output is shown in Figure <<.Rendered output of `h:outputText`,Rendered output of `h:outputText`>>.

====
.Rendered output of `h:outputText`
image::images/uioutputtext-screenshot.jpg[]
====

However, if you set escape to `false`, you should always keep in mind that you are dealing with a potential security vulnerability - especially if the user outputs editable data directly. Figure <<.Rendered output of `h:outputText`, Rendered output of `h:outputText`>> shows how a user executable code can smuggle into the text. This will allow cross-site scripting attacks.

===== Label Output Component `h:outputLabel`

The `h:outputLabel` component (label HTML element) allows labels to be linked to input fields. The components required to output the label are nested in the `h:outputLabel` tag. The component itself does not provide a text. The attribute `for` must be set and the attribute `id` to show the input field.

Listing <<.`h:outputLabel` in use, `h:outputLabel` in use>> shows in two ways how `h:outputLabel` can be used. In the first variant, the `h:outputText` tag returns its `value` Attribute displays the text that appears as a label in the input field for the first name. As you can see in the second variant, the label for the input field can also be specified in the `value` attribute of the `h:outputLabel` tag itself. This variant is simpler but less flexible - which did not stop us from choosing this approach in MyGourmet.

.`h:outputLabel` in use
[source,xhtml]
----
<h:outputLabel for="firstName">
  <h:outputText value="First Name:"/>
</h:outputLabel>
<h:inputText id="firstName" required="true"
    value="#{customerBean.customer.firstName}"/>
<h:outputLabel for="lastName" value="Last Name:"/>
<h:inputText id="lastName" required="true"
    value="#{customerBean.customer.lastName}"/>
----

===== Link component `h:outputLink`

The `h:outputLink` tag creates a hyperlink to an external URL. The URL that is loaded when the user clicks on the link is defined in the `value` attribute. No action event is fired, and the state of the component tree stored by JSF rendering the current view is lost. 

To set the displayed text and appearance of the link, any output component can be nested within the `h:outputLink` tag. For plain text, the `h:outputText` component or nested HTML elements suffice; for a graphical representation of the link, the `h:graphicImage` component can be used. By nesting `f:param` tags can be used to set URL parameters - both static and dynamic via a unified EL expression.

Listing <<.`h:outputLink` with external link, `h:outputLink` with external link>> shows an `h:outputLink` component with an external link and parameters in use.

.`h:outputLink` with external link
[source,xhtml]
----
<h:outputLink value="http://wiki.apache.org/myfaces/">
  <h:outputText value="MyFaces Wiki"/>
  <f:param name="action" value="info"/>
</h:outputLink>
----

Here is the rendered html output of the example from listing <<.`h:outputLink` with external link rendered html, `h:outputLink` with external link rendered html>>:

.`h:outputLink` with external link rendered html
[source,xhtml]
----
<a href="http://wiki.apache.org/myfaces/?action=info">
MyFaces Wiki</a>
----

A widespread criticism of JSF is that `GET` requests are not fully supported. That's not true. As of JSF 2.0, there are extensive support for `GET` requests with `View-Parameters` and as of JSF 2.2 in addition to `View-Actions`. For details, see section Section: Bookmarks and GET Requests in JSF.

===== Parameterizable text output field `h:outputFormat`

The tag `h:outputFormat` is the same as the `h:outputText` tag used to output text. In addition, it is possible to interweave either statically predefined or dynamically integrated values via Unified-EL expressions into the output text. Specifically, for example, the user name or a date can be incorporated into a text template. 

*Message-Format:* The output of text with dynamically integrated variables can be further simplified by the use of wildcard message format templates. A wildcard is a number within curly brackets that point to the index of an `f:param` child elements refers. The numbering of the parameters starts with the number 0 (typical for Java). The placeholder {0} is therefore replaced by the value of the first parameter `f:param` embedded in `h:outputFormat`, {1} by the value of the second parameter and so on, As an example, the message at the bottom of the `showCustomer.xhtml` view is expanded as shown in Listing <<.`h:outputFormat`, `h:outputFormat`>> in MyGourmet.

.`h:outputFormat`
[source,xhtml]
----
<h:outputFormat value="{0}, your profile is {1}.">
  <f:param value="#{customerBean.customer.firstName}"/>
  <f:param value="active"/>
</h:outputFormat
----

For the placeholder {0} the result of the expression customerBean.customer.firstName is used and for {1} the value of the second parameter, namely "active". The complete edition is therefore:

----
Martin, your profile is active.
----

If the template string is also dynamically integrated for different languages, parameters can be output to other locations - this is important for internationalization, as has already been shown in section Section: Internationalization.

==== Image output component

The component `UIGraphic` with the tag `h:graphicImage` shows the user a non-manipulatable graphic. The url attribute specifies the path to the graphic in the form of a static string or value expression. 

*Relative vs. Absolute addressing:* If a slash ( / ) is set at the beginning of the path, the path is understood as an absolute indication within the web application, otherwise the path is relatively understood. In web applications, an absolute addressing is generally recommended, because then the page structure can be changed arbitrarily without having to consider the integrated graphics and other resources. 

`h:graphicImage` tag is rendered as an `img` tag in the HTML output. If the path passed in the url attribute of the component begins with a slash ( / ), the context path of the application precedes the rendering of the `src` attribute. 

*`alt` attribute:* The attribute `alt` specifies the text to be displayed as an alternative to image display, the `Internet Explorer` shows the `ALT` -Text appropriate when the mouse is moved over the image. In the following example, the attribute `alt' references to a localized text (for details on localization, see section section: Internationalization).

[source,xhtml]
----
<h:graphicImage id="Grafik" url="/images/Grafik.jpg"
    alt="#{bundle.chooseLocale}" title="Grafikanzeige"
    width="149" height="160"/>
----

As of JSF 2.0, images can also be integrated in the form of resources. Instead of the path to the image file, you specify the name of the resource in the new attribute name of the tag `h:graphicImage`. Details on handling resources as of JSF 2.0 can be found in Chapter: Resource Management.

=== Input Components

The `UIInput` component is a subclass of the `UIOutput` class. It accepts input data from the user, such as text from a text entry field, passwords from a password input field, or - new in JSF 2.2 - files from a file upload field. `Table: input-components` shows the tags of `UIInput`- derived input components with examples (except for `h:inputHidden`).

[options="header",cols="1,1"]
|===
|Standard Tag   |Example   
//-------------
|h:inputText
a| image::images/comp-inputtext.jpg[]

|h:inputSecret
a| image::images/comp-inputsecret.jpg[]

|h:inputTextarea
a| image::images/comp-inputtextarea.jpg[]

|h:inputFile
a| image::images/comp-inputfile.jpg[]
|===

To convert, validate, and then detect and handle the inputs of these components, the following tags from the core tag library can be used: `f:converter` (see Section: Conversion), `f:validator` (see Section: Validation) and `f:valueChangeListener` (see Section: Value Change Events). Input components are often associated with label output components to generate a label element in the HTML output. For details, see section [Text output components section].

==== Text input field `h:inputText`

This component makes it possible to create a text input field. In Listing <<.`h:inputText` in action, `h:inputText` in action>>, you will again see the entry field for the first name in MyGourmet.

.`h:inputText` in action
[source,xhtml]
----
<h:inputText id="firstName"
  value="#{customerBean.customer.firstName}"
  size="30" maxlength="40" required="true"/>
----

A value expression links the input field of the example to the `firstName` property of the customerBean.customer object. When rendering the view, the value from the bean is displayed in the input field - it can be changed by the user. After submitting the form, the new value is automatically written back to the bean's property - assuming the conversion and validation were successful. 

If the required attribute is set to `true`, a validation error will be generated if the user does not enter a value. The size attribute sets the visible length of the input field to 30 characters, and maxlength it is determined that the user input may be a maximum of 40 characters.

==== Password entry field `h:inputSecret`

The `h:inputSecret` tag generates a password input field with hidden input. In the rendered output, the HTML tag becomes `<input type={"}password{"}>`. The user input in this input field is displayed in the form of dots. Setting the redisplay attribute to `false` prevents the entered password from being displayed in the source text of the HTML page when the page is rebuilt. Listing <<.`h:inputSecret` in use, `h:inputSecret`>> shows the component in use. Otherwise, this component works much like `h:inputText`.

.`h:inputSecret` in use
[source,xhtml]
----
<h:inputSecret redisplay="false"
  value="#{loginBean.password}" />
----

==== Multi-line text input field `h:inputTextarea`

The component `h:inputTextarea` is also used like the component `h:inputText`. However, instead of a field with only one line, it generates a larger, i.e., multi-line input field. The number of columns and rows is determined by the `rows` and `cols` attributes. For an example, see Listing <<.`h:inputTextarea` in use, `h:inputTextarea`>>.

.`h:inputTextarea` in use
[source,xhtml]
----
<h:inputTextarea id="textArea" rows="4" cols="7"
  value="#{managedBean.textAreaData}" />
----

==== Hidden input field `h:inputHidden`

The `h:inputHidden` component is invisible to the user and is used to transfer variables (and thus status) from page to page without having to save the status to the server. However, there are rarely any use cases where this behavior is desired in JSF. JSF manages the status of the pages of the application for us, and other data usually uses the user session. 

Of course, since this component is not a visible output to the user, there are no display-specific attributes like `styleClass` or `size`. Listing <<.`h:inputHidden` in use, `h:inputHidden`>> shows the component in use.

.`h:inputHidden` in use
[source,xhtml]
----
<h:inputHidden id="hidden"
  value="#{managedBean.hiddenField}"/>
----

==== File upload field `h:inputFile`

JSF 2.2: With JSF 2.2 it has finally made the `file` `upload` component with the tag `h:inputFile` in the standard. The reason for this very long delay is that only with version 3.0 the prerequisites for the file upload were included in the servlet standard.

`h:inputFile` allows you to upload a file to a bean property of type `javax.servlet.http.Part`. Like any other input component, this property is associated with the component through a value expression in the `value` attribute . In all other respects too, `h:inputFile` behaves like any other input component in JSF.

For the file upload to work properly, the `enctype` attribute of the enclosing `h:form` tag must be set to the value `multipart/form-data`. This is the only way to ensure that the data is transferred correctly to the server. Listing <<.`h:inputFile` with `h:form`, `h:inputFile` with `h:form`>> shows a simple example of uploading a file when clicking on a button.

.`h:inputFile` with `h:form`
[source,xhtml]
----
<h:form id="form" enctype="multipart/form-data">
  <h:inputFile id="file" value="#{bean.file}"/>
  <h:commandButton value="Upload" action="#{bean.upload}"/>
</h:form>
----

See the Managed Bean referenced in the last example in Listing <<.Managed Bean for File Upload, Managed Bean for File Upload>>. With a transmission (submit) the form JSF stores the uploaded file in the property named file type `javax.servlet.http.Part`.

.Managed Bean for File Upload
[source,java]
----
public class Bean {
  private Part file;
  private String fileContent;

  public void upload() {
    try {
      fileContent = new Scanner(file.getInputStream())
          .useDelimiter("A").next();
    } catch (IOException e) {// Error handling}
  }

  public Part getFile() {
    return file;
  }

  public void setFile(Part file) {
    this.file = file;
  }
}
----

Via the interface `Part` all important information of the file like the `name`, the `mime-type`, the `size` and of course the `content` are available. In the `upload` action method, the file content is read from the provided input stream and written to the `String` field . There it stands ready for further use in the managed bean. 

`h:inputFile`, like any other input `component`, supports the addition of `validators` to check the validity of the uploaded file:

[source,xhtml]
----
<h:inputFile id="file" value="#{bean.file}"
    validator="#{bean.validateFile}"/>
----

In the referenced validation method, for example, the size of the file can then be checked:

[source,java]
----
public void validateFile(FacesContext ctx,
    UIComponent comp, Object value) {
  if (((Part)value).getSize() > 1024) {
    new ValidatorException(new FacesMessage("file too big"));
  }
}
----

Incidentally, with `h:inputFile` you can also upload files via Ajax. The handling does not differ from other components and works as described in chapter Chapter:Ajax and JSF.

=== Selection Components

In this section, we'll show you several components for selecting values. Section [Section: Boolean Selection] starts with the simplest variant and shows the Boolean selection. Then it continues with components for selecting values ​​from a list: Section [Section: Simple Selection] shows components for selecting a value and Section [Section: Multiple Selection] Components for selecting multiple values. Finally, section [Section: Definition of choices] demonstrates how the choices are defined.

==== Boolean selection

With the selection component `UISelectBoolean`, which is available under the tag `h:selectBooleanCheckbox`, a Boolean value can be bound to a selection component. `UISelectBoolean` is a subclass of `UIInput` and is rendered as an HTML checkbox as shown in table: component-selectboolean.

[options="header",cols="1,1"]
|===
|Standard tag   |example   
//-------------
|h:selectBooleanCheckbox
a| image::images/comp-selectbooleancheckbox.jpg[]  
|===

In MyGourmet, `UISelectBoolean` is already used for the `useCreditCard` property. Listing <<.selection box in action, selection box in action>> shows the corresponding tag.

.selection box in action
[source,xhtml]
----
<h:selectBooleanCheckbox id="useCreditCard"
    value="#{customerBean.customer.useCreditCard}"/>
----

*A little hint:* The getter for a boolean value can start with `is`, so for our example, `isUseCreditCard()`. For select `fields` that reference a `Boolean` value (i.e., not the primitive data type), the `getter` `getUseCreditCard()` must be mentioned. The code for the `useCreditCard` property is found in the listing <<.property of a bean for a selection box, property of a bean for a selection box>>.

.property of a bean for a selection box
[source,java]
----
private Boolean useCreditCard = Boolean.FALSE;
public Boolean getUseCreditCard() {
  return useCreditCard;
}
public void setUseCreditCard(
    Boolean useCreditCard) {
  this.useCreditCard = useCreditCard;
}
----

==== Simple selection

The `UISelectOne` component allows the selection of a single object from a selection list. 
The `UISelectOne` class is also a subclass of `UIInput`. 
For this component, there are standard tags for displaying the objects as a radio button (`h:selectOneRadio`), list box (`h:selectOneListbox`) or pop-up menu (`h:selectOneMenu`). 
Examples of how the standard tags are displayed in the browser can be found in table: component-selectone.

[options="header",cols="1,1"]
|===
|Standard tag   |example   
//-------------
|h:selectOneRadio
a| image::images/comp-selectoneradio.jpg[]
|h:selectOneListbox
a| image::images/comp-selectonelistbox.jpg[]   
|h:selectOneMenu
a| image::images/comp-selectonemenu.jpg[]
|===
With the `value` attribute of the `UISelectOne` component, the selected value is linked to the property of a bean via a value expression. 
If the bound value does not have the data type `String`, a suitable converter must be selected.

To demonstrate `UISelectOne`, the example is extended to include the `gender` property. 
Listing <<.radio button in use, radio button in use>> shows the tag as a radio button.

.radio button in use
[source,xhtml]
----
<h:selectOneRadio id="gender" required="true"
    value="#{customerBean.customer.gender}">
  <f:selectItem itemLabel="Female" itemValue="f"/>
  <f:selectItem itemLabel="Male" itemValue="m"/>
</h:selectOneRadio>
----

Setting `required` = `true` forces you to choose one of these two options. 
In Listing <<.property `gender`, property `gender`>> you will find the necessary changes to the class Customer.

.property `gender`
[source,java]
----
private Character gender;
public Character getGender() {
  return gender;
}
public void setGender(Character gender) {
  this.gender = gender;
}
----

==== Multiple selection

Now that we know what the `UISelectOne` component can do, the functionality of the `UISelectMany` component is not hard to guess. 
This component allows the user to select none, one or more objects from a selection list. 
The class `UISelectMany` is derived from the class `UIInput`. 
Standard tags are available for selection as selection field (`h:selectManyCheckbox`), list (`h:selectManyListbox`) or selection menu (`h:selectManyMenu`) Some browsers can not handle the presentation as a selection menu reasonable. 
Even if the presentation is possible, the user interaction is difficult - the representation is the same as in the `UISelectOne` component. 
Examples of how the standard tags are displayed in the browser can be found in table: component-selectmany.

[options="header",cols="1,1"]
|===
|Standard tag   |example   
//-------------
|h:selectManyCheckbox   a| image::images/comp-selectmanycheckbox.jpg[]  
|h:selectManyListbox   a| image::images/comp-selectmanylistbox.jpg[]
|h:selectManyMenu   a| image::images/comp-selectmanymenu.jpg[]
|===

For each object or object group for the selection list, an `f:selectItem` or `f:selectItems` tag is nested in the component's tag (see section [sec: simple selection]). 
The `value` attribute binds the selected values ​​to a bean property using a value expression whose type is an array of primitive types or objects or a list of strings. 
If it is an array of a type other than a `String`, a matching converter is selected.

===== Selection field `h:selectManyCheckbox`

The `h:selectManyCheckbox` tag can be used to create a group of checkboxes, each representing a value that can be selected by the user. 
The values ​​of the selection fields are specified by nested `f:selectItem` or `f:selectItems` tags. 
The value of the checkboxes can be integrated in the `value` attribute via a unified-EL expression with the `enabledClass` and `disabledClass` attributes.

CSS style classes can be included which determine the layout of the selected or unselected selection fields and the associated text. 
With the attribute `layout` the arrangement of the individual items or selection fields can be determined: With the value `pageDirection` the selection fields are arranged vertically and with `lineDirection` horizontally. If the layout attribute is not specified, the display is horizontal. 

As a demonstration, the `Customer` class in MyGourmet will be the `preferredCategories` property extended. 
The user can thus select preferred categories from a list of values. 
The tag for a selection as `h:selectManyCheckbox` with two fixed values ​​(horizontally arranged checkboxes) can be found in Listing <<.selection field in action, selection field in action>>.

.selection field in action
[source,xhtml]
----
<h:selectManyCheckbox id="prefCat"
    value="#{customerBean.customer.preferredCategories}">
  <f:selectItem itemValue="IT" itemLabel="Italian"/>
  <f:selectItem itemValue="GR" itemLabel="Greek"/>
</h:selectManyCheckbox>
----

The HTML output rendered from the tag in Listing <<.selection field in action, selection box>> is visible in the Listing <<.HTML output of the selection box, HTML output of the selection box>>.

.HTML output of the selection box
[source,html]
----
<table id="form:prefCat">
  <tr>
    <td>
      <input id="form:prefCat:0" type="checkbox"
          name="form:prefCat" value="IT"/>
      <label for="form:prefCat:0"> Italian</label>
    </td>
    <td>
      <input id="form:prefCat:1" type="checkbox"
          name="form:prefCat" value="GR"/>
      <label for="form:prefCat:1"> Greek</label>
    </td>
  </tr>
</table>
----

The class Customer receives the property preferredCategories . For the corresponding code snippet, see the Listing <<.Bean property for a select box, Bean property for a select box>>.

.Bean property for a select box
[source,java]
----
private List<String> preferredCategories =
    new ArrayList<String>();
public List<String> getPreferredCategories() {
  return preferredCategories;
}
public void setPreferredCategories(
    List<String> preferredCategories) {
  this.preferredCategories = preferredCategories;
}
----

===== List box `h:selectManyListbox`

With a large number of selections, the display as a selection field is confusing and a list box in which the elements are displayed listed is more practicable. 
Listing <<.list box in action, list box in action>> shows how the `preferredCategories` property is used with the `h:selectManyListbox` tag.

.list box in action
[source,xml]
----
<h:selectManyListbox id="prefCat"
    value="#{customerBean.customer.preferredCategories}">
  <f:selectItem itemValue="IT" itemLabel="Italian"/>
  <f:selectItem itemValue="GR" itemLabel="Greek"/>
</h:selectManyListbox>
----

The HTML output rendered from the tag in Listing <<.list box in action, list box>> displays Listing <<.HTML output of the list box, HTML output of the list box>>.

[source,html]
----
<select id="form:prefCat" name="form:prefCat"
    multiple="multiple" size="2">
  <option value="IT">Italian</option>
  <option value="GR">Greek</option>
</select>
----

===== Menu field `h:selectManyMenu`

Unlike the list box, only one item is displayed in a menu at a time. 
In Internet Explorer you can scroll to the remaining elements via a scrollbar, in Mozilla (and its relatives) only one element is displayed at a time. The multiple choice is definitely difficult for the user to accomplish.

The example with the preferred categories as menu can be found in Listing <<.menu box in action,menu box in action>>.

[source,xhtml]
----
<h:selectManyMenu id="prefCat"
    value="#{customerBean.customer.preferredCategories}">
  <f:selectItem itemValue="IT" itemLabel="Italian"/>
  <f:selectItem itemValue="GR" itemLabel="Greek"/>
</h:selectManyMenu>
----

The HTML code can be seen in Listing <<.HTML output of the menu field, HTML output of the menu field>>.

[source,html]
----
<select id="form:prefCat" name="form:prefCat"
    multiple="multiple" size="1">
  <option value="IT">Italian</option>
  <option value="GR">Greek</option>
</select>
----

==== Definition of choices

The list of possible values ​​of a selection component is defined in JSF with the tags `f:selectItem` and `f:selectItems`.

===== Single choice with `f:selectItem`

The `f:selectItem` tag creates a single selection object and must be specified as the child tag of a selection component. 
The `localizable` attribute `itemLabel` stores the short description that is displayed to the user for this selection object. 
The `itemDescription` attribute specifies a description of the component, which is typically longer than itemLabel and is not represented by the default renderers. 
In `itemValue` the server-side value of this object is. 
It must be the same data type as the value of the parent component. 
With the `Boolean` attribute `itemDisabled` the value in the selection list of the component can be deactivated. 
It is then greyed out in the browser and can not be selected. 
Internet Explorer interprets the attribute `disabled` on the HTML element `option` only as of version 8.

As a variant to the use of these attributes, a `SelectItem` instance associated with this component can be referenced in the value attribute. 
If this attribute is set then `itemLabel`, `itemValue` and `itemDescription` will not be used. 
The example in Listing <<.`f:selectItem` in action, `f:selectItem` in action>> shows the use.

.`f:selectItem` in action
[source,xml]
----
<f:selectItem itemValue="IT" itemLabel="Italian"/>
<f:selectItem itemValue="GR" itemLabel="Greek"
    itemDisabled="#{user.numberOfVisits < 5}"/>
<f:selectItem itemValue="AT" itemLabel="Austrian"/>
<f:selectItem value="#{customerBean.selectMexican}"/>
----

In this example, `itemDisabled` is determined by a `Unified-EL` expression, which is true if the user has visited the page less than 5 times.

===== Several options with `f:selectItems`

The `f:selectItems` tag allows you to define multiple selections for a selection component. 
The list of options is specified in the `value` attribute as a `Unified-EL` expression. 
In JSF versions prior to 2.0, this value expression must return a value of type `SelectItem`, `SelectItem[]`, `Collection` (from `SelectItem` instances), or `Map`. 
For a `Map`, the `key` is used as the `itemLabel` and the `value` as the `itemValue`. 
As of JSF 2.0, a list of POJOs (Plain Old Java Objects) is enough - but more on that later.

If individual values ​​are to be displayed in addition to a dynamic selection list, they can be used together with `f:selectItem`. 
For example, this combination can add a blank element to a list of values. 
Listing <<.`f:selectItems` in Action, `f:selectItems` in Action>> shows an example of choosing `preferredCategories` in MyGourmet with a combination of `f:selectItems` and `f:selectItem` tags.

.`f:selectItems` in Action
[source,xhtml]
----
<h:selectManyListbox id="prefCat" value=
    "#{customerBean.customer.preferredCategories}">
  <f:selectItems value="#{customerBean.categories}"/>
  <f:selectItem itemValue="CN" itemLabel="Chinese"/>
</h:selectManyListbox>
----

Excerpts from the managed bean for this example can be found in Listing <<.Extract from Managed Bean for `UISelectItems`, Extract from Managed Bean for `UISelectItems`>>.

.Extract from Managed Bean for `UISelectItems`
[source,java]
----
public List<SelectItem> getCategories() {
  if (categories == null) {
    categories = new ArrayList<SelectItem>();
    categories.add(new SelectItem("IT", "Italian"));
    categories.add(new SelectItem("AT", "Austrian"));
  }
  return categories;
}
----

Listing <<.HTML code of the `UISelectItem` and `UISelectItems` component, HTML code of the `UISelectItem` and `UISelectItems` component>> displays the generated HTML code.

.HTML code of the `UISelectItem` and `UISelectItems` component
[source,html]
----
<select id="form:prefCat" name="form:prefCat"
    multiple="multiple" size="5">
  <option value="IT">Italian</option>
  <option value="AT">Austrian</option>
  <option value="CN">Chinese</option>
</select>
----

Starting with version 2.0, JSF allows a number of new attributes for `f:selectItems` to be used to generate the selection objects similar to the iteration of a `Data-Table` via a `List`. 
The creation of `SelectItem` instances in the `Managed-Bean` is then no longer necessary.

As with `h:dataTable`, the `var` attribute defines a `name` over which the current element is available when iterating. 
This name is then used in the `itemLabel` and `itemValue` attributes in value expressions to set the `value` and `label` of a single option.

Let's look at a short example. 
Listing <<.`f:selectItems` with attribute `var`, `f:selectItems` with attribute `var`>> shows the modified tags for the declaration of the selection list.

.`f:selectItems` with attribute `var`
[source,xhtml]
----
<h:selectManyListbox id="prefCat" size="5"
    value="#{customerBean.customer.preferredCategories}">
  <f:selectItems value="#{customerBean.categories}"
      var="cat" itemLabel="#{cat.name}" itemValue="#{cat.abbr}"/>
</h:selectManyListbox>
----

In Figure <<.Data flow at `f:selectItems` with attribute `var`, Data flow at `f:selectItems` with attribute `var`>>, you can see what the associated data flow looks like. 
The list referenced in the `value` attribute contains `five` beans of type `Category` - with the `name` and `abbr` properties. 
While going through the list the current bean is under the in `var` distinguished name `cat` stored. 
This creates an instance of the `SelectItem` class - with `cat.name` as the `label` and `cat.abbr` as the `value`. 
These Select-Items then represent the possible options of the selection list.

====
.Data flow at `f:selectItems` with attribute `var`
image::images/selectitems.jpg[]
====

Object groups: When using `h:selectItems`, individual elements of the list can also be grouped. 
To do this, JSF provides the `SelectItem`- derived class `SelectItemGroup`. 
The changes to the `Managed-Bean` to use collections are marginal (Listing extract from `Managed-Bean` for collections).

[source,java]
----
public List<SelectItem> getCategories() {
  if (categories == null) {
    categories = new ArrayList<SelectItem>();
    SelectItem[] euItems = {
      new SelectItem("IT", "Italian"),
      new SelectItem("AT", "Austrian")
    };
    SelectItemGroup euGroup = new SelectItemGroup(
        "Europe", null, true, euItems);
    categories.add(euGroup);
    categories.add(new SelectItem("MX", "Mexican"));
  }
  return categories;
}
----

The associated HTML code is shown in Listing <<.HTML code of the `UISelectItem` and `UISelectItems` component, HTML code of the `UISelectItem` and `UISelectItems` component>> with grouping.

.HTML code of the `UISelectItem` and `UISelectItems` component, HTML code of the `UISelectItem` and `UISelectItems` component
[source,html]
----
<select id="form:prefCat" name="form:prefCat"
    multiple="multiple" size="5">
  <optgroup label="Europe">
    <option value="IT">Italian</option>
    <option value="AT">Austrian</option>
  </optgroup>
  <option value="MX">Mexican</option>
</select>
----

=== Panel Components

Grouping components in a container uses the `UIPanel` component. 
Actions such as showing or hiding all components can be performed together for components nested in a panel tag.

The HTML tag library provides the `h:panelGrid` tags to create a customizable `header` and `footer` `table` and `h:panelGroup` for easy grouping of items. 

Elements grouped with `h:panelGroup` are rendered either as an `inline element` or, as of JSF 1.2, optionally as a `block element`. 
A `block element` is always rendered by the browser in a new line, an `inline element` does not create a line break unless the line is over. 
The output method is controlled with the attribute `layout`: The value `block` results in an output as `<div />` element, all other values output a `<span />` element. 

An `h:panelGrid` element creates a table and arranges child components in the rows and columns. 
This requires the number of columns with the attribute `columns` to be defined. 
This places the first element contained in the first row in the first column, the second element in the first row in the second column, and so on up to the column defined with columns. 
The subsequent element is then placed in the second row in the first column and the process continues according to the same pattern (Listing <<.The panel grid component `h:panelGrid`, The panel grid component `h:panelGrid`>>).

.The panel grid component `h:panelGrid`
[source,xhtml]
----
<h:panelGrid columns="3" styleClass="table-background"
    width="40" columnClasses="table-odd-col, table-even-col"
    footerClass="table-footer" headerClass="page-header">
  <f:facet name="header">
    <h:outputText value="Kopfzeile"/>
  </f:facet>
  <h:outputText value="(1,1)"/>
  <h:outputText value="(1,2)"/>
  <h:outputText value="(1,3)"/>
  <h:outputText value="(2,1)"/>
  <h:outputText value="(2,2)"/>
  <h:outputText value="(2,3)"/>
  <f:facet name="footer">
    <h:outputText value="Fußzeile"/>
  </f:facet>
</h:panelGrid>
----

The number of child components in a `h:panelGrid` component should always be a multiple of the defined number of columns. 
If this does not work out or if an `empty` cell is needed, an empty `h:panelGroup` element can be inserted. 
If you want to display multiple components in a cell of the table, you can also group them with a `h:panelGroup` element.

`h:panelGrid` can be expanded with `facets` by a `header` and a `footer`. 
For this one is simply `Facet` with a distinguished name - `header` for `header` and `footer` added as a child element - the footers.

Design: The layout of each table part can be determined by including CSS stylesheet classes in the `columnClasses`, `footerClass`, `headerClass`, and `rowClasses` attributes. 
If `headerClass` specified, this class is on the Header-Facet applied, the same applies to `footerClass` and a Footer-Facet.

[source,html]
----
<table class="table-background" width="40">
  <thead>
   <tr>
     <th class="page-header" colspan="3" scope="colgroup">
     Kopfzeile</th>
   </tr>
  </thead>
  <tfoot>
   <tr>
     <td class="table-footer" colspan="3">Fußzeile</td>
   </tr>
  </tfoot>
  <tbody>
   <tr>
     <td class="table-odd-col">(1,1)</td>
     <td class="table-even-col">(1,2)</td>
     <td class="table-odd-col">(1,3)</td>
   </tr>
   <tr>
     <td class="table-odd-col">(2,1)</td>
     <td class="table-even-col">(2,2)</td>
     <td class="table-odd-col">(2,3)</td>
   </tr>
  </tbody>
</table>
----

=== `UIViewRoot`

The component `UIViewRoot` maps the root element of the component tree. 
Through the `UIViewRoot` component, all elements of the tree can be accessed, but it is not displayed. 
The tag of the component is located in the core tag library and is integrated into a page declaration with `f:view`.

`f:view` provides some useful attributes for working with JSF on a daily basis. 
The `locale` attribute can be used to set the localization for the component tree and the page rendered from it. 
Valid values ​​for `locale` are `Strings` that contain a localization code (such as "de" or "en"), or instances of the class `java.util.Locale`. 
In JSF 1.2 two further interesting attributes have been added: `beforePhase` and `afterPhase` offer the possibility to include `Phase-Listeners` for the page with a `Method-Expression`. 
These listeners are called before or after each phase (except for the `Restore-View` phase). 
The method must have the following signature:

----
void phaseListener(javax.faces.event.PhaseEvent ev)
----

All that remains to be done is why phase listeners registered with the `beforePhase` and `afterPhase` attributes are not executed for the first phase: There is no component tree at the beginning of the first phase. 
Therefore, `UIViewRoot` can not trigger events.

=== message components

When executing a request, for example, messages (messages) may be created during validation, conversion or event handling. 
Messages become instances of the `FacesMessage` class in JSF. 
Using the `h:message` or `h:messages` component, these messages can be presented to the user. 
Each message has a severity level (there are levels `Info`, `Warn`, `Error`, `Fatal`) and descriptive information. 
Details of the JSF messaging system are covered in the Section: [Messaging section]. 

Styling of Messages: By incorporating CSS classes or CSS styles, it is possible to display messages differently depending on their severity. 
For this, the attributes `infoClass`, `infoStyle`, `warnClass` and `warnStyle`, `errorClass`, `errorStyle`, `fatalClass` and `fatalStyle` with the reference to the displayed CSS style or the CSS class to be displayed are used.

A message - `h:message`: To display only a single `FacesMessage` for a particular component, the `h:message` Tag used. 
If multiple messages are generated for the component, only the first one is displayed with this component. 
The attribute for the `id` of that component is referenced for the first message to be displayed. 
In Listing <<.`h:message` in action, `h:message` in action>>, the input field for the `birthday` from MyGourmet is specified with an `h:message` tag for the component.

.`h:message` in action
[source,xhtml]
----
<h:inputText id="birthday" size="30"
    value="#{customerBean.customer.birthday}">
  <f:convertDateTime pattern="dd.MM.yyyy"/>
  <f:validator validatorId="at.irian.Birthday"/>
</h:inputText>
<h:message for="birthday" showDetail="true" showSummary="true"
   warnStyle="color: green" infoStyle="color: blue"
   errorStyle="color: red"/>
----

If the user enters a date of birth in the future, a validation error will be thrown and a message will be generated in the output with the CSS style "color: red" (the severity of any standard validation message is error). 

If the `showDetail` attribute of the message component is set to `true`, the detailed error information is displayed; if `showSummary` is set to `true`, a summary of the error information is displayed. 
If both attributes have the value `true`, the summary and the detailed information are output.

All Messages - `h:messages`: Multiple messages can be viewed using the `h:messages` component. 
If the `globalOnly` attribute is set to `false`, all messages are displayed; if set to `true`, only messages that do not belong to a component are output (typically messages triggered by `Event-Listener` or `Action-Methods`) were). 
With `layout` the display type of the message is determined. 
With layout = "list", the messages are output one by one in an HTML list element, with layout = "table" the individual messages are displayed in table rows.

Each page with messages element: When developing a web application, do not forget to include a message output element in the page to instantly recognize validation and conversion errors. 
Typical Impact: Navigation fails when converting or validating fails. 
JSF will support you from version 2.0 onwards and automatically inserts a `h:messages` component into the view if none exists - but only if the `Project-Stage` is set to `Development` (see section [Section: Project-Stage])

=== Components for `GET` navigation

The component `UIOutcomeTarget` has been included in the standard with version 2.0 of JSF and forms a central aspect of the extended support of `GET` requests and bookmarks. 
The task of this component is to create a `hyperlink` that, when activated, makes a simple `GET` request, but still uses the navigation mechanism of JSF.

The HTML tag library has tags for two occurrences of this component that differ only in the type of rendered output:

* `h:link` is rendered as a link.
* `h:button` is rendered as a button.

Both components have the attributes `value` and `outcome`, with which the `hyperlink` is defined. 
The value of `value` appears in the rendered output as the text of the link or button, depending on the Tag. 
Crucial to the target of the link is the value of the attribute, which is passed to the navigation handler when the component is rendered. 
This tries to find a navigation case where `from-outcome` matches the value of `outcome`. 
If the search is `unsuccessful`, the value of `outcome` is interpreted directly as a `View-ID`.

Listing <<.`h:link` in action, `h:link` in action>> shows two examples of `h:link` with a direct link to the view `/showCustomer.xhtml`. 
In contrast to "classic" navigation, the goal of the navigation is already determined here in the `Render-Response` phase, not just in the `Invoke-Application-Phase` in post back. 
With `f:param` it is possible to attach parameters to the link, as the second tag shows.

[source,xhtml]
----
<h:link outcome="/showCustomer.xhtml"
    value="#{msgs.menu_show_customer}"/>
<h:link outcome="/showCustomer.xhtml"
    value="#{msgs.menu_show_customer}">
  <f:param name="id" value="1234"/>
</h:link>
----

Unlike the command components, `h:link` and `h:button` need not be embedded in an `h:form` tag. 
For more information about support for bookmarks and `GET` requests, see [Section: Bookmarks] and `GET` Requests in JSF.

=== Resource-related components

With JSF 2.0, a standardized method of managing resources such as `stylesheets` or `scripts` has become standard. 
At this point, we only want to give a brief overview and not go into detail about resource management. 
A more detailed description follows in Chapter [Chapter: Resource Management].

The following new tags of the HTML tag library allow the comfortable insertion of resources into the view:

* `h:outputScript` outputs a script resource.
* `h:outputStylesheet` outputs a stylesheet resource.

In the simplest case, resources are identified by their file name. 
Optionally, they can also be grouped in libraries that also have a name. 
In the above two tags these values ​​can be entered directly into the attributes `name` and `library`.

For example, the following tag inserts the `main.css` stylesheet from the `styles` `library` into the view:

----
<h:outputStylesheet name="main.css" library="styles"/>
----

Internally, JSF creates the file name `/styles/main.css` from there and then tries to find this file in the following order:
* `/resources` in the root of the application
* `/META-INF/resources` in jar files in `classpath`

In addition, JSF allows the positioning of individual resources in defined areas of a view, such as the `head` or the `body`. 
For JSF to correctly identify these areas, there are the following new components in the HTML Tag Library:

* `h:head` encloses the head area of ​​the page.
* `h:body` encloses the body area of ​​the page.

When integrating a script resource with `h:outputScript`, the desired area can be specified with the attribute `target`. 
The allowed values ​​are `head`, `body` and `form`.

If you use resources in your application, you should use `h:head` and `h:body` in each view. 
Otherwise, the correct loading of resources is not guaranteed. 
This also applies if you are using a component library that manages its resources with JSF. 
In this case, however, it may be that the library offers its own components for this purpose.

=== Behavioral Interfaces

In JSF, there are several interfaces that define a particular behavior of components. 
When introducing the standard components, you may have noticed that a number of them have similar patterns of behavior. 
For example, there are some components that have one value, others can even change that value, and still others trigger an action event when a user activates it.

As a user of the component, in addition to the behavior, you can also read from the interfaces implemented by the component which objects you can attach to the component. 
For example, a `Validator` is only allowed for components whose value can be changed.

Here is a selection of the most important behavioral interfaces:

* ActionSource2 +
The interface `ActionSource2` is the "successor" of `ActionSource` from JSF 1.2, which became necessary due to the conversion of method bindings to method expressions.

Components that implement this interface are sources of action events and allow the addition of `Action-Listener`. +
For example, `ActionSource2` is implemented by `UIComponent`.

* ValueHolder

Components that implement this interface have a `value` that can be set via a `Value-Expression`, but also locally, and support converters. 
`ValueHolder` is implemented by `UIOutput`, for example.

* EditableValueHolder
This interface is derived from `ValueHolder` and extends its behavior. 
Components that implement this interface allow editing the value and appending validators. 
They also trigger `Value-Change-Events` when the value changes, allowing the user to react with `Value-Change-Listeners`. 
`EditableValueHolder` is implemented by `UIInput`, for example.

=== MyGourmet 8: Standard Components

MyGourmet 8 summarizes all the changes from the previous sections on JSF standard components. 
The individual innovations have already been explained there. 
Here only the complete example should be presented. 
In the browser, the page `editCustomer.xhtml` looks with the new fields as shown in Figure <<.MyGourmet 8: View in Browser, MyGourmet 8: View in Browser>>.

.MyGourmet 8: View in Browser
====
image::images/mygourmet08-editcustomer.jpg[]
====

The `showCustomer.xhtml` page displays the previously entered data. 
Worth mentioning here is the output of the list of preferred categories and the values ​​of the other selection fields. 
Instead of iterating over the selected categories in the view, the `preferredCategoriesString` property of the bean `customerBean` is used in the output. 
The structure of the string to be displayed is moved to the backing bean - the logic is thus defined at a central location and the page definition remains slim. 
In a similar way, the selected gender is output. 
In the model, the `gender` is stored as a single character - the property `selectedGender` the output is used in the backing bean. 
Internally, the character is converted into a readable string.

The corresponding methods of the class `CustomerBean` can be found in Listing <<.MyGourmet 8: Extract of the class CustomerBean, MyGourmet 8: Extract of the class CustomerBean>>.

.MyGourmet 8: Extract of the class CustomerBean
[source,java]
----
public String getPreferredCategoriesString() {
  StringBuilder categories = new StringBuilder();
  List<String> cats = customer.getPreferredCategories();
  if (cats != null) {
    for (String cat : prefCats) {
      if (categories.length() > 0) {
        categories.append(", ");
      }
      categories.append(getCategoryLabel(cat));
    }
  }
  return categories.toString();
}

public String getSelectedGender() {
  return customer.getGender() != null
      ? getGenderLabel(customer.getGender()) : null;
}

private String getCategoryLabel(String category) {
  FacesContext c = FacesContext.getCurrentInstance();
  return GuiUtil.getResourceText(
      c, "msgs", "category_" + category);
}

private String getGenderLabel(char gender) {
  FacesContext c = FacesContext.getCurrentInstance();
  return GuiUtil.getResourceText(
      c, "msgs", "gender_" + gender);
}
----

The output of the selected gender can alternatively be made via a map with the gender as the key and the string as the value. 
In the page, this map is used as key in an EL expression with the customer's gender:

[source,xhtml]
----
#{customerBean.genderMap[
    customerBean.customer.gender]}
----

This completes the example of MyGourmet 8. 
This is followed directly by another example, which is dedicated to the standard component `UIData` and the switching between list view and detail view.

=== MyGourmet 9: `UIData` and detail view

MyGourmet 9 demonstrates the use of the standard component `UIData` and the switching between list view and detail view. 
To do this, we expand the customer's data with a list of addresses. 
So that this address data does not have to be entered with every test run, the previous order of the pages is reversed. 
The home page is now `showCustomer.xhtml` with the list of addresses. 
The data of the customer remain editable and the individual addresses can be edited and deleted. 
In the browser, the pages then look like in Figure <<.MyGourmet 9: `showCustomer.xhtml` in Browser, MyGourmet 9: `showCustomer.xhtml` in Browser>> and <<.MyGourmet 9: `editAddress.xhtml` in Browser, MyGourmet 9: `editAddress.xhtml` in Browser>>.

====
.MyGourmet 9: `showCustomer.xhtml` in Browser
image::images/mygourmet09-showcustomer.jpg[]
====

====
.MyGourmet 9: `editAddress.xhtml` in Browser
image::images/mygourmet09-editaddress.jpg[]
====

A section of `showPersons.xhtml` with the additional `h:commandLink` tags for navigating the detail pages and deleting an address can be found in Listing <<.MyGourmet 9: Address data in `showCustomer.xhtml`, MyGourmet 9: Address data in `showCustomer.xhtml`>>.

.MyGourmet 9: Address data in `showCustomer.xhtml`
[source,xhtml]
----
<h:dataTable var="address"
    value="#{customerBean.customer.addresses}">
  <h:column>
    <f:facet name="header">
      <h:outputText value="#{msgs.zip_code}"/>
    </f:facet>
    <h:outputText value="#{address.zipCode}"/>
  </h:column>
  <h:column>
    <f:facet name="header">
      <h:outputText value="#{msgs.city}"/>
    </f:facet>
    <h:outputText value="#{address.city}"/>
  </h:column>
  <h:column>
    <f:facet name="header">
      <h:outputText value="#{msgs.street}"/>
    </f:facet>
    <h:outputText value="#{address.street}"/>
  </h:column>
  <h:column>
    <h:commandLink value="#{msgs.edit}"
      action="#{addressBean.edit(address)}"/>
     
    <h:commandLink value="#{msgs.delete}"
      action="#{customerBean.deleteAddress(address)}"/>
  </h:column>
</h:dataTable>
----


The class `Customer` is extended by the property `addresses`. 
The list consists of instances of the class `Address` with the properties `zipCode`, `city`, `street` and `country`. 
For simplicity, the list is initialized with two elements if it is empty. 
Listing <<.MyGourmet 9: Address data in Customer, MyGourmet 9: Address data in Customer>> shows the corresponding code of the class `Customer`.

.MyGourmet 9: Address data in Customer
[source,java]
----
private List<Address> addresses =
    new ArrayList<Address>();
public List<Address> getAddresses() {
  if (addresses.size() == 0) {
    addresses.add(new Address(
        1010, "Wien", "Stephansplatz 1", "Austria"));
    addresses.add(new Address(
        1040, "Wien", "Karlsplatz 1", "Austria"));
  }
  return addresses;
}
public void setAddresses(List<Address> addresses) {
  this.addresses = addresses;
}
----

The list of addresses can thus already be output. 
But how do we get from the overview page to the detail page, and also with the right data? 
The source text of `showCustomer.xhtml` shown above already reveals the complete trick. 
The key point is the use of a `Method-Expression` with one parameter, which enables the new unified EL. 
To trigger navigation to the details page, the action attribute of the `h:commandLink` element is set to #{addressBean.edit(address)}.

Let's take a look at the deletion of an address. 
We are also relying on the new unified EL back and use a `Method-Expression` with a parameter. 
The `h:commandLink` tag for deleting an address is shown in Listing <<.MyGourmet 9: Address data in `showCustomer.xhtml`, MyGourmet 9: Address data in `showCustomer.xhtml`>>. 
The `Method-Expression` in the `action` attribute transfers the address to be deleted as a `parameter` to the method. 
This gives us access to the address directly in the method, which was not so easy so far. .
The code of the action method is shown in Listing <<.MyGourmet 9: Action method for deleting an address, MyGourmet 9: Action method for deleting an address>>.

.MyGourmet 9: Action method for deleting an address
[source,java]
----
public String deleteAddress(Address address) {
  customer.getAddresses().remove(address);
  return null;
}
----

The new version of Unified EL is part of Java EE 6 and comes with all servers supporting Servlet 3.0 and JSP 2.2 (including Tomcat 7 or Jetty 8). 
If you use an older server, you still do not have to do without the most important features of the new Unified EL. 
Subsec Configuration of the Unified EL section shows how to use JBoss' alternative EL implementation.