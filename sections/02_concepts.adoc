:sectnums:
== The concepts of JavaServer Faces

On the basis of the small example developed in the last chapter, we now turn to what is behind the theory behind the source code. To do this, we'll look at the individual components of JavaServer Faces technology and analyze JSF's support for building a modern web application.

=== Tasks of JSF technology

Let's summarize what the JSF specification means - it defines a framework for developing the user interface in Java web applications. The specification serves to assist the developer in the following areas:

* Components: +
JSF makes it easy to build complete web applications from components. In addition, you can create components yourself and reuse any.

* Data transfer: +
JSF makes it very easy to transfer data from the application to the user interface (and back again).

* State storage: +
JSF enables automatic storage of the state of the application on the server or on the client.

* Event handling: +
Events generated by the user at the client can be handled on the server. To do this, event handling methods are linked to the individual components.

Due to the strict separation of the layers of the application within the meaning of the MVC architecture, the individual persons involved in the application (eg web designers, component developers and application developers) can work independently of each other.

=== JavaServer Faces in Keywords

*Component (also Component, UIComponent or Control)* +
A component is a stand-alone and reusable building block used with other components to build a page in a JSF application. JSF offers a good selection of predefined components. The palette ranges from simple output components for text or images to components for capturing user input, to complex components for displaying tables.

*View and component tree* +
All components of a page are collectively called views and are linked together in the form of a component tree. The root of this tree is the UIViewRoot component, all other components are attached as children and children of these children under this element. All JSF-related operations in the flow of a request to the application start by calling a method on that UIViewRoot element that recursively passes the call on to its children.

*Renderer* +
The actual output of the component and its data and the removal of the data changed by the user at the client is done by the renderer. One component can be connected to many renderers - depending on the output technology, a specific renderer is selected, thus changing the appearance of the component. Renderers are optional - the component can also determine its own appearance and then performs the output process "independently".
Page declaration language (also called View Declaration Language, VDL)
A page declaration language (VDL) is a syntax for declaring views or pages for JSF. This concept was introduced in JSF 2.0 as part of the integration of facelets to abstract from the technology used. The standard in version 2.0 with Facelets and JSP supports two concrete implementations of a VDL. However, JSP is only supported for compatibility reasons and only offers some of the new features.

*Validator* +
The values ​​entered by the user may not always be correct - for example, the user may not have entered a value in a required field or entered a value that is too long in a length-limited text field. For such cases, there are easy-to-use validators in JSF. These validators check the validity of the values ​​entered and prevent the writing back of invalid values ​​to the model.

*Converter* +
For web applications, it is necessary to convert the data types provided by the application logic into a string, since the browser can only process and display strings. Also there is a help in the JSF technology, which is called converter. It converts the data types used by business logic into strings, and converts those strings back to Java-compatible data types after being modified by the user. If an error occurs in the conversion, as with the validators, the values ​​are not written back to the model.

*Managed beans (also called backing beans)* +
Behind the components are managed beans, which provide the actual values ​​for filling the components. They are - as already shown in the first example - centrally defined and can either be separate for each user or be valid centrally for the entire application. Managed beans are simple Java classes, also known as plain old Java objects ( POJOs ), which must comply with the JavaBeans standard.

*Unified Expression Language (also Unified EL)* +
The Unified Expression Language is the link between the components of a view and the underlying managed beans. Value expressions combine managed bean properties with component attributes-not just to read the values ​​of a bean, but also to write back user input. Method expressions allow the linking of components with methods. A concept used, for example, in the validation of user input and event handling.

*Events and event handling* +
Events are one of the key elements of JavaServer Faces technology. For example, an event occurs in a JSF application when a button is pressed or a value is changed. Each component can trigger events and each managed bean can be registered as an interested party for such events. In addition to the events already defined for the default components, new events (for custom components) can be included in JSF event handling.

*Navigation and actions ( navigation-rules, action )* +
Navigation in a JSF application was defined before JSF 2.0 exclusively via so-called navigation rules in faces-config.xml. JSF uses the return value of special methods, called "action" methods (which are called when an Action event is handled), to cause a redirect from one page to the next. This return value can be the name of a navigation rule or directly from JSF 2.0 the name of the next page.

*Messages* +
If errors occur while processing methods or validating and converting values, these errors must be displayed to the user. Validation and conversion errors are translated into messages in JSF that can then be viewed on the page. 

The temporal interaction of these individual objects in the JSF technology is precisely regulated, namely in the "Request Processing Lifecycle" called life cycle of an HTTP request. We will take a closer look at this "lifecycle" in section [Section: Life Cycle of an HTTP Request in JSF] . First, however, we will demonstrate in the following section the relationship between some of these basic concepts using the example of MyGourmet 1.

We will be using a lot of terms from the JSF technology throughout this book. To give an overview, we will briefly look at the definition of the most important terms in advance.

=== MyGourmet 1: Keywords in action

The last section briefly explained the most important basic terms of JavaServer Faces. After this rather theoretical consideration we want to try to connect these catchwords with the already known example MyGourmet 1. The starting point in Listing MyGourmet 1: The page editCustomer.xhtml is the code of the page declaration editCustomer.xhtml.

.editCustomer.xhtml
[source,xhtml]
----
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://xmlns.jcp.org/jsf/core"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<head>
  <title>MyGourmet - Edit Customer</title>
</head>
<body>
  <h1><h:outputText value="MyGourmet"/></h1>
  <h2><h:outputText value="Edit Customer"/></h2>
  <h:form id="form">
    <h:panelGrid id="grid" columns="2">
      <h:outputLabel value="First Name:" for="firstName"/>
      <h:inputText id="firstName"
          value="#{customer.firstName}"/>
      <h:outputLabel value="Last Name:" for="lastName"/>
      <h:inputText id="lastName"
          value="#{customer.lastName}"/>
      <h:commandButton id="save" action="#{customer.save}"
        value="Save"/>
    </h:panelGrid>
  </h:form>
</body>
</html>
----

If a user wants to view this page in the browser, they must type editCustomer.jsf in the address bar. However, we have always created XHTML files with the extension .xhtml. Where does this difference come from and why does an output appear in the browser window at all? This question is answered easily. Outwardly, only the JSF view editCustomer.jsf is visible, which is internally built on a so-called page declaration. In "standard" JSF, this is an XHTML file for facelets or a JSP file with the same name as the corresponding JSF view. The JSF implementation knows how the path of the associated page declaration looks relative to the context of the web application - in our case /editCustomer.xhtml, This path of the page declaration is also called a view identifier.

The page declaration determines the content and structure of the component tree, and thus the view. The tags of the XHTML page are translated from facelets into components and arranged in the component tree. Figure MyGourmet 1: From the page declaration to the component, this implementation shows an example on the tag of the input component for the first name.

====
.MyGourmet 1: From the page declaration to the component
image::images/mygourmet01-template2component.jpg[]
====

In the same way all other tags of the page are converted into components and inserted into the tree. The finished component tree of the editCustomer.jsf view looks like MyGourmet 1: Component Tree in Figure . The names of the nodes in the figure are the names of the component classes used.

====
.MyGourmet 1: component tree
image::images/mygourmet01-componenttree.jpg[]
====

The ready-built component tree can now be converted from a renderer to an output language and displayed to the user. In most cases, the output will be HTML pages, but replacing the renderer will allow almost any output technology to be used. However, for the moment we want to limit ourselves to HTML. The renderer thus takes the data stored in the component instance and outputs the corresponding HTML code for the respective component. Figure MyGourmet 1: From the component to the HTML output, for example, shows how the input component for the first name is converted to HTML.

====
.MyGourmet 1: From component to HTML output
image::images/mygourmet01-component2html.jpg[]
====

The representation of the completely rendered page in the browser can be seen in the browser in Figure MyGourmet 1: editCustomer.xhtml.

====
.MyGourmet 1: editCustomer.xhtml in the browser
image::images/mygourmet01-screenshot.jpg[]
====

The relationships between page declaration, component tree and rendered output should therefore be clarified. However, we have left out the concrete process of the entire process in the form of the JSF life cycle. These temporal relationships and processes are discussed in section [Section: Life Cycle of an HTTP Request in JSF]. But before we throw in section [Section: Managed beans] yet a closer look at Managed beans and Section [Section: The Unified Expression Language] on the connection between the model and view with the Unified Expression Language.

=== Managed Beans

The managed beans are a central component of the JavaServer Faces. They form the model or the connection to the model and the business logic in an application. With regard to a strict separation of presentation and logic they play a very important role. In practice, the business logic calls in an application are completely encapsulated in the managed beans. The connection to the properties and methods of a managed bean is realized with unified expression expressions.

The remainder of this section discusses the basics and details of managed beans. For more detailed information about the Unified Expression Language, the link between view and model in JSF, see section [Section: The Unified Expression Language].

==== Managed Beans - The Basics

What must a managed bean look like in JSF so that it can be used? The requirements are minimal: managed beans are simple Java classes, also known as plain old Java objects ( POJOs ), which must comply with the JavaBeans standard. For the class itself, this just means that it must have a constructor without parameters with visibility public.

As mentioned earlier, JSF accesses the properties of the managed beans to read and write data. A property has a name, a type, and methods for reading and writing the value. The names of these methods must conform to the following convention: getPropertyName is the name of the method for read access and setPropertyName is the name of the write access method. Whether the method accesses a private variable of the class, or whether it involves a complex operation of business logic, is transparent and ultimately irrelevant. Outwardly, only the property of the bean is visible in both cases. 

Listing Managed Bean class Customer from MyGourmet 1 once again shows the class Customer from our example MyGourmet 1. This bean has the properties firstName and lastName of the type String, which are defined by the respective getter and setter methods. The access in the view is done with the expressions # {customer.firstName} and # {customer.lastName}. Depending on whether the value in the accessing component is read or written, the corresponding getter or setter is used. The names of the properties are derived from the getter and setter names. The private fields in the background have no effect on the name - they only record the value of the property.

The save method fulfills another purpose. It is used to handle events and is not associated with any property - more detailed information on this topic can be found in the section [Events and Event Handling].

.Customer.java
[source,java]
----
import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;

@ManagedBean
@SessionScoped
public class Customer {
  private String firstName;
  private String lastName;
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getLastName() {
    return lastName;
  }
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
  public String save() {
    return "/showCustomer.xhtml";
  }
}
----

Bean properties do not necessarily have to have both a getter and a setter method. Depending on which of the two is present, then it is a property that can only be read or written.

In fact, in the last few paragraphs, we talked only about JavaBeans. They become managed beans only when they are actually managed by JSF. How it works is shown in the next section.

==== Configuration of managed beans

One of the cornerstones of JSF is the central point for managing managed beans - the Managed Bean Creation Facility. The following tasks are performed with this instrument:

* Declaration of all managed beans
* Defining the lifetime of the managed beans
* Automatic generation, initialization, use and deletion of the managed bean instances
* Provision of Managed Beans via the Expression Language (EL). For example, value expressions and method expressions can be referenced to business objects.
To be able to use managed beans in the view, the JSF environment must know under which name and under which class the respective JavaBean can be found. Since JSF 2.0 there are two variants to perform this registration. In the introductory example, we have already seen how a managed bean is declared via annotations. Listing configuration of the bean customer from MyGourmet 1 via annotations again shows the relevant part of the class. Alternatively, managed beans can also be declared in faces-config.xml - in JSF versions prior to 2.0 this was the only option.

----
@ManagedBean
@SessionScoped
public class Customer {
  ...
}
----

Listing configuration of the bean customer from MyGourmet 1 in faces-config.xml shows how the configuration of the bean customer from MyGourmet 1 looks in the faces-config.xml file.

.faces-config.xml
[source,xml]
----
<managed-bean>
  <managed-bean-name>customer</managed-bean-name>
  <managed-bean-class>
    at.irian.jsfatwork.gui.page.Customer
  </managed-bean-class>
  <managed-bean-scope>session</managed-bean-scope>
</managed-bean>
----

The two variants presented in the Listings configuration of the bean customer from MyGourmet 1 via annotations and configuration of the bean customer from MyGourmet 1 in faces-config.xml lead to the same result: The managed bean with the name customer is defined. Which of the two you use in your project is partly also a matter of taste. We chose annotations in MyGourmet to avoid bloated configuration files.

In faces-config.xml, the declaration of a bean takes place in an element called managed-bean. Nested in it follows the managed-bean-name element first the name under which the bean is referenced in EL expressions - in our example, customer. The class of the bean is specified in the managed-bean-class element. Finally, in the managed-bean-scope element with session, the lifetime of the bean is specified.

When declared with the annotation @ManagedBean, the name of the managed bean is conventionally the same as the class name with a small initial letter. For example, in our case, the customer class becomes the bean customer. If you want to use a different name, you can set it in the element name of the annotation. listing Configuration of the bean customer with an alternative name shows the already known bean with the explicit name customerBean. Access in the view is now with the expression # {customerBean.firstName}.

----
@ManagedBean(name = "customerBean")
@SessionScoped
public class Customer {
  ...
}
----

Default JSF defines scopes for beans (in brackets is the configuration value in faces-config.xml and annotation):

* None scope ( none, @NoneScoped ): +
The managed bean is recreated each time it is called.
* Request scope ( request, @RequestScoped ): +
The managed bean survives for the duration of an HTTP request.
* View Scope ( view, @ViewScoped ): +
The lifetime of the managed bean is linked to the view in which it is used.
* Session Scope ( session, @SessionScoped ): + 
The managed bean lives for the duration of a session in which the user is connected to the application.
* Application scope ( application, @ApplicationScoped ): + 
For the lifetime of the application, only one instance of this managed bean exists for all users.

Picture comparing the life of different scopes compares the life of the scopes provided by default JSF.

====
.Comparison of the lifetime of different scopes
image::images/managed-bean-scopes.jpg[]
====

Now that you understand how managed beans are declared, we do not want to deny you how JSF manages them. The internal process for accessing a bean is as follows:

. When the bean is first accessed, it is automatically instantiated by the Managed Bean Creation Facility. If the instance of the bean already exists, it will be returned. The instantiation can only occur if a constructor without arguments is available.
. After creating the bean, all managed properties are initialized. More details can be found in section [Section: Managed Properties] .
. Finally, the managed bean is stored under the specified lifetime.

In our example, this is done in the session scope, i.e., as long as there is a logical connection between the user and the application in the form of a session. Only use the session scope if absolutely necessary. With the new view scope, it is now relatively easy to take data across multiple requests. At least until you navigate to a new page.

==== Managed properties

The Managed Bean Creation Facility provides the ability to initialize properties of managed beans after creation (so-called managed properties). In addition to fixed values, Dependency Injection also provides the ability to use dependencies on other beans for initialization.

As with the configuration of the beans themselves, there are also two variants for the declaration of the managed properties. The @ManagedProperty annotation directly annotates the fields of the property in the bean. The initial value for this method is in the value element. Alternatively, the same declaration can be made in the faces-config.xml. Added to this is the element managed-property is used, where the name of the property and the value to be set are in the property-name and value elements.

Listing Managed Properties Annotation shows the Java code of an annotated managed bean with managed properties. Listing managed properties in the configuration show the equivalent configuration in faces-config.xml . Of course, the annotations in the class login are not necessary in this case.

.Login.java
[source,java]
----
@ManagedBean
@SessionScoped
public class Login {
  @ManagedProperty(value = "3")
  private int loginRetries;
  @ManagedProperty(
    value = "#{roleResolver.defaultResolver}")
  private RoleResolver roleResolver;
  ...
}
----

.faces-config.xml
[source,xml]
----
<faces-config>
  ...
  <managed-bean>
    <managed-bean-name>login</managed-bean-name>
    <managed-bean-class>
        at.company.webapp.model.Login
    </managed-bean-class>
    <managed-bean-scope>session</managed-bean-scope>
    <managed-property>
      <property-name>loginRetries</property-name>
      <value>3</value>
    </managed-property>
    <managed-property>
      <property-name>roleResolver</property-name>
      <value>#{roleResolver.defaultResolver}</value>
    </managed-property>
  </managed-bean>
  ...
</faces-config>
----

After initializing the login, its loginRetries attribute has the value 3. The roleResolver attribute shows that the value can be a reference to another managed bean - via a value expression. All other attributes have their default values.

The use of managed beans to initialize managed properties is limited in JSF. A managed property can not be initialized with a managed bean that has a shorter lifetime. For example, it is not allowed to inject a bean in the request scope into a bean in the session scope. The explanation for this is simple: Since a session runs longer than a request, the injected bean is out of date after the first request. Beans in the None Scope, on the other hand, can always be used because they are not stored in any scope.

Initialization with dependency injection references offers some advantages over bean resolution in the code. On the one hand, static calls in the code can be avoided, and on the other hand, maintainability and clarity increase due to the central configuration.

The Managed Bean Creation Facility is JSF's ability to create beans - but by far not the only one possible. With CDI and Spring, there are alternatives that are clearly superior in configuration scope and extensibility, but without unnecessarily increasing the complexity of the application. In the Section: Beans and Dependency Injection with CDI section, we show how managed beans are managed with CDI and the benefits of doing so.

==== The role of managed beans

So far, we've assumed that the managed beans are the model of the application according to the MVC design pattern. It does not necessarily have to be that way - in most cases it's even better if the managed beans are not directly the model, but only a mediator between view and actual model.

How can you imagine that? A simple example, based on MyGourmet 1, helps clarify this issue. In MyGourmet 1, the managed bean is the model of the application; accessing the customer's first name looks like this: # {customer.firstName}, In addition to the model properties of the customer, the bean also contains the action methods for event handling. The disadvantage of this variant is the close coupling of GUI logic and model, which has a negative impact especially when it comes to changes.

A more elegant solution is to completely free the model class Customer from JSF code and introduce a customer bean managed bean that has a Customer property in addition to the GUI logic. Access to the customer's first name looks like this: # {customerBean.customer.firstName}, In this variant, the model class can be created independently of the presentation layer in a lower layer of the application. The two variants are shown in Figure The Role of Managed Beans.

====
.The role of managed beans
image::images/managed-beans-modell.jpg[]
====

For the time being, in MyGourmet we will stick to using the class Customer as a managed bean. Only in the more extensive examples from MyGourmet 5 in section [Section:  MyGourmet 5 : Conversion] is a separate class used.

=== The Unified Expression Language

A basic element of the JSF specification is the Unified Expression Language (abbreviated to Unified EL), which makes it possible to dynamically connect components of the user interface and the business data behind it. We want to read data from the model, but also write user input back to the model.

Furthermore, it has to be defined which methods treat which events. Value expressions bind component attributes to managed beans and their properties, and method expressions reference methods. As in MyGourmet 1 , we'll take a closer look at section [Unified EL Section in MyGourmet 1].

For the definition of an EL expression, a rhombus and a curly bracket precede the expression, and a curly bracket limit the expression. What is allowed between these limiters? Between these delimiters you can specify the name of managed beans or "implicit" objects, properties of these objects (separated by parent elements) or operators. These include arithmetic operators such as "+" and "-" as well as comparison operators, even the "ternary" operator ( condition? If_true: if_failure ) is allowed.

==== Unified EL in MyGourmet 1

In the example of MyGourmet 1, we have already made extensive use of value expressions to display customer data and save user input. Take the customer's first name as an example: The expression # {customer.firstName} connects the value of the input component to the property firstName of the managed bean customer. Figure Value Expression in Input Component shows the relationship between tag, component, and managed bean in more detail.

====
.Value Expression in Input Component
image::images/unified-el-value-expression.jpg[]
====

A value expression is only resolved when the value is actually read or set. Therefore, the value expression itself is stored in the component, not the value. A closer look at why this is necessary follows in the section [lifecycle of an HTTP request in JSF] over the lifecycle of JSF.

The data is already properly read when the page is displayed and written when the form is submitted. It lacks the ability to call custom code when editing the submitted page - for example, to save the user's input in the database. This is where Method Expressions come into play. If the user press save button on editCustomer.jsf page,  the server should call the save method of the bean. For command components, there is the attribute action, which can contain a method expression. In our example, this is the expression # {customer.save}. The referenced method is called when all data entered by the user has been validated and valid. The returned string is used for navigation and determines which page is displayed. Figure Method Expression in Command Component shows the component's tag and the way to call the method associated with the component.

====
.Method Expression in Command Component
image::images/unified-el-method-expression.jpg[]
====

More detailed information about the Unified EL can be found in the next section. The navigation process is described in more detail in section [Section: Navigation].

==== The unified EL in detail

Below is a brief overview of the possibilities offered by the Unified EL.

* value = "# {user.username}" +
Binds a component attribute to the username property of the managed bean named user. This means that when the component is rendered, the value is retrieved from the bean by calling getUsername(), and the value is returned to the bean by the setUsername() call in the update phase.
* rendered = "# {user.username! = null}" +
Binds a Boolean value ( true or false ) to the attribute of the component. This can be used very well to show or hide the component by setting the rendered attribute. To avoid problems, using the rendered attribute is preferable to using JSTL <c: if /> tags: , Such an expression does not update the value (there is no setter), so a compound expression can not be used for the value attribute of JSF components.
* value = "# {bill.sum * 13,7603}" +
If the value of an h:outputText component is labeled with this expression, the component will always have the current value of the property sum of the managed bean bill multiplied by 13,7603rd. However, this form of EL expressions should be used sparingly. Calculations of any kind are better off in the business logic.
* style = "# {grid.displayed? 'display: inline;' : 'display: none;'} " +
Here, the style attribute of a component is displayed either on display: inline; or display: none; A very common trick used to hide or show areas of a page on the client for certain attribute values.
* value = "Hello User # {user.username}" +
The combination of strings and unified EL expressions is also possible. In this way it is very easy to generate dynamic expressions. However, this solution has a serious drawback: When combined with the string, the value is no longer converted but simply called toString () .
* action = "# {user.storeUser}" +
Here, the action storeUser is called via a method expression. The referenced method must have the signature String storeUser() and return the string that determines navigation to the next page.
* value = "# {mapBean ['index']}" +
To access values ​​in objects that implement the Map interface, the key can be enclosed in square brackets. This notation is in principle equivalent to the dot notation, so it can also be referenced with the dot notation on the contents of a map. Conversely, it is possible to access the properties of normal beans with the notation of the square brackets. Small puzzles: Why can the notation with square brackets in certain situations be beneficial?
* value = "# {mapBean [user.username]}" +
Here's the resolution of the task: You can also nest value expressions, and then use the key to access the map or the property name to access the bean property specify via a value expression.
* value = "# {listBean [5]}" +
One final example: Here, the value of the component references the sixth entry in a list. Again, this index can be a value expression again, as in the above example.

Implicit Objects: The basis for resolving the EL expressions can be any managed bean or a list of implicit objects provided by JSF. The following list contains the most important implicit objects:

* requestScope +
Access to the request map of the external context.
* viewScope +
Access to the view map of the view root.
* sessionScope +
Access to the session map of the external context.
* applicationScope +
Access to the application map of the external context.
* view +
Access to the view root.
* param +
Access to the request parameter map of the external context.
* paramValues +
Access to the Request-Parameter-Values-Map of the external context (behaves the same as the Request-Parameter-Map, except that a string array is returned here).
* header +
Access to the request header map of the external context.
* headerValues +
Access to the request header value map of the external context (behaves the same as the request header map, except that a string array is returned here).
* facesContext +
Access to the faces context
* initParam +
Access to the init parameter map of the external context and thus to context parameters of the web application.
* cookie +
Access to the request cookie map of the external context.

Example: A common example of implicit objects: The # {param.myParam} expression can be used to access the request parameter named myParam.

==== Extensions of the Unified EL in Java EE 6

Java EE 6 brings a new version of the Unified EL with some long-awaited innovations. With the new version methods with parameters can finally be used in EL expressions. Until now this was only possible for static methods via EL functions (see section Section: Definition of an EL function).

The use of method expressions with parameters opens up a number of interesting possibilities in JSF. In the example MyGourmet 9 in Section Section: MyGourmet 9: UIData and detail view you can see how an action method with parameters for deleting an address from a list can be used.

But that is not all. As another innovation, value expressions are no longer limited to bean properties. The new unified EL allows you to call any method whose return value is the value expression value. This allows the following unified EL expressions:

* value = "# {bean.list.size ()}" +
With this expression, it is finally possible to read the number of elements of a list without detours.
* value = "# {bean.text.replaceAll (':', '_')}" +
This expression invokes the replaceAll() method on the text property of type String to replace all colons with underscores, and returns the result back. 
* value = "# {bean.findOrders (otherBean.customer)}" +
The value of this expression is determined by a call to the findOrders() method on the bean bean. The parameter customer of the bean otherBean is used as a parameter - this is also possible without any problems.
* value = "# {bean.getName ()}" +
This value expression binds the return value of the getName() method to the component. In contrast to the expression, # {bean.getName ()} can only be read - even if the method setName() exists - and is therefore not suitable for input fields.

The new version of the Unified EL is part of Java EE 6 and comes automatically with all servers that support Servlet 3.0 and JSP 2.2 (such as Tomcat 7 or Jetty 8). If you use an older server, you still do not have to do without the most important features of the new Unified EL. Subsec Configuration of the Unified EL section shows how to use JBoss' alternative EL implementation.

=== Life cycle of an HTTP request in JSF