:sectnums:
== The concepts of JavaServer Faces

On the basis of the small example developed in the last chapter, we now turn to what is behind the theory behind the source code. To do this, we'll look at the individual components of JavaServer Faces technology and analyze JSF's support for building a modern web application.

=== Tasks of JSF technology

Let's summarize what the JSF specification means - it defines a framework for developing the user interface in Java web applications. The specification serves to assist the developer in the following areas:

* Components: +
JSF makes it easy to build complete web applications from components. In addition, you can create components yourself and reuse any.

* Data transfer: +
JSF makes it very easy to transfer data from the application to the user interface (and back again).

* State storage: +
JSF enables automatic storage of the state of the application on the server or on the client.

* Event handling: +
Events generated by the user at the client can be handled on the server. To do this, event handling methods are linked to the individual components.

Due to the strict separation of the layers of the application within the meaning of the MVC architecture, the individual persons involved in the application (eg web designers, component developers and application developers) can work independently of each other.

=== JavaServer Faces in Keywords

*Component (also Component , UIComponent or Control)* +
A component is a stand-alone and reusable building block used with other components to build a page in a JSF application. JSF offers a good selection of predefined components. The palette ranges from simple output components for text or images to components for capturing user input, to complex components for displaying tables.

*View and component tree* +
All components of a page are collectively called views and are linked together in the form of a component tree. The root of this tree is the UIViewRoot component, all other components are attached as children and children of these children under this element. All JSF-related operations in the flow of a request to the application start by calling a method on that UIViewRoot element that recursively passes the call on to its children.

*Renderer* +
The actual output of the component and its data and the removal of the data changed by the user at the client is done by the renderer. One component can be connected to many renderers - depending on the output technology, a specific renderer is selected, thus changing the appearance of the component. Renderers are optional - the component can also determine its own appearance and then performs the output process "independently".
Page declaration language (also called View Declaration Language, VDL)
A page declaration language (VDL) is a syntax for declaring views or pages for JSF. This concept was introduced in JSF 2.0 as part of the integration of facelets to abstract from the technology used. The standard in version 2.0 with Facelets and JSP supports two concrete implementations of a VDL. However, JSP is only supported for compatibility reasons and only offers some of the new features.

*Validator* +
The values ​​entered by the user may not always be correct - for example, the user may not have entered a value in a required field or entered a value that is too long in a length-limited text field. For such cases, there are easy-to-use validators in JSF. These validators check the validity of the values ​​entered and prevent the writing back of invalid values ​​to the model.

*Converter* +
For web applications, it is necessary to convert the data types provided by the application logic into a string, since the browser can only process and display strings. Also there is a help in the JSF technology, which is called converter. It converts the data types used by business logic into strings, and converts those strings back to Java-compatible data types after being modified by the user. If an error occurs in the conversion, as with the validators, the values ​​are not written back to the model.

*Managed beans (also called backing beans)* +
Behind the components are managed beans, which provide the actual values ​​for filling the components. They are - as already shown in the first example - centrally defined and can either be separate for each user or be valid centrally for the entire application. Managed beans are simple Java classes, also known as plain old Java objects ( POJOs ), which must comply with the JavaBeans standard.

*Unified Expression Language (also Unified EL)* +
The Unified Expression Language is the link between the components of a view and the underlying managed beans. Value expressions combine managed bean properties with component attributes-not just to read the values ​​of a bean, but also to write back user input. Method expressions allow the linking of components with methods. A concept used, for example, in the validation of user input and event handling.

*Events and event handling* +
Events are one of the key elements of JavaServer Faces technology. For example, an event occurs in a JSF application when a button is pressed or a value is changed. Each component can trigger events and each managed bean can be registered as an interested party for such events. In addition to the events already defined for the default components, new events (for custom components) can be included in JSF event handling.

*Navigation and actions ( navigation-rules , action )* +
Navigation in a JSF application was defined before JSF 2.0 exclusively via so-called navigation rules in faces-config.xml. JSF uses the return value of special methods, called "action" methods (which are called when an Action event is handled), to cause a redirect from one page to the next. This return value can be the name of a navigation rule or directly from JSF 2.0 the name of the next page.

*Messages* +
If errors occur while processing methods or validating and converting values, these errors must be displayed to the user. Validation and conversion errors are translated into messages in JSF that can then be viewed on the page. 

The temporal interaction of these individual objects in the JSF technology is precisely regulated, namely in the "Request Processing Lifecycle" called life cycle of an HTTP request. We will take a closer look at this "lifecycle" in section [Section: Life Cycle of an HTTP Request in JSF] . First, however, we will demonstrate in the following section the relationship between some of these basic concepts using the example of MyGourmet 1.

We will be using a lot of terms from the JSF technology throughout this book. To give an overview, we will briefly look at the definition of the most important terms in advance.

=== MyGourmet 1: Keywords in action

The last section briefly explained the most important basic terms of JavaServer Faces. After this rather theoretical consideration we want to try to connect these catchwords with the already known example MyGourmet 1. The starting point in Listing MyGourmet 1: The page editCustomer.xhtml is the code of the page declaration editCustomer.xhtml.

.editCustomer.xhtml
[source,xhtml]
----
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://xmlns.jcp.org/jsf/core"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<head>
  <title>MyGourmet - Edit Customer</title>
</head>
<body>
  <h1><h:outputText value="MyGourmet"/></h1>
  <h2><h:outputText value="Edit Customer"/></h2>
  <h:form id="form">
    <h:panelGrid id="grid" columns="2">
      <h:outputLabel value="First Name:" for="firstName"/>
      <h:inputText id="firstName"
          value="#{customer.firstName}"/>
      <h:outputLabel value="Last Name:" for="lastName"/>
      <h:inputText id="lastName"
          value="#{customer.lastName}"/>
      <h:commandButton id="save" action="#{customer.save}"
        value="Save"/>
    </h:panelGrid>
  </h:form>
</body>
</html>
----

If a user wants to view this page in the browser, they must type editCustomer.jsf in the address bar. However, we have always created XHTML files with the extension .xhtml. Where does this difference come from and why does an output appear in the browser window at all? This question is answered easily. Outwardly, only the JSF view editCustomer.jsf is visible, which is internally built on a so-called page declaration. In "standard" JSF, this is an XHTML file for facelets or a JSP file with the same name as the corresponding JSF view. The JSF implementation knows how the path of the associated page declaration looks relative to the context of the web application - in our case /editCustomer.xhtml, This path of the page declaration is also called a view identifier.

The page declaration determines the content and structure of the component tree, and thus the view. The tags of the XHTML page are translated from facelets into components and arranged in the component tree. Figure MyGourmet 1: From the page declaration to the component, this implementation shows an example on the tag of the input component for the first name.