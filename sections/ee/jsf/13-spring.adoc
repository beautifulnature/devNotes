== JSF and Spring (Pending)

The use of Spring in JSF projects offers a whole range of advantages over the use of the internal Managed Bean Creation Facility. 
Among other things, Spring brings a much more powerful dependency injection mechanism, autowiring beans, and sophisticated support for Aspect-Oriented Programming (AOP), to name just a few of the benefits - all without the complexity of the application increase. 
From JSF's point of view, it makes no difference whether beans are managed via Spring or JSF internally. 
The connection between the view and the model is done in both cases via the unified EL.

After some information about configuring Spring in section [Section: Configuration of Spring] shows section [Section: Dependency injection with Spring and JSR-330] how JSF applications can be developed with Spring. 
Afterwards section [section:  MyGourmet 16 Spring : Integration of Spring] details for example MyGourmet 16 Spring.

Another important topic in web development is the mapping of business processes. 
For this purpose conversations are used more frequently. 
Why this is so shows section [Section: Conversations with JSF], If you already use Spring to manage the managed beans in your project, there's nothing standing in the way of using conversations. 
Section [Apache MyFaces Orchestra section] then shows you how to use the Spring Apache MyFaces Orchestra project.

=== Configuration of Spring

Integrating Spring into a JSF application is done in two steps. 
First, you have to configure and activate Spring itself. 
The easiest way to do this is with the Spring-integrated `Servlet-Context-Listener` `ContextLoaderListener`, which is integrated into the `web.xml` and when initializing a servlet sets up the `ApplicationContext` of Spring. 
The required configuration files get the listener from the context parameter `contextConfigLocation`. 
There you can specify a list of filenames separated by spaces, commas or semicolons. 
The paths are evaluated relative to the root of the web application and it is possible to use search patterns like `/WEB-INF/*Context.xml` or `/WEB-INF/**/*Context.xml`. 
Listing <<.configuration of Spring in the web.xml, configuration of Spring in the web.xml>> shows the necessary configuration in the `web.xml`.

.configuration of Spring in the web.xml
[source,xml]
----
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>
    /WEB-INF/spring-config.xml
  </param-value>
</context-param>
<listener>
  <listener-class>
    org.springframework.web.context.ContextLoaderListener
  </listener-class>
</listener>
<listener>
  <listener-class>
  org.springframework.web.context.request.RequestContextListener
  </listener-class>
</listener>
----

Starting with version 2.0, Spring supports the scopes request and session, which are relevant for web applications. 
In order for these to work properly, the servlet request listener RequestContextListener must also be configured in the web.xml. 
In addition, Spring allows the definition of own scopes from version 2.0. We will also take advantage of this opportunity to implement the view scope added in JSF 2.0 (see section [section:  MyGourmet 16 Spring : Integration of Spring]). 
Spring itself does not yet support this new scope in the current version.

The second step is to instruct JSF not to self-terminate managed beans, but to delegate work to Spring. 
Spring provides for this purpose a separate EL resolver, the first Managed beans on the application context of Spring dissolves before it - when the resolution was unsuccessful - passes control to the standard resolver of JSF. 
This EL resolver is configured in the application area of faces-config.xml, as shown in listing configuration of the Spring-EL resolver in faces-config.xml.

[source,xml]
----
<faces-config>
  <application>
    <el-resolver>
      org.springframework.web.jsf.el.SpringBeanFacesELResolver
    </el-resolver>
    ...
  </application>
</faces-config>
----
All information given here refers to Spring in version 2.5 or higher in combination with JSF from version 1.2. 
For older versions of Spring (whose use we no longer recommend) or JSF in version 1.1, the configuration differs in some places from the one shown here.
=== Dependency Injection with Spring and JSR-330
Starting with version 3.0, Spring supports the standard Dependency Injection for Java (JSR-330, also called At Inject ). 
JSR-330 has been the first to standardize the most important dependency injection annotations. 
This finally makes it possible to use the same annotations from the javax.inject package in different environments such as Java EE 6, Spring 3 or Guice 2. 
This approach avoids dependencies on annotations of a specific dependency injection framework.

JSR-330 covers the core area of ​​dependency injection sufficiently. However, other areas such as the definition of beans are considered only rudimentarily in JSR-330 - making it easier to use. 
Among other things, Spring supports the JSR 330 annotation @Named to register beans. 
The bean name is either specified directly in the value element or otherwise derived from the class name. 

For the scope of a bean, only the annotation @Singleton is available in JSR-330. 
All other scopes can be specified in the value element of the Spring annotation @Scope. 

Spring As of version 2.0, the following scope of validity is supported by default, which applies equally to configuration via annotations and via XML:

Prototype Scope ( prototype ): 
The bean is not saved and recreated each time it is called. Corresponds to the None scope in JSF.
Request scope ( request ): 
The bean is alive for the duration of an HTTP request. Corresponds to the request scope in JSF.
Session Scope ( session ): 
The bean is alive for the duration of a session in which the user is connected to the application. 
Corresponds to the session scope in JSF.
Singleton scope ( singleton ): 
For the lifetime of the application, only one instance of this bean is common to all users. 
Corresponds to the application scope in JSF.

The annotation of a field with @Inject is sufficient to define an injection point. 
Listing dependency injection with @Inject shows the definition of a bean with an injection point.
[source,java]
----
@Named
@Singleton
public class MyBean {
  @Inject
  private Service service;
  ...
}
----
Spring 3.0 (or any other dependency injection framework that supports JSR-330) can resolve this dependency and inject a service- type bean. 
If there are multiple beans of the same type, the selection must be further restricted. 
To this end, JSR-330 provides so-called qualifiers. 
A qualifier is any annotation that is annotated with @ javax.inject.Qualifier. 
Listing JSR-330 Qualifier shows the qualifier @Special as an example.
[source,java]
----
@Retention(RUNTIME)
@Target({TYPE, FIELD, METHOD})
@Qualifier
public @interface Special {
}
----
With such a qualifier, on the one hand, the class of the bean and, on the other hand, the injection point are annotated. 
But let's take a look at this with an example. Listing service beans with and without qualifiers shows two different implementations of the interface service. 
Both classes are defined as beans in singleton scope using the @Service and @Scope annotations. 
Since both beans have the type service (we assume that only the interface is known to the outside), we annotate the class SpecialServiceImpl with our qualifier @Special for further differentiation.

[source,java]
----
@Service("service")
@Scope("singleton")
public class ServiceImpl implements Service {
  ...
}
----

[source,java]
----
@Service("specialService")
@Scope("singleton")
@Special
public class SpecialServiceImpl implements Service {
  ...
}
----
The same qualifier annotation is also used at the injection point to restrict the selection of the Service type beans to the desired specimen. 
Listing dependency injection with @Inject and Qualifier shows the corresponding code snippet.

[source,java]
----
public class MyBean {
  @Inject @Special
  private Service service;
  ...
}
----
JSR-330 uses @Named to provide specific qualifier annotations to narrow the selection based on the name of the bean. 
For example, in listing dependency injection with @Inject and @Named, the bean of type Service named specialService is injected from listing service beans with and without qualifiers.
[source,java]
----
public class MyBean {
  @Inject @Named("specialService")
  private Service service;
  ...
}
----
Dependency Injection for Java is an important step in the right direction. In the next section, we'll look at what the use of Spring in combination with JSR-330 looks like in MyGourmet.
=== MyGourmet 16 Spring: Integration of Spring

In MyGourmet 16 Spring is all about the integration of Spring. 
The necessary libraries are integrated into the Maven project via dependencies in the `pom.xml`. 
For details, please refer directly to the source code.

The additionally necessary configuration in the `web.xml` corresponds exactly to the one presented in the last section and will not be repeated here. 
Now, for a functional system, only the XML file `spring-config.xml` referenced in the context parameter `contextConfigLocation` and the configuration of the beans are missing. 
Listing Spring configuration of MyGourmet 16 shows the complete Spring configuration for MyGourmet 16 Spring (some class names and schema locations contain a line break for space reasons, but this is not allowed).

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/
          spring-beans-3.0.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/
          spring-context-3.0.xsd">

  <!-- Classpath nach Spring-Komponenten scannen -->
  <context:component-scan base-package="at.irian.jsfatwork"/>

  <!-- View-Scope registrieren -->
  <bean class="org.springframework.beans.factory
      .config.CustomScopeConfigurer">
    <property name="scopes">
      <map>
        <entry key="view">
          <bean class="at.irian.jsfatwork.spring.ViewScope"/>
        </entry>
      </map>
    </property>
  </bean>
</beans>
----
Beans are defined in Spring either through annotations or in the XML configuration. 
Since we have configured the managed beans via annotations in all examples, we first look at this variant. 
The transition to MyGourmet is limited to replacing the JSF annotations with their JSR-330 and Spring candidates in the ProviderServiceImpl, AddressBean, CustomerBean, ProviderBean, and ProviderListBean classes. 

The implementation of the view scope for Spring is done in class at.irian.jsfatwork.spring.ViewScope, We will not show the class here, if you are interested please have a look at the source code of MyGourmet 16 Spring. 
The Scope is registered using a CustomScopeConfigurer bean, whose scopes property picks up a map of the custom scopes. 
In Listing Spring's MyGourmet 16 configuration, you can see the registration of the new view scope. 

Listing Bean Definition and Dependency Injection with Spring Annotation shows the configuration of the beans named providerService and providerBean via the annotation @Named, The example also describes how to configure dependencies between beans and annotations. 
The JSR 330 annotation @Inject on the providerService field of the ProviderBean class causes the bean with the identifier providerService to be injected into the field of the same name when you create a bean with the identifier providerBean. 
With @Inject field of class or the setter method of a property can be annotated directly.
[source,java]
----
@Named("providerService")
@Singleton
public class ProviderServiceImpl
    implements ProviderService {
...
}
----

[source,java]
----
@Named("providerBean")
@Scope("view")
public class ProviderBean {

    @Inject
    private ProviderService providerService;
    ...
}
----
However, the definition of beans via annotation works only if Spring is instructed to search classes for annotations using the context: component-scan element in the XML configuration. 
The base-package attribute defines a starting point in order to limit the search process as much as possible and not unnecessarily prolong the start of the application. 
At MyGourmet, we limit ourselves to classes whose fully qualified name begins with at.irian.jsfatwork (see Listing Spring Configuration by MyGourmet 16 ). 
As a pleasant side effect enabled context: component-scan also the processing of standard annotations like @Resource, @PostConstruct and @PreDestroy and as of Spring 3.0 also JSR 330 annotations. 

Finally, let's take a quick look at the configuration of beans over XML. 
Listing XML configuration of the beans in MyGourmet 16 Spring shows what an equivalent annotation configuration would look like in spring-config.xml. 
A bean is declared in Spring with the element bean. The name is specified in the attribute id, the scope in the attribute scope and the underlying class in the class attribute. 
The bean providerService is introduced into the bean providerBean with the child element property. 
The attribute name specifies the name of the property to be set and the attribute ref the identifier of the bean to be set.

[source,xml]
----
<bean id="providerService"
    class="at.irian.jsfatwork.service.ProviderServiceImpl"/>
<bean id="addressBean" scope="session"
    class="at.irian.jsfatwork.gui.page.AddressBean"/
<bean id="customerBean" scope="session"
    class="at.irian.jsfatwork.gui.page.CustomerBean"/>
<bean id="providerBean" scope="view"
    class="at.irian.jsfatwork.gui.page.ProviderBean">
  <property name="providerService" ref="providerService"/>
</bean>
----

What we showed you here is the simplest form of bean definition with Spring and JSR-330. 
Once Spring is up and running in JSF, all the possibilities of the Spring framework are open to you - and trust us, that's a lot. 
Particularly noteworthy here is the very good and extensive integration of Aspect Oriented Programming (AOP) for the simple implementation of cross-sectional functionality. 
Further information on Spring and Spring AOP can be found in the very successful documentation at http://www.springsource.org/documentation. 

An important application for the use of Spring with JSF is the ability to define additional scopes. 
Especially conversations are interesting here. See section [Conversations with JSF] for general information on this topic, and section [Apache MyFaces Orchestra section] shows how to use conversations with Spring and Apache MyFaces Orchestra.

=== Conversations with JSF

In many web applications, the underlying business processes can not be mapped directly to the page flow. 
Many processes that form a single entity from the user's point of view extend across multiple requests or even across multiple views in the application. 
For example, consider registering a user who asks for login information in the first step and personal data in the second step. 
For the user of the application, this process is a self-contained activity that begins with displaying the first view and is completed by pressing the Finish button in the second step.

This raises the question of the scope in which the data must be stored during the process, so that they are available in each step. 
Managed beans in the request scope are recreated after each request and therefore are not suitable. 
The view scope is only sufficient if the process does not cover more than one view. 
Managed beans in the application scope are not suitable for our purposes, because they are generated only once per application and thus all users see the same data. 
Remains as a last alternative, only the session scope left. Although the session scope solves the availability problem during the process, it does have some significant disadvantages.

At this point, conversations come into play. 
Conversations are the ideal location for managed beans whose lifetime goes beyond a request or view. 
For web applications, this case often occurs because business processes can not always be mapped directly to the application's page flow. 
Conversations offers some key advantages over the session:

A conversation, in contrast to the session, can be easily quit and removed from memory without affecting other conversations or managed beans outside the conversation.

There can be any number of conversations per user.

A conversation is usually recreated for each window or tab of the browser. 
This allows the application to run concurrently in multiple windows or tabs that do not affect each other. 
This is not so easy with the session, since most browsers use the same session for all tabs and often even for windows. 
Of course, the browser does not decide which session to use. 
However, if the same cookies are used in the browser for all tabs and windows, the server can not distinguish them.

JSF can be easily extended with conversations. 
When you use Spring, the Apache MyFaces Orchestra project provides conversations and a number of other extensions for developing web applications with JSF and Spring. 
Orchestra details can be found in section [Apache MyFaces Orchestra section].

=== Apache MyFaces Orchestra

Apache MyFaces Orchestra offers a number of enhancements to make integrating JSF and Spring as easy as possible. 
The most important feature is certainly the support of conversations. 
Therefore, the section [Conversations with Orchestra] deals completely with the topic of conversations with Orchestra and Spring.

Similar to conversations, using the Java Persistence API (JPA), the lifetime of the persistence context is an important criterion. 
As with the managed beans, problems can occur if the lifetime is set too short or too long. 
OrchestraAlso provides a solution to this problem by bringing together the persistence context and conversations. 
Further information on the persistence support of Orchestra can be found in section [Persistence section]. 

Another interesting feature offered by Orchestra is the ability to define a view controller for a view. 
It is a managed bean bound to a view through an annotation or naming convention. 
The view controller is then notified of the execution of the lifecycle at multiple locations, such as just before rendering the view, and can respond accordingly. 
Section [Section: View Controller] shows details about the View controllers and describes how they can be used in practice. 

Finally, in the section [  MyGourmet 17 Spring section : Apache MyFaces Orchestra], you will find the example of MyGourmet 17 Spring, in which some Orchestra features are put into practice.

==== Conversations with Orchestra

A conversation, like the session or the HTTP request, can be used as a scope for managed beans. 
The lifetime of a conversation begins in Orchestra with the first access to a bean in the conversation scope. 
How is it determined how long a conversation lasts? For standard scopes, the end of life is clearly defined. 
The request scope ends after each request, the session scope ends with the end of the session and so on. 

Orchestra defines two different strategies to end a conversation. Manual scope conversations must be terminated explicitly through the Orchestra API or a special tag in the page declaration. 
Alternatively, Orchestra offers also an automatic management of the service life (access scope). 
The conversation remains active across multiple requests until the properties or methods of a bean in the conversation are no longer accessed.

===== Configuration of Orchestra

Orchestra relies on Spring for the Conversation Scopes and the custom Scopes available on Spring 2.0. 
This makes it imperative that all managed beans in the conversation scope are defined via Spring. 
However, you should consider this not as a limitation, but as an opportunity - otherwise you can benefit from the configuration of your beans over Spring. 
We already covered the 

basic configuration of Spring in section [Section: Configuration of Spring]. 
Orchestra's Listing Spring configuration of the Conversation Scopes shows all for Orchestra additionally necessary entries in the Spring configuration.

[source,xml]
----
<import resource=
    "classpath*:/META-INF/spring-orchestra-init.xml"/>

<!-- Configure additional Orchestra scopes -->
<bean class="org.springframework.beans.factory.config
    .CustomScopeConfigurer">
  <property name="scopes">
    <map>
      <entry key="manual">
        <bean class="org.apache.myfaces.orchestra
            .conversation.spring.SpringConversationScope">
          <property name="timeout" value="30"/>
          <property name="lifetime" value="manual"/>
        </bean>
      </entry>
      <entry key="access">
        <bean class="org.apache.myfaces.orchestra
            .conversation.spring.SpringConversationScope">
          <property name="timeout" value="30"/>
          <property name="lifetime" value="access"/>
        </bean>
      </entry>
    </map>
  </property>
</bean>
----

First, the import element imports all of the classpath Spring configurations for Orchestra. 
Some basic settings are made in these imported files. Then again, a bean with the class CustomScopeConfigurer known from the section [  MyGourmet 16 Spring : Integration of Spring] is used to define Orchestra's two conversation scopes. 
The two scopes can be used with the names specified in the key attribute in the definition of managed beans. With access

a bean is created in the access scope and with manual a bean in the manual scope. 
The two scope definitions differ in configuration only by the different initialization of the property lifetime. 
The timeout property specifies the amount of time, in minutes, that Orchestra waits after the last access to a conversation before automatically terminating it.

When choosing this timeout, keep in mind the right ratio to the session timeout. 
If the session timeout is less than the timeout of the conversation, the conversation will already end with the session timeout if the user is completely inactive. 
However, if the user continues to work with another part of the application without accessing the open conversation, the session timeout is reset on each request. 
In this case, the timeout of the conversation takes effect. 

For Orchestra to function properly, the listener shown in Listing Configuration for Orchestra in the `web.xml` must be configured in the `web.xml`.

[source,xml]
----
<listener>
  <listener-class>
    org.apache.myfaces.orchestra.conversation.servlet
        .ConversationManagerSessionListener
  </listener-class>
</listener>
----
===== Conversations in Action

To demonstrate the new scopes, we will first change the scope of the managed bean customerBean from session to access. 
All you have to do is change the value of the value element of the @Scope annotation from session to access. 
Listing Definition of a bean in the access scope shows the class definition with the annotations. 
If the beans are defined with XML elements, then the scope attribute must be set to the value access there.

[source,java]
----
@Named("customerBean")
@Scope("access")
public class CustomerBean {
...
}
----

How does this managed bean behave in practice? In our example, the bean named customerBean is used in the showCustomer.xhtml and editCustomer.xhtml views. 
The initial call to showCustomer.xhtml creates the conversation as well as the bean. 
The name of the conversation is automatically derived from the name of the managed bean and is also customerBean. 
If the user then continues to editCustomer.xhtml to change the data and then back again, the conversation remains open. 
Only when the user invokes a view that does not have access to the properties and methods of the bean customerBeantakes place, the conversation is terminated. 
In section [Section:  MyGourmet 17 Spring : Apache MyFaces Orchestra], we'll take a closer look at the lifetime of conversations using MyGourmet 17 Spring. 

Automatic lifetime conversations are very convenient, but can sometimes lead to unexpected results. 
For example, if the managed bean is not accessed during the execution of an Ajax request, it will be used by Orchestra removed and recreated the next time you access it. 
This can lead to very unpleasant side effects that are difficult to locate. 
Equally well may be the case that a managed bean stays in storage for a very long time if it is - perhaps unintentionally - referenced in some form on several pages in a row. 
This can lead to unwanted effects, especially in combination with the persistence management of Orchestra. 
With manual life you have to decide for yourself how long the conversation is kept in memory. 

In practice, it is not always desirable for each bean to have its own conversation. 
Therefore, the name of the conversation can be explicitly specified in the value element with the @ConversationName annotation be specified. 
If two managed beans define the same name for their conversation and are used at the same time, they end up in the same conversation. 

The example in Listing Definition of two beans in the same conversation with annotation includes the beans with the names bean1 and bean2 in the manual scope whose conversation name is explicitly set to conversation. 
The conversation is created the first time you access any of the beans and remains active until manually or timed out. 
If both beans are referenced during this time, they end up in the same conversation. 
Without @ConversationName In this case, there would be a conversation with the name bean1 and one with the name bean2.

[source,java]
----
@Named("bean1")
@Scope("manual")
@ConversationName("conversation")
public class SomeBean {
...
}
----
[source,java]
----
@Named("bean2")
@Scope("manual")
@ConversationName("conversation")
public class AnotherBean {
...
}
----
The name of the conversation can also be set in XML via the conversationName attribute. Listing Definition of two beans in the same conversation with XML shows the XML variant of the example including the definition of the Orchestra namespace.
[source,xml]
----
<beans ... xmlns:orchestra="http://myfaces.apache.org/orchestra"
    xsi:schemaLocation="http://myfaces.apache.org/orchestra
    http://myfaces.apache.org/orchestra/orchestra.xsd">
...
<bean id="bean1" class="SomeBean" scope="manual"
    orchestra:conversationName="conversation"/>
<bean id="bean2" class="AnotherBean" scope="manual"
    orchestra:conversationName="conversation"/>
</beans>
----
Let's have a look at a managed bean in the manual scope. As an example, in MyGourmet 17 Spring, we will create a small wizard for creating a customer in two steps. 
The wizard includes the views addCustomer1.xhtml and addCustomer2.xhtml, which use the addCustomerBean managed bean. 
Listing Manually end a conversation through the Java API shows the relevant part of the source code of this bean in the manual scope. 
The bean and conversation are created on first access. However, since this is a manual conversation, it will not automatically stop. This task is done manually when saving or canceling the wizard in the action methods by calling the method invalidate () on the current conversation. The current conversation is returned by Conversation.getCurrentInstance (). 
Listing Manually ending a conversation through the Java API shows the two methods save () to save the new customer and cancel () to cancel the wizard.
[source,java]
----
@Named("addCustomerBean")
@Scope("manual")
public class AddCustomerBean extends CustomerBeanBase {
  ...
  public String save() {
    customerService.save(customer);
    Conversation.getCurrentInstance().invalidate();
    return ViewIds.CUSTOMER_LIST_VIEW_ID;
  }
  public String cancel() {
    Conversation.getCurrentInstance().invalidate();
    return ViewIds.CUSTOMER_LIST_VIEW_ID;
  }
}
----
A conversation can also be terminated with the endConversation tag from the Orchestra Tag Library, available through the namespace http://myfaces.apache.org/orchestra. 
This tag is added as a child tag to a command component and gets the attribute name the names of the terminating conversation. 
Listing Closing a conversation manually in the page declaration displays the cancel button of the example with the endConversation tag. Both variants fulfill the same purpose.
[source,xml]
----
<h:commandButton id="cancel" value="#{msgs.cancel}"
    action="#{addCustomerBean.cancel}" immediate="true">
  <o:endConversation name="addCustomerBean"/>
</h:commandButton>
----
When you start MyGourmet 17 Spring and click through the application in the browser, you will notice that each URL of the application has the request parameter named conversationContext. 
Orchestra uses the value of this parameter to distinguish different windows and tabs of the same browser instance. 
As you already know, conversations are placed in the session. 
In order for these conversations to be clearly mapped to a browser window or tab, Orchestra introduces the concept of conversational context. 
The value of the conversationContext parameter is the identifier of the current context and establishes the connection. 
Such a context is a container for all conversations of a window or tab. 

If the application reopens in a new window or tab, this parameter is missing and Orchestra creates a new conversation context with a new identifier. 
You can check this by running MyGourmet 17 Spring in two tabs of your browser in parallel. 
You will see that the value of the conversationContext parameter is different. 

Figure Session with Orchestra conversations represents a session with two conversational contexts in which the same conversations are active. 
This situation arises when the application is used in two windows or tabs at the same time. 
Only through the context is it possible for a conversation to exist multiple times.
 
Figure: Session with Orchestra conversations
==== Persistence
Web applications that use the Java Persistence API (JPA) to persist the data have another problem when mapping business processes. 
In addition to the lifetime of the managed beans, the lifetime of the persistence context is another crucial criterion. 
If this duration is set too short, data loading problems can occur (the LazyInitializationException should be familiar to many developers). 
On the other hand, if it is too long, the memory usage of the application increases.

Most problems stem from the fact that the lifetime of the persistence context and that of the managed beans do not match. 
In many cases, the lifetime of the beans is longer than that of the persistence context. 
Because managed beans often hold loaded entities, accessing a property that was not yet loaded before closing the persistence context becomes a dreaded LazyInitializationException. 

Orchestra Also provides a solution to this problem by linking the persistence context to a conversation and keeping it open for the life of the conversation. 
As with conversations, the persistence context should remain open as long as needed, but as short as possible. 
At the end of the conversation, the persistence context is also closed. 

Since the persistence context remains open throughout the conversation's lifetime, it is easy to work directly with the entities loaded by the database.

An important point is that each conversation receives its own persistence context and thus also its own JPA Entity Manager. 
Therefore, entities loaded in one conversation can not easily be used in another conversation because they are tied to an entity manager. 
If you need the same entity in multiple conversations at the same time, it should also be loaded independently in each conversation. 
If you want to pass an entity from one conversation to another, for example when moving from a list view to a detail view, you should only pass the ID and reload the entity in the second conversation.

Alternatively, you can also put multiple managed beans in the same conversation so they automatically use the same persistence context. 
How this works we have shown in the last section. 
However, you should be aware that memory usage increases with each loaded entity. 

We will not go into the additional configuration and practical aspects of persistence support in Orchestra here. 
After this part of Orchestra works only in combination with JPA, we will treat this topic only in chapter section: MyGourmet Full Stack Spring - JSF, Spring, Orchestra and JPA combined. 
There we show you with the help of MyGourmetHow to create a complete application with JSF, Spring, Orchestra and JPA. 

But before that happens, in the next section, we'll show you how to define Orchestra View controllers in the next section.

==== View Controller

Another interesting feature offered by Orchestra is the ability to define a view controller for a view. 
This is a managed bean bound to a view and notified at multiple points in the lifecycle execution. 
As of JSF 2.0, you can alternatively use system events to respond to life-cycle events. 

The connection between view and view controller can be defined using the annotation @ViewController on the class of the managed bean or via a naming convention. 

The @ViewController annotation in the viewIds element picks up a list of view IDs for which the bean should act as a view controller. 
listing Annotation-based definition of a view controller shows the class AddCustomerBean, which is defined as the view controller for the views with the view IDs /addCustomer1.xhtml and /addCustomer2.xhtml.
[source,java]
----
@Named("addCustomerBean")
@Scope("manual")
@ViewController(viewIds = {"/addCustomer1.xhtml",
    "/addCustomer2.xhtml"})
public class AddCustomerBean
    extends CustomerBeanBase {

  @InitView
  public void createCustomer() {
    if (customer == null) {
      customer = customerService.createNew();
    }
  }
  ...
}
----
A view controller can also be linked to a view using a naming convention. The name of the managed bean (not the class name) used as the view controller is calculated from the name of the view ID. 
To do this, all characters in the view ID are converted to uppercase after a forward slash. 
Then all slashes and all characters are removed from the first point. 
If this results in an invalid bean name, the prefix _ is prefixed. Table tab: orchestra-namemapper shows some examples.
View ID	Bean name
addCustomer1.xhtml	addCustomer1
customer / registration1.xhtml	customerRegistration1
1addCustomer.xhtml	_ 1addCustomer
The definition of the view controller via the naming convention has some disadvantages compared to the annotation-based variant. 
Annotations offer the option of using a bean as a view controller for multiple views in addition to the choice of bean names. The example from the listing annotation-based definition of a view controller can therefore not be realized in the form via the naming convention. 

Once a view is connected to a view controller, Orchestra can notify the view controller at certain times during the lifecycle execution. 
The following methods of the view controller are called:

After the restore view phase, the method of the view controller annotated with @InitView is called. 
If the method has the name initView (), the annotation can be omitted.

Before the Invoke Application phase, the method annotated @PreProcess is called. 
If the method is named preProcess (), the annotation can be omitted.

Before the render-response phase, the method annotated with @PreRenderView is called. 
If the method is named preRenderView (), the annotation can be omitted.

For example, in the view controller in Listing Annotation- Based Definition of a view controller, the createCustomer () method is annotated with @InitView. 
This method is called for the two views /addCustomer1.xhtml and /addCustomer2.xhtml after each restore view phase to initialize the customer variable if it is null. 

View controllers form the basis for another feature of Orchestra. With the annotation @ConversationRequire a number of views can be linked to a particular conversation. 
This is especially interesting for business processes that span multiple views with a defined home page. 
As long as the conversation does not exist, the user can only access the homepage. 
Each access to a different page of the process, depending on the configuration, leads to a redirect or the triggering of a navigation. 
Only when the conversation is created from the home page will the other views of the process be available. 

Let's look at this from the last example. 
Listing View Controller for a multi-view process shows the AddCustomerBean class again, this time with the annotation @ConversationRequire. 
The annotation's conversationNames element specifies any conversions whose existence should be checked before a user can access the views. 
An exception is any View ID specified in the entryPointViewIds element. These views can also be called without an existing conversation - somehow the process has to be started. 
In our example, the starting point of the flow is the view addCustomer1.xhtml. If you access addCustomer2.xhtml without the addCustomerBean conversation, you will navigate with the element navigationAction specified string. 
This can be a global navigation rule or, as of JSF 2.0, it can also be a view ID. 
In our example, simply navigate to the first view. 
Alternatively, instead of the element navigationAction, the element redirect with a URL for a redirect can also be specified.
[source,java]
----
@Named("addCustomerBean")
@Scope("manual")
@ViewController(viewIds = {"/addCustomer1.xhtml",
    "/addCustomer2.xhtml"})
@ConversationRequire(conversationNames = "addCustomerBean",
    entryPointViewIds = "/addCustomer1.xhtml",
    navigationAction = "/addCustomer1.xhtml")
public class AddCustomerBean extends CustomerBeanBase {
...
}
----
==== MyGourmet 17 Spring: Apache MyFaces Orchestra
MyGourmet 17 Spring integrates Apache MyFaces Orchestra and shows not only the necessary configuration but also some use cases. 
From version 1.4 on, Orchestra offers a new module Core20, which is already adapted to JSF 2.0. Core20 summarizes the Basic Core modules known from previous versions of Orchestra and Core15 with the annotations introduced in the section. 
The module is integrated into the Maven project via a dependency in the pom.xml. 
For details, please refer directly to the source code. On the configuration of Spring and Orchestra we will not go into any more here. 

In MyGourmet 17 Spring we have slightly rebuilt the customer area of ​​the application. 
The start page is now customerList.xhtml, which displays a list of all customers in an mc: dataTable component. 
From this view, the user can jump to the detail page of a customer, create a new customer, or delete an existing customer. 

The bean customerListBean in the access scope is defined as the view controller of the view. 
Listing MyGourmet 17 Spring: View Controller's Customer Overview page shows the CustomerListBean class the bean. 
The list of customers is loaded in the method preRenderView. Since it is annotated with @PreRenderView, it is called before each rendering of the Orchestra view. 
To delete a customer, call the deleteCustomer method using an h: commandLink component. The customer to be deleted is passed directly as a parameter:

<h:commandLink value="#{msgs.delete}" action=
    "#{customerListBean.deleteCustomer(customer)}">
  <f:ajax render="@form"/>
</h:commandLink>
Deleting a customer is executed as an Ajax request. The bean's access scope means that the bean's conversation stays open until it's no longer accessed.
[source,java]
----
@Named("customerListBean")
@Scope("access")
@ViewController(viewIds = {"/customerList.xhtml"})
public class CustomerListBean {

  @Inject
  private CustomerService customerService;
  private List<Customer> customerList;

  @PreRenderView
  public void preRenderView() {
    customerList = customerService.findAll();
  }
  public List<Customer> getCustomerList() {
    return customerList;
  }
  public void deleteCustomer(Customer customer) {
    customerService.delete(customer);
  }
}
----
We have in the wake of changes to the Customer in 17 Spring MyGourmet all operations for objects of type Customer in the interface Customer Service summarized. The Cus-tomerServiceImpl implementation of this interface is available as a bean with the identifier customerService. See Listing MyGourmet 17 Spring: View Controllers on the Customer Overview page to see how service dependency is defined with @Inject. 

The showCustomer.xhtml detail page is also available via an h: commandLinkComponent can be reached in the overview page. When the component is activated, the showCustomer method of the bean customerBean is called with the customer ID as a parameter. The method loads the customer and returns the View ID of the detail page for navigation. The managed bean customerBean is defined as a view controller for editCustomer.xhtml, showCustomer.xhtml and editAddress.xhtml and is created in the access scope. The class AddressBean has merged into this class. Listing MyGourmet 17 Spring: View Controller of Customer Views shows the head of the CustomerBean class, The CustomerBean class is derived from the abstract class CustomerBeanBase, which includes some basic customer view functionality that is also used by AddCustomerBean when creating a customer, but more on that later.
[source,java]
----
@Named("customerBean")
@Scope("access")
@ViewController(viewIds = {"/editCustomer.xhtml",
    "/showCustomer.xhtml", "/editAddress.xhtml"})
public class CustomerBean extends CustomerBeanBase {
...
}
----
Let's take a look at the conversation of the managed bean customerBean. 
If the user goes from the overview page to the detail page of a customer, the conversation bean customerBean with automatically managed lifespan is created in addition to the managed bean (access scope). The conversation is not terminated until there is no more access to the bean customer bean during a request. Figure life of the conversation CustomerBean shows a series of accesses to the views customerList.xhtml, showCustomer.xhtml, editCustomer.xhtml and editAddress.xhtml, The bar at the bottom of the figure shows the lifetime of the customerBean conversation.
 
Figure: Lifetime of conversation customerBean
The wizard for creating a new customer is also accessible from the overview page. 
The process consists of the two views addCustomer1.xhtml for entering the customer's basic data and addCustomer2.xhtml for entering an address. The managed bean addCustomerBean is the view controller for both views and is in the manual scope this time. Listing MyGourmet 17 Spring: View controller of the wizard for creating a customer shows the class AddCustomerBean. The bean is also injected with the service customerService, which is used to create a new customer instance in the createCustomer method is used. Because this method is annotated with @InitView, it is called by Orchestra after the restore view phase when the lifecycle for one of the two linked views is executed. This ensures that there is always an instance of the class Customer.
[source,java]
----
@Named("addCustomerBean")
@Scope("manual")
@ViewController(viewIds = {"/addCustomer1.xhtml",
    "/addCustomer2.xhtml"})
@ConversationRequire(conversationNames = "addCustomerBean",
    entryPointViewIds = "/addCustomer1.xhtml",
    navigationAction = "/addCustomer1.xhtml")
public class AddCustomerBean extends CustomerBeanBase {

  @Inject
  private CustomerService customerService;

  @InitView
  public void createCustomer() {
    if (customer == null) {
      customer = customerService.createNew();
    }
  }
  public String save() {
    customerService.save(customer);
    Conversation.getCurrentInstance().invalidate();
    return ViewIds.CUSTOMER_LIST_VIEW_ID;
  }
  public String cancel() {
    Conversation.getCurrentInstance().invalidate();
    return ViewIds.CUSTOMER_LIST_VIEW_ID;
  }
  public Address getAddress() {
    return customer.getAddresses().get(0);
  }
}
----

The annotation @ConversationRequire on the View controller ensures that a user in the browser can only access the addCustomer1.xhtml entry page of the wizard as long as the addCustomerBean conversation does not exist. Home pages are all views whose view IDs are listed in the entryPointViewIds element of the annotation. If the user in the browser calls the addCustomer2.xhtml view without the addCustomerBean conversation, or if the conversation times out after accessing the first page, the navigation handler becomes the string specified in navigationAction/addCustomer1.xhtml called. Due to the implicit navigation of JSF as of version 2.0, the browser directly displays the view with the corresponding view ID. The view is declared as the entry page and Orchestra creates the conversation the first time you access the bean. After completing the first page, the second page can now be called to complete the registration. 

Since the addCustomerBean bean is in the scope of the manual, we have to take care of ending the conversation ourselves. To do this, invoke the invalidate method on the current conversation in the two action methods save and cancelReceive Conversation.getCurrentInstance ().