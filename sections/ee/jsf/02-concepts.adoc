:sectnums:
== The concepts of JavaServer Faces

On the basis of the small example developed in the last chapter, we now turn to what is behind the theory behind the source code. To do this, we'll look at the individual components of JavaServer Faces technology and analyze JSF's support for building a modern web application.

=== Tasks of JSF technology

Let's summarize what the JSF specification means - it defines a framework for developing the user interface in Java web applications. The specification serves to assist the developer in the following areas:

* Components: +
JSF makes it easy to build complete web applications from components. In addition, you can create components yourself and reuse any.

* Data transfer: +
JSF makes it very easy to transfer data from the application to the user interface (and back again).

* State storage: +
JSF enables automatic storage of the state of the application on the server or on the client.

* Event handling: +
Events generated by the user at the client can be handled on the server. To do this, event handling methods are linked to the individual components.

Due to the strict separation of the layers of the application within the meaning of the MVC architecture, the individual persons involved in the application (eg web designers, component developers and application developers) can work independently of each other.

=== JavaServer Faces in Keywords

*Component (also Component, UIComponent or Control)* +
A component is a stand-alone and reusable building block used with other components to build a page in a JSF application. JSF offers a good selection of predefined components. The palette ranges from simple output components for text or images to components for capturing user input, to complex components for displaying tables.

*View and component tree* +
All components of a page are collectively called views and are linked together in the form of a component tree. The root of this tree is the UIViewRoot component, all other components are attached as children and children of these children under this element. All JSF-related operations in the flow of a request to the application start by calling a method on that UIViewRoot element that recursively passes the call on to its children.

*Renderer* +
The actual output of the component and its data and the removal of the data changed by the user at the client is done by the renderer. One component can be connected to many renderers - depending on the output technology, a specific renderer is selected, thus changing the appearance of the component. Renderers are optional - the component can also determine its own appearance and then performs the output process "independently".
Page declaration language (also called View Declaration Language, VDL)
A page declaration language (VDL) is a syntax for declaring views or pages for JSF. This concept was introduced in JSF 2.0 as part of the integration of facelets to abstract from the technology used. The standard in version 2.0 with Facelets and JSP supports two concrete implementations of a VDL. However, JSP is only supported for compatibility reasons and only offers some of the new features.

*Validator* +
The values ​​entered by the user may not always be correct - for example, the user may not have entered a value in a required field or entered a value that is too long in a length-limited text field. For such cases, there are easy-to-use validators in JSF. These validators check the validity of the values ​​entered and prevent the writing back of invalid values ​​to the model.

*Converter* +
For web applications, it is necessary to convert the data types provided by the application logic into a string, since the browser can only process and display strings. Also there is a help in the JSF technology, which is called converter. It converts the data types used by business logic into strings, and converts those strings back to Java-compatible data types after being modified by the user. If an error occurs in the conversion, as with the validators, the values ​​are not written back to the model.

*Managed beans (also called backing beans)* +
Behind the components are managed beans, which provide the actual values ​​for filling the components. They are - as already shown in the first example - centrally defined and can either be separate for each user or be valid centrally for the entire application. Managed beans are simple Java classes, also known as plain old Java objects ( POJOs ), which must comply with the JavaBeans standard.

*Unified Expression Language (also Unified EL)* +
The Unified Expression Language is the link between the components of a view and the underlying managed beans. Value expressions combine managed bean properties with component attributes-not just to read the values ​​of a bean, but also to write back user input. Method expressions allow the linking of components with methods. A concept used, for example, in the validation of user input and event handling.

*Events and event handling* +
Events are one of the key elements of JavaServer Faces technology. For example, an event occurs in a JSF application when a button is pressed or a value is changed. Each component can trigger events and each managed bean can be registered as an interested party for such events. In addition to the events already defined for the default components, new events (for custom components) can be included in JSF event handling.

*Navigation and actions ( navigation-rules, action )* +
Navigation in a JSF application was defined before JSF 2.0 exclusively via so-called navigation rules in faces-config.xml. JSF uses the return value of special methods, called "action" methods (which are called when an Action event is handled), to cause a redirect from one page to the next. This return value can be the name of a navigation rule or directly from JSF 2.0 the name of the next page.

*Messages* +
If errors occur while processing methods or validating and converting values, these errors must be displayed to the user. Validation and conversion errors are translated into messages in JSF that can then be viewed on the page. 

The temporal interaction of these individual objects in the JSF technology is precisely regulated, namely in the "Request Processing Lifecycle" called life cycle of an HTTP request. We will take a closer look at this "lifecycle" in section [Section: Life Cycle of an HTTP Request in JSF] . First, however, we will demonstrate in the following section the relationship between some of these basic concepts using the example of MyGourmet 1.

We will be using a lot of terms from the JSF technology throughout this book. To give an overview, we will briefly look at the definition of the most important terms in advance.

=== MyGourmet 1: Keywords in action

The last section briefly explained the most important basic terms of JavaServer Faces. After this rather theoretical consideration we want to try to connect these catchwords with the already known example MyGourmet 1. The starting point in Listing MyGourmet 1: The page editCustomer.xhtml is the code of the page declaration editCustomer.xhtml.

.editCustomer.xhtml
[source,xhtml]
----
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://xmlns.jcp.org/jsf/core"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<head>
  <title>MyGourmet - Edit Customer</title>
</head>
<body>
  <h1><h:outputText value="MyGourmet"/></h1>
  <h2><h:outputText value="Edit Customer"/></h2>
  <h:form id="form">
    <h:panelGrid id="grid" columns="2">
      <h:outputLabel value="First Name:" for="firstName"/>
      <h:inputText id="firstName"
          value="#{customer.firstName}"/>
      <h:outputLabel value="Last Name:" for="lastName"/>
      <h:inputText id="lastName"
          value="#{customer.lastName}"/>
      <h:commandButton id="save" action="#{customer.save}"
        value="Save"/>
    </h:panelGrid>
  </h:form>
</body>
</html>
----

If a user wants to view this page in the browser, they must type editCustomer.jsf in the address bar. However, we have always created XHTML files with the extension .xhtml. Where does this difference come from and why does an output appear in the browser window at all? This question is answered easily. Outwardly, only the JSF view editCustomer.jsf is visible, which is internally built on a so-called page declaration. In "standard" JSF, this is an XHTML file for facelets or a JSP file with the same name as the corresponding JSF view. The JSF implementation knows how the path of the associated page declaration looks relative to the context of the web application - in our case /editCustomer.xhtml, This path of the page declaration is also called a view identifier.

The page declaration determines the content and structure of the component tree, and thus the view. The tags of the XHTML page are translated from facelets into components and arranged in the component tree. Figure MyGourmet 1: From the page declaration to the component, this implementation shows an example on the tag of the input component for the first name.

====
.MyGourmet 1: From the page declaration to the component
image::images/mygourmet01-template2component.jpg[]
====

In the same way all other tags of the page are converted into components and inserted into the tree. The finished component tree of the editCustomer.jsf view looks like MyGourmet 1: Component Tree in Figure . The names of the nodes in the figure are the names of the component classes used.

====
.MyGourmet 1: component tree
image::images/mygourmet01-componenttree.jpg[]
====

The ready-built component tree can now be converted from a renderer to an output language and displayed to the user. In most cases, the output will be HTML pages, but replacing the renderer will allow almost any output technology to be used. However, for the moment we want to limit ourselves to HTML. The renderer thus takes the data stored in the component instance and outputs the corresponding HTML code for the respective component. Figure MyGourmet 1: From the component to the HTML output, for example, shows how the input component for the first name is converted to HTML.

====
.MyGourmet 1: From component to HTML output
image::images/mygourmet01-component2html.jpg[]
====

The representation of the completely rendered page in the browser can be seen in the browser in Figure MyGourmet 1: editCustomer.xhtml.

====
.MyGourmet 1: editCustomer.xhtml in the browser
image::images/mygourmet01-screenshot.jpg[]
====

The relationships between page declaration, component tree and rendered output should therefore be clarified. However, we have left out the concrete process of the entire process in the form of the JSF life cycle. These temporal relationships and processes are discussed in section [Section: Life Cycle of an HTTP Request in JSF]. But before we throw in section [Section: Managed beans] yet a closer look at Managed beans and Section [Section: The Unified Expression Language] on the connection between the model and view with the Unified Expression Language.

=== Managed Beans

The managed beans are a central component of the JavaServer Faces. They form the model or the connection to the model and the business logic in an application. With regard to a strict separation of presentation and logic they play a very important role. In practice, the business logic calls in an application are completely encapsulated in the managed beans. The connection to the properties and methods of a managed bean is realized with unified expression expressions.

The remainder of this section discusses the basics and details of managed beans. For more detailed information about the Unified Expression Language, the link between view and model in JSF, see section [Section: The Unified Expression Language].

==== Managed Beans - The Basics

What must a managed bean look like in JSF so that it can be used? The requirements are minimal: managed beans are simple Java classes, also known as plain old Java objects ( POJOs ), which must comply with the JavaBeans standard. For the class itself, this just means that it must have a constructor without parameters with visibility public.

As mentioned earlier, JSF accesses the properties of the managed beans to read and write data. A property has a name, a type, and methods for reading and writing the value. The names of these methods must conform to the following convention: getPropertyName is the name of the method for read access and setPropertyName is the name of the write access method. Whether the method accesses a private variable of the class, or whether it involves a complex operation of business logic, is transparent and ultimately irrelevant. Outwardly, only the property of the bean is visible in both cases. 

Listing Managed Bean class Customer from MyGourmet 1 once again shows the class Customer from our example MyGourmet 1. This bean has the properties firstName and lastName of the type String, which are defined by the respective getter and setter methods. The access in the view is done with the expressions # {customer.firstName} and # {customer.lastName}. Depending on whether the value in the accessing component is read or written, the corresponding getter or setter is used. The names of the properties are derived from the getter and setter names. The private fields in the background have no effect on the name - they only record the value of the property.

The save method fulfills another purpose. It is used to handle events and is not associated with any property - more detailed information on this topic can be found in the section [Events and Event Handling].

.Customer.java
[source,java]
----
import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;

@ManagedBean
@SessionScoped
public class Customer {
  private String firstName;
  private String lastName;
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getLastName() {
    return lastName;
  }
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
  public String save() {
    return "/showCustomer.xhtml";
  }
}
----

Bean properties do not necessarily have to have both a getter and a setter method. Depending on which of the two is present, then it is a property that can only be read or written.

In fact, in the last few paragraphs, we talked only about JavaBeans. They become managed beans only when they are actually managed by JSF. How it works is shown in the next section.

==== Configuration of managed beans

One of the cornerstones of JSF is the central point for managing managed beans - the Managed Bean Creation Facility. The following tasks are performed with this instrument:

* Declaration of all managed beans
* Defining the lifetime of the managed beans
* Automatic generation, initialization, use and deletion of the managed bean instances
* Provision of Managed Beans via the Expression Language (EL). For example, value expressions and method expressions can be referenced to business objects.
To be able to use managed beans in the view, the JSF environment must know under which name and under which class the respective JavaBean can be found. Since JSF 2.0 there are two variants to perform this registration. In the introductory example, we have already seen how a managed bean is declared via annotations. Listing configuration of the bean customer from MyGourmet 1 via annotations again shows the relevant part of the class. Alternatively, managed beans can also be declared in faces-config.xml - in JSF versions prior to 2.0 this was the only option.

----
@ManagedBean
@SessionScoped
public class Customer {
  ...
}
----

Listing configuration of the bean customer from MyGourmet 1 in faces-config.xml shows how the configuration of the bean customer from MyGourmet 1 looks in the faces-config.xml file.

.faces-config.xml
[source,xml]
----
<managed-bean>
  <managed-bean-name>customer</managed-bean-name>
  <managed-bean-class>
    at.irian.jsfatwork.gui.page.Customer
  </managed-bean-class>
  <managed-bean-scope>session</managed-bean-scope>
</managed-bean>
----

The two variants presented in the Listings configuration of the bean customer from MyGourmet 1 via annotations and configuration of the bean customer from MyGourmet 1 in faces-config.xml lead to the same result: The managed bean with the name customer is defined. Which of the two you use in your project is partly also a matter of taste. We chose annotations in MyGourmet to avoid bloated configuration files.

In faces-config.xml, the declaration of a bean takes place in an element called managed-bean. Nested in it follows the managed-bean-name element first the name under which the bean is referenced in EL expressions - in our example, customer. The class of the bean is specified in the managed-bean-class element. Finally, in the managed-bean-scope element with session, the lifetime of the bean is specified.

When declared with the annotation @ManagedBean, the name of the managed bean is conventionally the same as the class name with a small initial letter. For example, in our case, the customer class becomes the bean customer. If you want to use a different name, you can set it in the element name of the annotation. listing Configuration of the bean customer with an alternative name shows the already known bean with the explicit name customerBean. Access in the view is now with the expression # {customerBean.firstName}.

----
@ManagedBean(name = "customerBean")
@SessionScoped
public class Customer {
  ...
}
----

Default JSF defines scopes for beans (in brackets is the configuration value in faces-config.xml and annotation):

* None scope ( none, @NoneScoped ): +
The managed bean is recreated each time it is called.
* Request scope ( request, @RequestScoped ): +
The managed bean survives for the duration of an HTTP request.
* View Scope ( view, @ViewScoped ): +
The lifetime of the managed bean is linked to the view in which it is used.
* Session Scope ( session, @SessionScoped ): + 
The managed bean lives for the duration of a session in which the user is connected to the application.
* Application scope ( application, @ApplicationScoped ): + 
For the lifetime of the application, only one instance of this managed bean exists for all users.

Picture comparing the life of different scopes compares the life of the scopes provided by default JSF.

====
.Comparison of the lifetime of different scopes
image::images/managed-bean-scopes.jpg[]
====

Now that you understand how managed beans are declared, we do not want to deny you how JSF manages them. The internal process for accessing a bean is as follows:

. When the bean is first accessed, it is automatically instantiated by the Managed Bean Creation Facility. If the instance of the bean already exists, it will be returned. The instantiation can only occur if a constructor without arguments is available.
. After creating the bean, all managed properties are initialized. More details can be found in section [Section: Managed Properties] .
. Finally, the managed bean is stored under the specified lifetime.

In our example, this is done in the session scope, i.e., as long as there is a logical connection between the user and the application in the form of a session. Only use the session scope if absolutely necessary. With the new view scope, it is now relatively easy to take data across multiple requests. At least until you navigate to a new page.

==== Managed properties

The Managed Bean Creation Facility provides the ability to initialize properties of managed beans after creation (so-called managed properties). In addition to fixed values, Dependency Injection also provides the ability to use dependencies on other beans for initialization.

As with the configuration of the beans themselves, there are also two variants for the declaration of the managed properties. The @ManagedProperty annotation directly annotates the fields of the property in the bean. The initial value for this method is in the value element. Alternatively, the same declaration can be made in the faces-config.xml. Added to this is the element managed-property is used, where the name of the property and the value to be set are in the property-name and value elements.

Listing Managed Properties Annotation shows the Java code of an annotated managed bean with managed properties. Listing managed properties in the configuration show the equivalent configuration in faces-config.xml . Of course, the annotations in the class login are not necessary in this case.

.Login.java
[source,java]
----
@ManagedBean
@SessionScoped
public class Login {
  @ManagedProperty(value = "3")
  private int loginRetries;
  @ManagedProperty(
    value = "#{roleResolver.defaultResolver}")
  private RoleResolver roleResolver;
  ...
}
----

.faces-config.xml
[source,xml]
----
<faces-config>
  ...
  <managed-bean>
    <managed-bean-name>login</managed-bean-name>
    <managed-bean-class>
        at.company.webapp.model.Login
    </managed-bean-class>
    <managed-bean-scope>session</managed-bean-scope>
    <managed-property>
      <property-name>loginRetries</property-name>
      <value>3</value>
    </managed-property>
    <managed-property>
      <property-name>roleResolver</property-name>
      <value>#{roleResolver.defaultResolver}</value>
    </managed-property>
  </managed-bean>
  ...
</faces-config>
----

After initializing the login, its loginRetries attribute has the value 3. The roleResolver attribute shows that the value can be a reference to another managed bean - via a value expression. All other attributes have their default values.

The use of managed beans to initialize managed properties is limited in JSF. A managed property can not be initialized with a managed bean that has a shorter lifetime. For example, it is not allowed to inject a bean in the request scope into a bean in the session scope. The explanation for this is simple: Since a session runs longer than a request, the injected bean is out of date after the first request. Beans in the None Scope, on the other hand, can always be used because they are not stored in any scope.

Initialization with dependency injection references offers some advantages over bean resolution in the code. On the one hand, static calls in the code can be avoided, and on the other hand, maintainability and clarity increase due to the central configuration.

The Managed Bean Creation Facility is JSF's ability to create beans - but by far not the only one possible. With CDI and Spring, there are alternatives that are clearly superior in configuration scope and extensibility, but without unnecessarily increasing the complexity of the application. In the Section: Beans and Dependency Injection with CDI section, we show how managed beans are managed with CDI and the benefits of doing so.

==== The role of managed beans

So far, we've assumed that the managed beans are the model of the application according to the MVC design pattern. It does not necessarily have to be that way - in most cases it's even better if the managed beans are not directly the model, but only a mediator between view and actual model.

How can you imagine that? A simple example, based on MyGourmet 1, helps clarify this issue. In MyGourmet 1, the managed bean is the model of the application; accessing the customer's first name looks like this: # {customer.firstName}, In addition to the model properties of the customer, the bean also contains the action methods for event handling. The disadvantage of this variant is the close coupling of GUI logic and model, which has a negative impact especially when it comes to changes.

A more elegant solution is to completely free the model class Customer from JSF code and introduce a customer bean managed bean that has a Customer property in addition to the GUI logic. Access to the customer's first name looks like this: # {customerBean.customer.firstName}, In this variant, the model class can be created independently of the presentation layer in a lower layer of the application. The two variants are shown in Figure The Role of Managed Beans.

====
.The role of managed beans
image::images/managed-beans-modell.jpg[]
====

For the time being, in MyGourmet we will stick to using the class Customer as a managed bean. Only in the more extensive examples from MyGourmet 5 in section [Section:  MyGourmet 5 : Conversion] is a separate class used.

=== The Unified Expression Language

A basic element of the JSF specification is the Unified Expression Language (abbreviated to Unified EL), which makes it possible to dynamically connect components of the user interface and the business data behind it. We want to read data from the model, but also write user input back to the model.

Furthermore, it has to be defined which methods treat which events. Value expressions bind component attributes to managed beans and their properties, and method expressions reference methods. As in MyGourmet 1 , we'll take a closer look at section [Unified EL Section in MyGourmet 1].

For the definition of an EL expression, a rhombus and a curly bracket precede the expression, and a curly bracket limit the expression. What is allowed between these limiters? Between these delimiters you can specify the name of managed beans or "implicit" objects, properties of these objects (separated by parent elements) or operators. These include arithmetic operators such as "+" and "-" as well as comparison operators, even the "ternary" operator ( condition? If_true: if_failure ) is allowed.

==== Unified EL in MyGourmet 1

In the example of MyGourmet 1, we have already made extensive use of value expressions to display customer data and save user input. Take the customer's first name as an example: The expression # {customer.firstName} connects the value of the input component to the property firstName of the managed bean customer. Figure Value Expression in Input Component shows the relationship between tag, component, and managed bean in more detail.

====
.Value Expression in Input Component
image::images/unified-el-value-expression.jpg[]
====

A value expression is only resolved when the value is actually read or set. Therefore, the value expression itself is stored in the component, not the value. A closer look at why this is necessary follows in the section [lifecycle of an HTTP request in JSF] over the lifecycle of JSF.

The data is already properly read when the page is displayed and written when the form is submitted. It lacks the ability to call custom code when editing the submitted page - for example, to save the user's input in the database. This is where Method Expressions come into play. If the user press save button on editCustomer.jsf page,  the server should call the save method of the bean. For command components, there is the attribute action, which can contain a method expression. In our example, this is the expression # {customer.save}. The referenced method is called when all data entered by the user has been validated and valid. The returned string is used for navigation and determines which page is displayed. Figure Method Expression in Command Component shows the component's tag and the way to call the method associated with the component.

====
.Method Expression in Command Component
image::images/unified-el-method-expression.jpg[]
====

More detailed information about the Unified EL can be found in the next section. The navigation process is described in more detail in section [Section: Navigation].

==== The unified EL in detail

Below is a brief overview of the possibilities offered by the Unified EL.

* value = "# {user.username}" +
Binds a component attribute to the username property of the managed bean named user. This means that when the component is rendered, the value is retrieved from the bean by calling getUsername(), and the value is returned to the bean by the setUsername() call in the update phase.
* rendered = "# {user.username! = null}" +
Binds a Boolean value ( true or false ) to the attribute of the component. This can be used very well to show or hide the component by setting the rendered attribute. To avoid problems, using the rendered attribute is preferable to using JSTL <c: if /> tags: , Such an expression does not update the value (there is no setter), so a compound expression can not be used for the value attribute of JSF components.
* value = "# {bill.sum * 13,7603}" +
If the value of an h:outputText component is labeled with this expression, the component will always have the current value of the property sum of the managed bean bill multiplied by 13,7603rd. However, this form of EL expressions should be used sparingly. Calculations of any kind are better off in the business logic.
* style = "# {grid.displayed? 'display: inline;' : 'display: none;'} " +
Here, the style attribute of a component is displayed either on display: inline; or display: none; A very common trick used to hide or show areas of a page on the client for certain attribute values.
* value = "Hello User # {user.username}" +
The combination of strings and unified EL expressions is also possible. In this way it is very easy to generate dynamic expressions. However, this solution has a serious drawback: When combined with the string, the value is no longer converted but simply called toString () .
* action = "# {user.storeUser}" +
Here, the action storeUser is called via a method expression. The referenced method must have the signature String storeUser() and return the string that determines navigation to the next page.
* value = "# {mapBean ['index']}" +
To access values ​​in objects that implement the Map interface, the key can be enclosed in square brackets. This notation is in principle equivalent to the dot notation, so it can also be referenced with the dot notation on the contents of a map. Conversely, it is possible to access the properties of normal beans with the notation of the square brackets. Small puzzles: Why can the notation with square brackets in certain situations be beneficial?
* value = "# {mapBean [user.username]}" +
Here's the resolution of the task: You can also nest value expressions, and then use the key to access the map or the property name to access the bean property specify via a value expression.
* value = "# {listBean [5]}" +
One final example: Here, the value of the component references the sixth entry in a list. Again, this index can be a value expression again, as in the above example.

Implicit Objects: The basis for resolving the EL expressions can be any managed bean or a list of implicit objects provided by JSF. The following list contains the most important implicit objects:

* requestScope +
Access to the request map of the external context.
* viewScope +
Access to the view map of the view root.
* sessionScope +
Access to the session map of the external context.
* applicationScope +
Access to the application map of the external context.
* view +
Access to the view root.
* param +
Access to the request parameter map of the external context.
* paramValues +
Access to the Request-Parameter-Values-Map of the external context (behaves the same as the Request-Parameter-Map, except that a string array is returned here).
* header +
Access to the request header map of the external context.
* headerValues +
Access to the request header value map of the external context (behaves the same as the request header map, except that a string array is returned here).
* facesContext +
Access to the faces context
* initParam +
Access to the init parameter map of the external context and thus to context parameters of the web application.
* cookie +
Access to the request cookie map of the external context.

Example: A common example of implicit objects: The # {param.myParam} expression can be used to access the request parameter named myParam.

==== Extensions of the Unified EL in Java EE 6

Java EE 6 brings a new version of the Unified EL with some long-awaited innovations. With the new version methods with parameters can finally be used in EL expressions. Until now this was only possible for static methods via EL functions (see section Section: Definition of an EL function).

The use of method expressions with parameters opens up a number of interesting possibilities in JSF. In the example MyGourmet 9 in Section Section: MyGourmet 9: UIData and detail view you can see how an action method with parameters for deleting an address from a list can be used.

But that is not all. As another innovation, value expressions are no longer limited to bean properties. The new unified EL allows you to call any method whose return value is the value expression value. This allows the following unified EL expressions:

* value = "# {bean.list.size ()}" +
With this expression, it is finally possible to read the number of elements of a list without detours.
* value = "# {bean.text.replaceAll (':', '_')}" +
This expression invokes the replaceAll() method on the text property of type String to replace all colons with underscores, and returns the result back. 
* value = "# {bean.findOrders (otherBean.customer)}" +
The value of this expression is determined by a call to the findOrders() method on the bean bean. The parameter customer of the bean otherBean is used as a parameter - this is also possible without any problems.
* value = "# {bean.getName ()}" +
This value expression binds the return value of the getName() method to the component. In contrast to the expression, # {bean.getName ()} can only be read - even if the method setName() exists - and is therefore not suitable for input fields.

The new version of the Unified EL is part of Java EE 6 and comes automatically with all servers that support Servlet 3.0 and JSP 2.2 (such as Tomcat 7 or Jetty 8). If you use an older server, you still do not have to do without the most important features of the new Unified EL. Subsec Configuration of the Unified EL section shows how to use JBoss' alternative EL implementation.

=== Life cycle of an HTTP request in JSF

From an HTTP request, some processing must be done in JSF to restore the state of the application and to prepare for the application logic to be called. These steps include the restoration of the component tree, the reading of the user-modified data from the HTTP request and the validation of that data, as well as the transfer of that validated data to the model objects. After calling up actions in the business logic, the last step remains - the output of the response to the HTTP request (the so-called "rendering"). This process is in the JavaServer Faces Specifically defined and forms an essential basis for any application based on the JSF technology. In Figure The lifecycle of an HTTP request, the process is shown.

====
.The life cycle (lifecycle) of an HTTP request
image::images/lifecycle-complete.jpg[]
====

We will now take a closer look at the individual processing steps. In order to make the whole thing more exciting, we will immediately discuss the practical usability of the processes in the individual phases.

*Phase 1: Restore View ( Restore View )* +
Each view of a JSF application consists of components organized in the form of a component tree. The processing of a request begins in the first phase of the life cycle with the structure of the component tree. 

If the first request is for a view, the component tree does not exist yet and JSF rebuilds it from the page declaration. If the page-declaration language JSP is used, JSF forwards the request to the JSP page located behind the view. This is processed and each time a new tag not yet associated with an initialized component is encountered, a new component is created and initialized with the attribute values ​​from the JSP page. Facelets follows a similar strategy and builds the tree parsing the underlying XHTML document.

In a second pass through the component tree, the page is then rendered. An initial request for a view only goes through the first and the last phase of the lifecycle. Illustration Initiation of the life cycle shows this process.

====
.Initiation of the life cycle
image::images/lifecycle-initial.jpg[]
====

When a request requests the same page the second time, in JSF versions prior to 2.0, the component tree is completely restored from the state previously stored on the server or client. Of course, not only the components themselves are part of the component tree, but also validators, converters and the "old" values ​​as well as all the other properties of the components.

Starting with JSF 2.0, there is a crucial difference between JSP and facelets at this point. JSP reconstructs the complete component tree from the page state. By contrast, when using facelets, JSF first rebuilds the view from the page declaration and only then processes the saved state. This new approach - also called partial state saving - offers some advantages in terms of performance and size of the page state. First tests show that with the partial state saving enabled, the size of the page state is reduced by a factor of about 3.

*Phase 2: Apply Request Parameters ( Apply Request Values )*

In this phase, the entire component tree is edited and the values ​​entered by the user are assigned to the individual components. This is done by calling the processDecodes() method at the root node - the root node then calls the same method on its child node and recursively calls it on its child node. 

In addition, when processing the method, each component (or more specifically the renderers associated with the component) will look for the HTTP request, namely the HTTP headers and cookies parameters, the values ​​that affect that component, and stores them as a "Submitted Value". This process will "decode" (English decoding) called. However, the submitted value is not yet the value that is later actually written into the model - it first has to be converted into a format suitable for the data model and validated. In addition, writeback can still be prevented by the conversion failing or validating. 

The conversion and validation will then be done in the next phase, but this phase can also be brought forward: setting the immediate attribute instructs the component to perform the conversion and validation already in phase 2. Why this is desirable in some cases and how it works is described in section [Section: Changing the Life Cycle - Immediate Attribute] explained in more detail.

The submited value is also important in the rendering phase, especially for writing custom components. If the validation or conversion of components of the page is unsuccessful, the submitting value must be used when rendering the components - it would not be correct to use the "old" component value stored in the value property because otherwise information of the user would be lost.

*Phase 3: Conversion and Validation ( Process Validations )*

*Phase 4: Update Model ( Update Model Values )*

*Phase 5: Execute application ( Invoke Application )*

*Phase 6: Render Response (Render Response)*

===== Changing the life cycle - immediate attribute

===== immediate attribute for command components

==== MyGourmet 2: immediate attributes

=== Navigation

An important part of any JSF application is the definition of navigation between views. In order for the user in the browser to ever be able to switch from one view of the application to another, the page declaration must contain a command component. This is a component that initiates the sending of the current page to the server and thus initiates the processing of the lifecycle on the server. Of these command components, there are two in JSF: h: commandButton and h: commandLink . As the name already suggests, they are output as a button or link in HTML. 

The decisive factor for the use of navigation is the action attribute the command components. It will decide at the end of the Invoke Application phase which view will be rendered by JSF and returned to the user.

As of JSF 2.0, the view ID of a view can be specified directly in the action attribute or returned by the action method - we call this implicit navigation. Let's take a closer look at the navigation in MyGourmet. Listing command components from MyGourmet shows the two command components in the view editCustomer.xhtml. The first button triggers navigation to the showCustomer.xhtml view because the action method is save returns this view id. When pressing the second button, the user ends up on the view named cancelled.xhtml in the action attribute.

[source,xhtml]
----
<h:commandButton id="save" value="Save"
    action="#{customer.save}"/>
<h:commandButton id="cancel" value="Cancel"
    action="/cancelled.xhtml" immediate="true"/>
----

The classic variant of navigation is based on navigation rules. You specify when which page of the application is called. JSF allows the definition of any number of navigation rules in faces-config.xml. In a rule, before the listing of the individual navigation cases, the element from-view-id appears. This element determines from which page the following navigation cases are valid.

Listing navigation rule for MyGourmet shows a navigation rule for the page declaration with the view ID editCustomer.xhtml, the navigation in MyGourmet currently used with implicit navigation equivalent. The individual navigation cases can only become active if the user is on this view.

.faces-config.xml
[source,xml]
----
<navigation-rule>
  <from-view-id>/editCustomer.xhtml</from-view-id>
  <navigation-case>
    <from-outcome>ok</from-outcome>
    <to-view-id>/showCustomer.xhtml</to-view-id>
  </navigation-case>
  <navigation-case>
    <from-outcome>cancel</from-outcome>
    <to-view-id>/cancelled.xhtml</to-view-id>
  </navigation-case>
</navigation-rule>
----

In contrast to the previous example, the navigation rule in Listing Global Navigation Rule is global for all views of the application. The from-view-id element will contain an expression in such cases to define the appropriate view IDs. In the simplest case, the value * includes all views. But it is equally possible for example to restrict the rule to a directory within the application with /secure/*.

.faces-config.xml
[source,xml]
----
<navigation-rule>
  <from-view-id>*</from-view-id>
  <navigation-case>
    <from-outcome>logout</from-outcome>
    <to-view-id>/home.xhtml</to-view-id>
  </navigation-case>
</navigation-rule>
----

One or more navigation cases then follow in the detail area of ​​the navigation rules. These navigation cases define the page transitions via filter and target elements. The landing page is defined by the element. The filter elements are from-outcome and the less frequently used from-action.
 
The string in the from-outcome element of the navigation rule must then match the return value of the action method. As an alternative, there can be a string directly in the action attribute, which must then correspond to the element from-outcome . 

If there are several same return values, the navigation case may be using the from-action element be further restricted to calling a particular action method. Listing navigation case with from-action shows a corresponding navigation case.

.faces-config.xml
[source,xml]
----
<navigation-case>
  <from-action>#{customer.save}</from-action>
  <from-outcome>ok</from-outcome>
  <to-view-id>/showCustomer.xhtml</to-view-id>
</navigation-case>
----

We have not considered a case yet. What happens if the action method returns null ? The answer is simple (at least before JSF 2.0): The current page is displayed again. As of JSF 2.0, this behavior can be affected by conditional navigation, but more on that later.

In some cases, it may be necessary to trigger the navigation explicitly through the JSF navigation handler, for example, to navigate from one action listener to another. This is not possible in direct form because the action listener does not return a string. To do this, first define a global navigation rule in the faces-config.xml, with the from-outcome on a string and to-view-id are set to the desired landing page. Listing Programmatic navigation shows the call that causes navigation to the destination page. As of JSF 2.0, it is of course also possible to specify a view ID directly instead of the global navigation rule.

[source,java]
----
FacesContext ctx = FacesContext.getCurrentInstance();
fc.getApplication().getNavigationHandler()
    .handleNavigation(ctx, null, "cancel");
----

Since version 2.0 JSF also offers conditional navigation. With the if element, which takes a value expression that must evaluate to a Boolean value, navigation cases can be made dependent on the result of that expression. The element if can be used in combination with from-outcome or from-action or as the only condition for a navigation case. Either way, all specified conditions must be met for the navigation case to occur.

Listing Conditional navigation in action shows a version of the already known navigation rule from MyGourmet with conditional navigation. The navigation after pressing the Cancel button depends on the customer.registered property in the example. If the user is already registered and only changes his data, he will return to the overview page /showCustomer.xhtml when the button is clicked. If it terminates before the registration is completed, it will arrive at the view /cancelled.xhtml

.faces-config.xml
[source,xml]
----
<navigation-rule>
  <from-view-id>/editCustomer.xhtml</from-view-id>
  <navigation-case>
    <from-outcome>ok</from-outcome>
    <to-view-id>/showCustomer.xhtml</to-view-id>
  </navigation-case>
  <navigation-case>
    <from-outcome>cancel</from-outcome>
    <if>#{customer.registered}</if>
    <to-view-id>/showCustomer.xhtml</to-view-id>
  </navigation-case>
  <navigation-case>
    <from-outcome>cancel</from-outcome>
    <if>#{not customer.registered}</if>
    <to-view-id>/cancelled.xhtml</to-view-id>
  </navigation-case>
</navigation-rule>
----

The introduction of conditional navigation also affects navigation behavior when the action method returns null. In JSF versions before 2.0, the current page was always displayed again. As of version 2.0, JSF checks all navigation cases that have an if element without from-outcome or from-action.

=== Events and Event Handling

An essential part of any web application is the handling of user input at the client. For example, if the user clicks a button or selects an entry from a list, a corresponding action must be taken. In JavaServer Faces events (events) are used. These events are then handled by event listeners previously registered with a component for a particular event type. As an example, the button to save from MyGourmet 2 in Listing MyGourmet 2: The page `editCustomer.xhtml`. 

For this button component, the method expression in the attribute `action` registered an event handling method. If the user clicks on the button in the browser, an event is generated when the lifecycle is processed, and the registered method is called. 

The handling of the events and the call of the event listeners is done in JSF on the server side. When the lifecycle is run, events can be generated and inserted into an event queue when the phases are processed as of the `Apply Request Values ​​phase`. When the phase is finished, the registered event listeners are called for the events in the queue. This must not happen earlier, so that each event listener sees the same status of the component tree. Illustration The lifecycle of an HTTP request provides an overview of the lifecycle and the possible places for dealing with events. From the figure, it can be seen that there is the possibility of influencing the life cycle when executing the events. Event listeners can with the method FacesContext.renderResponse() can jump directly to the Render Response phase or with the method FacesContext.responseComplete() completely abort the life cycle. As it stands in an example, MyGourmet 3 shows in section [Section:  MyGourmet 3 : Events].

JSF defines several types of events (and matching event listeners) that are triggered by user actions or by the system. The following events are triggered by user actions:

* Value change events are triggered when the value of an input component changes. For details, refer to section [Value Change Events Section].

* Action events are fired by command components when they are activated. Details can be found in section [Action Events].

The following events are triggered by the system:

* System events are triggered by the system at certain times in the life cycle. Details can be found in section [System Events].

* Phase events are routinely triggered by the system during the life cycle before and after each phase. Details can be found in section [Section: Phase Events] .

A more detailed description of each event type follows in the next sections.

==== Value Change Events

==== Action Events

==== MyGourmet 3: Events

==== System Events

==== Phase Events

==== MyGourmet 4: Phase Listener and System Events

===== Life cycle analysis

=== Page declaration languages

A View Declaration Language (VDL) is a syntax for declaring views or pages for JSF. This concept was introduced in JSF 2.0 as part of the integration of facelets to abstract from the technology used. The standard supports as of version 2.0 with facelets and JSP two concrete implementations of a VDL. 

Before version 2.0 of JavaServer Faces JSP was the primary page declaration language of the specification. Developers should be made as easy as possible by using a standardized and widely used technology to move to JSF. A noble approach - but unfortunately the JSF and JSP team is a suboptimal solution, mainly because the two technologies were designed for different purposes. 

Let's take a closer look at this discrepancy between JSP and JSF. As you already know, a request in JSF will be processed in several phases. The structure of the component tree from the page declaration and the output of the view take place in different phases. And that's exactly where the problem lies: JavaServer Pages were designed for a much simpler life cycle. 

A request is processed with JSPs in a single phase - which also returns the response in the background. In the background, each JSP file is compiled into a servlet with a more or less complex set of out.println ("...") statements. This is particularly problematic when combined with JSF if the JSP file contains component content as well as simple content such as HTML elements and text. These are output directly while the file is being processed, while the component tags are used to build the component tree, which is not rendered until the end of the lifecycle. This and other reasons make the construction of the component tree from JSP page declarations relatively expensive.

This is where facelets come in - an alternative technology for declaring views that is perfectly integrated into the JSF lifecycle. The main task of facelets is to build component trees from XHTML documents. Facelets does the job brilliantly and, compared to JSP, also has some other benefits that we will discuss in the next section. 

In JavaServer Faces 2.0, Facelets took the place of JSP as the primary page declaration language. JSP is supported in the standard only for compatibility reasons. New features are available from JSF 2.0 only with facelets.

==== Benefits of Facelets over JSP

The use of facelets in a JSF project offers a number of practical advantages over the use of JavaServer Pages. 
This is not surprising since Facelets was developed specifically for JSF. 
The resulting seamless integration into the lifecycle does not entail many JSP-inherent problems in building the views.

Opting for the JSF life cycle makes the creation and delivery of views with facelets more efficient. 
This affects on the one hand in a higher speed when processing the pages compared to JSP. 
On the other hand, there are also some benefits for page authors. 
Problems with the combination of components and standard HTML content are a thing of the past with facelets. 
The use of `f: verbatim` is therefore unnecessary, as is the need to use `f: view`. 

Facelets provides the ability to build pages and content on templates. 
For more information, see section Section: Templating. 
The reuse of content is generally capitalized, which facilitates the modularization of your projects and thus increases the maintainability. 
Page fragments can be stored centrally and integrated into multiple pages. 
It even goes so far that you can create components without writing a line of Java code. 
You can find out how this works in Chapter Chapter: Custom JSF component.

After this brief overview of the benefits of facelets, let's take a closer look at the practical aspects of page declarations in the next section.

==== Page declaration languages ​​in use

JSF 2.0 was a big step forward in terms of supporting page declaration languages. 
In older versions, the view handler had to be replaced to use facelets in their own projects. 
With version 2.0 this step became obsolete. JSP and facelets work right now without further configuration. 

When integrating facelets into the JSF standard, special emphasis was placed on backward compatibility with the previous version before JSF 2.0. 
Outwardly, nothing has changed for developers who use facelets as VDL. 
Only the implementation was adapted to JSF 2.0. 
So if you have classes from the com.sun.facelets package in your project or using a subpackage, you must adapt your project to the new classes. 
In all other cases, the use of facelets is even easier, since the inclusion of the jar files and the facelets view handler is eliminated. 

So far we have used facelets in all the examples. 
It's time to take a closer look at such a declaration. 
<<.showCustomer.xhtml,List page declaration in facelets>>  shows again showCustomer.xhtml from MyGourmet 1 in a slightly shortened version.

.showCustomer.xhtml
[source,xhml]
----
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:f="http://xmlns.jcp.org/jsf/core"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<head><title>Show Customer</title></head>
<body>
  <h1><h:outputText value="Show Customer"/></h1>
  <h:panelGrid id="grid" columns="2">
    <h:outputText value="First Name:"/>
    <h:outputText value="#{customer.firstName}"/>
    <h:outputText value="Last Name:"/>
    <h:outputText value="#{customer.lastName}"/>
  </h:panelGrid>
  <h:outputText value="Customer saved!"/>
</body>
</html>
----

Technically speaking, a facelet declaration is nothing more than an XHTML document with the Doctype XHTML Transitional. 
The integration of the tag libraries used is realized via namespaces in the root element of the document. 
In the Listing Page Declaration in Facelets example, all core tag library tags are prefixed with f: and the HTML tag library tags are prefixed with h : . The rest of the document consists only of component tags and pure HTML. 

JSF decides according to some rules whether a page declaration is interpreted as JSP or facelets. This behavior can be controlled by the following context parameters in the web.xml:

* javax.faces.DEFAULT_SUFFIX defines a space-separated list of view identifier extensions that JSF should interpret as JSP. The default is .jsp.
* javax.faces.FACELETS_SUFFIX defines a space-separated list of view identifier extensions that JSF should interpret as JSF. The default is .xhtml.
* javax.faces.FACELETS_VIEW_MAPPINGS defines a semicolon-separated list of view identifiers that JSF should interpret as facelets. 
This list may also contain wildcard entries such as /secure/*.

=== Using the ID attribute in JSF

In addition to the value attribute, JSF probably uses the id attribute most often. This attribute allows the developer to set a unique ID for the component. However, the ID does not have to be unique for the entire page, but only within the current naming container in which the component is embedded. Naming containers in JSF are some components that restrict large areas of the page, such as h: form , h: dataTable, or all composite components.

To help the developer keep the component IDs of a web page unique, JSF does not directly write the user-supplied ID in the rendered output. Instead, the so-called client ID of the component is used. The client ID is composed of colons separated by the ID of the component and the IDs of all parent components that are naming containers. 

For example, in Figure <<.Client IDs in MyGourmet 3, Client IDs in MyGourmet 3>>, the client IDs from the example MyGourmet 3 can be found. All input components and the buttons are located inside the form with the ID form, which can also be recognized by the client IDs.

====
.Client IDs in MyGourmet 3
image::images/client-ids-mygourmet03.jpg[]
====

Changing the page structure, adding or dropping naming containers as parents, also changes the client ID of the embedded component. 
As of JSF 1.2, this behavior can be affected for form components. 
The prependId attribute of the h: form tag controls whether the ID of the form precedes the identifiers of its components (value is true ) or not (value is false ). The default value is true. 
Figure <<.Client IDs in MyGourmet 3 with prependId set to false, Client IDs in MyGourmet 3 with prependId to false>> again shows the client IDs from the example MyGourmet 3 - this time, however, the attribute prependId of the h: form tags set to false.

====
.Client IDs in MyGourmet 3 with prependId set to false
image::images/client-ids-mygourmet03-prependid.jpg[]
====

Of course, the client ID is also needed within the source code - for example, to render the ID of a component. 
The full ID is accessed through the `getClientId(FacesContext fc)` method defined in UIComponent. 
If no ID is set for the component when this method is first called, the component is assigned an automatic ID. 
These automatic IDs are distinguishable from manually assigned identifiers through the prefix `j_id`.

=== conversion

Conversion is an important aspect of the JSF LifeCycle because values ​​are represented on the Web client as `Strings`, but as `Java types` on the server side. 
The converters play the role of an internal mediator. 
They take care of converting the user-entered `strings` into `Java objects` and convert `Java objects` back into `strings` when rendering the output.

In JSF, there are already standard converters for many data types that are used automatically. 
For example, in MyGourmet 3, if we change the type of property `creditCardNumber` of the class from `String` to `Integer`, we do not have to worry about the conversion. 
If no other converter is defined, JSF automatically uses the default converter for the data type.

This standard converter is responsible for both directions of conversion. 
For one thing, when rendering the view, it converts the integer value of the creditCardNumber property to a string. 
When submitting a form, it also converts the user-entered string back to an integer.

Each converter implements the `javax.faces.convert.Converter` `interface` shown in Listing <<.The Interface Converter, The Interface Converter>>.

.The Interface Converter
[source,java]
----
public interface Converter {
  Object getAsObject(FacesContext context,
      UIComponent component,
      String value) throws ConverterException;
  String getAsString(FacesContext context,
      UIComponent component,
      Object value) throws ConverterException;
}
----

The two directions of the conversion are obvious here: For the conversion of the Java data type into a string, the method `getAsString()` is called, for the conversion from the string back to the Java data type the method `getAsObject()`. +
Finding a converter for a component works through the following steps:

* The component tag contains a `converter` `attribute` that references a converter.
* The component tag has a `child tag` that references a converter.
* The component points to a `value` with a certain `data type` - a converter is `registered` for this `data type`.

The registration of converters in `faces-config.xml` is discussed below. 
First, in the next section, we will show you which converter JSF already delivers in the standard version.

==== Standard converter

Of the standard converters that are integrated via a child tag, the tag `f:convertDateTime` and the tag `f:convertNumber` are relevant in practice. 

The `f:convertDateTime` tag has the following properties:

* `type`: +
This attribute defines which parts of the `date value` are displayed. 
It can take the values `date`, `time` or `both`.
* `dateStyle`: +
This attribute specifies the type of `date display` when type is set to `date` or `both`. 
Possible values are `default`, `short`, `long`, `full`.
* `timeStyle`: +
This attribute specifies the type of `time display` when type is set to `time` or `both`. 
The same values ​​are valid as for the `dateStyle` entry.
* `pattern`: +
Instead of specifying type, `dateStyle` and `timeStyle`, a date pattern (such as dd.MM.yyyy) can be passed directly here.
* `timeZone`: +
The time zone for the output can be changed using this attribute, for example, the default value for this attribute is `GMT`.
* `locale`: +
Here a localization can be specified - both as a `string` and as an instance of the class `Locale` via a `Value-Expression`. 
Examples of the value are: en_US or #{session.locale}.

The tag `f:convertNumber` has the following properties:

* `type`: +
Can accept the currency or percentage properties in addition to the default number.
* `currencyCode`: +
With this property the currency can be set via an internationally valid code - for the euro that would be eg. `EUR`. 
Alternatively, you can set the attribute currencySymbol.
* `currencySymbol`: +
Alternative to the currencyCode. 
Example would be the indication of for the Euro.
* `groupingUsed`: +
Indicates whether a separator (for example, a thousands separator) is used.
* `locale`: +
Here a localization can be specified - both as a string and as an instance of the class `Locale` via a `Value-Expression`. 
Examples of the value are: `en_US` or # {session.locale}.
* `minFractionDigits`: + 
This attribute specifies the minimum number of decimal places.
* `maxFractionDigits`: +
This attribute specifies the maximum number of decimal places.
* `minIntegerDigits`: +
This attribute specifies the minimum number of decimal places.
* `maxIntegerDigits`: +
This attribute specifies the maximum number of digits before the decimal point.
* `pattern`: +
As an alternative to specifying the other attributes, this attribute can be used to directly define a pattern for the display - for example, the specification of "#.###,##" for the "German" number format is possible here.

For the individual attributes of the converters, they are as close as possible to the attributes of the localization functions of Java itself - in the Java API documentation you will find more about the possible values ​​for the individual parameters and their effects.

The handling of errors and error messages in the form of messages during conversion is explained in more detail in section [Message section].

Converter for localization: Converters are also used to localize values. 
With the `locale` attribute, the localization code for the default converters can be explicitly set - both as a `String` and as an instance of the class `Locale` via a `Value-Expression`. 
Without explicit specification, the default localization code is used. 
In the example in Listing <<.Localization with Converters, Localization with Converters>>, the date December 13, 2012 is read from a backing bean and displayed for German and English, resulting in the following output:

.Localization with Converters
----
13.12.12
12/13/12
----
[source,xhtml]
----
<h:outputText id="orderDate" value="#{orderBean.orderDate}">
  <f:convertDateTime dateStyle="short" locale="de"/>
</h:outputText>
<h:outputText id="orderDate" value="#{orderBean.orderDate}">
  <f:convertDateTime dateStyle="short" locale="en"/>
</h:outputText>
----

Converter Binding: As of JSF 1.2, the standard converter tags (`f:convertNumber`, `f:convertDateTime` and `f:converter`) have an additional attribute binding, via which the converter instance can be obtained from a `Managed-Bean`.

==== Custom converter

Of course, the functionality of the JSF framework can be extended by creating your own converter: It is possible to replace existing converters with your own as well as to process new Java data types or to develop your own converter for individual component tags.

For example, consider a converter that replaces groups of whitespace characters with an underscore in input strings. 
Listing <<.converter for replacing characters, converter for replacing characters>> shows the corresponding class `Replace-Converter`.

.converter for replacing characters
[source,java]
----
public class ReplaceConverter implements Converter {
  public Object getAsObject(FacesContext ctx, UIComponent c,
      String value) throws ConverterException {
    if (value == null) return null;
    return value.replaceAll("s+", "_");
  }
  public String getAsString(FacesContext ctx, UIComponent c,
      Object value) throws ConverterException {
    if (value == null) return null;
    return value.toString();
  }
}
----

Our converter implements the `Interface` `Converter` with the two methods `getAsObject()` and `getAsString()`. 
After we want to convert user-input strings, we replace the characters in the `getAsObject()` method. 
In the `getAsString()` method called when rendering, we simply return the string representation of the passed object (it should be a string anyway).

A small note: This converter works in the form shown above only with input components, but not with output components. Why? 
For the aforementioned reason that in `getAsString()` only the string representation of the passed object is returned.

Custom converters can be registered and federated in JSF in several ways. 
One possibility is to provide converters to individual components of a view. 
This works for all input and output components via the child element `f:converter` or a `Method_Expression` in the attribute `converter`. 
The `f:converter` tag is simply added as a child element to the tag of the desired component in the page declaration. 
However, the converter must already be registered under a unique identifier in the system. 
This identifier is then used in the `attribute` `converterId` of `f:converter` entered.

Starting with version 2.0 JSF offers the possibility to register converters with the annotation @FacesConverter in the system. 
Listing <<.Converter with @FacesConverter Register, Converter with @FacesConverter Register>> shows how the previously created converter is connected to the identifier specified in the annotation.

.Converter with @FacesConverter Register
[source,java]
----
@FacesConverter("at.irian.ReplaceConverter")
public class ReplaceConverter implements Converter {
  ...
}
----

In JSF prior to version 2.0, converters were registered only in the `faces-config.xml` file. 
Of course, in JSF 2.0 and newer versions, this variant is still available. 
To do this, a `converter` `element` must be created for each `converter` with the `child elements` `converter-id` for the identifier and `converter-class` for the class of the converter. 
Listing <<.the converter in `faces-config.xml`, the converter in `faces-config.xml`>> shows how the previously annotated registration of our converter looks like in `faces-config.xml`.

.the converter in `faces-config.xml`
[source,xml]
----
<converter>
  <converter-id>at.irian.ReplaceConverter</converter-id>
  <converter-class>
    at.irian.jsfatwork.gui.jsf.ReplaceConverter
  </converter-class>
</converter>
----

JSF offers yet another variant to connect a converter with a component. 
All input and output components have the `attribute` `converter`. 
In this `attribute`, a `Value-Expression` can be used to reference a `Managed-Bean` property of `type` `javax.faces.convert.Converter`. 
The getter method of this property must then return a new instance of the desired converter each time it is called. 
A setter method is not needed for this.

Listing <<.Custom converters in the page declaration, Custom converters in the page declaration>>  shows for both variants presented how the converter in the page declaration is connected to a component. 
When using the `attribute` `converter` Of course, there must be a `getReplaceConverter()` method in the referenced managed bean.

.Custom converters in the page declaration
[source,xhtml]
----
<h:inputText value="#{bean.stringValue}">
  <f:converter converterId="at.irian.ReplaceConverter"/>
</h:inputText>
<h:inputText value="#{bean.otherStringValue}"
    converter="#{bean.replaceConverter}"/>
----

Alternatively, it may be a good idea to create a centralized `Managed-Bean` for all application custom converters. 
This bean is in the `Application` scope and provides for each converter a getter method that returns a new instance of the converter. 
Listing <<.`Managed-Bean` for Converter, `Managed-Bean` for Converter>> shows how such a `Managed-Bean` might look like.

[source,java]
----
@ManagedBean @ApplicationScoped
public class ConverterProvider {
  public Converter getReplaceConverter() {
    return new ReplaceConverter();
  }
}
----

Registering a converter with an identifier provides a decisive advantage: Facelets make it even easier to integrate custom converters. 
In section [Section: Creating tag libraries with facelets], we show you how to easily define a tag for a custom converter in a tag library. 
In addition to incorporating custom converters into separate components, JSF also provides the ability to globally register a converter for a specific data type. 
As of JSF 2.0, it is sufficient to set the element `forClass` of the annotation `@FacesConverter` to the desired data type. 
Listing <<.converter for data type with @FacesConverter, converter for data type with @FacesConverter>> shows this for the data type `Date`.

.converter for data type with @FacesConverter
[source,java]
----
@FacesConverter(forClass = Date.class)
public class MyDateConverter implements Converter {
  ...
}
----

In JSF prior to version 2.0, converters for certain classes had to be registered in `faces-config.xml`. 
How to do this, Listing shows <<.converter for Date type, converter for Date type>> in `faces-config.xml`. 
If under `converter-for-class` a class is specified for which no converter exists yet, a new converter is registered.
Of course, this type of configuration will continue to work with JSF 2.0 and later versions.

.converter for Date type
[source,xml]
----
<converter>
  <converter-for-class>
    java.util.Date
  </converter-for-class>
  <converter-class>
    at.irian.jsfatwork.MyDateTimeConverter
  </converter-class>
</converter>
----

In the example of MyGourmet 5 in section [Section:  MyGourmet 5 : Conversion], another custom converter for postal codes is being developed and integrated into the example.

==== MyGourmet 5: Conversion

The example MyGourmet 5 extends MyGourmet 4 from section [Section:  MyGourmet 4 : Phase Listener and System Events] by some input fields and shows the use of standard and custom converters.

Starting with this example, let's change the underlying backing bean. 
So far, there has been a bean that has all the characteristics of the customer and the code for the page. 
With regard to the extensions in this section, it makes sense to separate these aspects. 
The customer's data is now in the class `Customer` in the package `at.irian.jsfatwork.domain`. 
The `Managed-Bean` `CustomerBean` replaces the previous class `Customer` in the package `at.irian.jsfatwork.gui.page`. 
It contains a customer property for the current customer and code relevant to the page.

To demonstrate the converter, the class `Customer` also receives the properties `birthday`, `zipCode`, `city` and `street`. 
For entering the date of birth on `editCustomer.xhtml` we add the default converter `f:convertDateTime` with a pattern. 
Listing <<.input component with date converter, input component with date converter>> shows the tag.

.input component with date converter
[source,xhml]
----
<h:inputText id="birthday" size="30"
    value="#{customerBean.customer.birthday}">
  <f:convertDateTime pattern="dd.MM.yyyy"/>
</h:inputText>
----

The birthdate on `showCustomer.xhtml` uses the same default converter. 
Listing <<.output component with date converter, output component with date converter>> shows the tag.

.output component with date converter
[source,xml]
----
<h:outputText
    value="#{customerBean.customer.birthday}">
  <f:convertDateTime pattern="dd.MM.yyyy"/>
</h:outputText>
----

As an example of a user-defined converter, we want to develop a converter that allows you to enter postcodes with country codes without saving them. 
For this purpose, all letters including the first occurrence of the character '-' are ignored. 
The remainder of the entered string must then be a number. 
The input A-1010 then becomes, for example, the number 1010.

The new converter `ZipCodeConverter` is derived from the JSF class `IntegerConverter`, which has the advantage that the actual conversion of the postal code without the country code can be done by it. 
Listing <<.converter for postal codes with country codes, converter for postal codes with country codes>> shows the code of the class. 
With the annotation @FacesConverter we register the converter under the identifier `at.irian.ZipCode` for later use in the system.

[source,java]
----
@FacesConverter(value="at.irian.ZipCode")
public class ZipCodeConverter
    extends IntegerConverter implements Serializable {
  public Object getAsObject(FacesContext ctx,
      UIComponent component,String value)
      throws ConverterException {
    if (value != null && value.length() > 0) {
      int pos = value.indexOf('-');
      for (int i = 0; i < pos; i++) {
        if (!Character.isLetter(value.charAt(i))) {
          throw new ConverterException("Zip invalid.");
        }
      }
      if (pos > -1 && pos < value.length() - 1) {
        return super.getAsObject(
            ctx, component, value.substring(pos + 1));
      }
    }
    return super.getAsObject(ctx, component, value);
  }
}
----

Particularly interesting is the part that handles the error handling: If the zip code does not match the pattern, an exception instance of the type `ConverterException` is generated. 
The exception is linked through its constructor to a message, which is then output as an error message in the web browser.

The user-defined converter `ZipCodeConverter` is integrated via the child element `f:converter` in `editCustomer.xhtml`. 
Listing <<.converter via identifier, converter via identifier>> shows the corresponding tag.

.converter via identifier
[source,xhtml]
----
<h:inputText id="zipCode" size="30" required="true"
    value="#{customerBean.customer.zipCode}">
  <f:converter converterId="at.irian.ZipCode"/>
</h:inputText>
----

Now that we've converted all the input to the required data types, we'll turn to validating user input in the next section.

=== validation

Entering data is a matter that users like to make mistakes - identifying and preventing the entry of erroneous data into the model must be a concern of any development framework. 
JSF already offers many possibilities out-of-the-box to prevent such mistakes.

For validating user input, so-called `Validators` are used in JSF. 
The linking of `Validators` and input components is very simple - similar to the integration of converters. 
In addition to a set of standard validators included with JSF, it's easy to write your own validators.

With JSF 2.0 and above, validation is even easier with support for the BeanValidation concept (JSR-303). 
New mechanisms enable for the first time fully `metadata-based` validation without detours. 
Section [JSR-303 bean validation section] is dedicated to this highly topical issue and shows how to use bean validation in combination with JSF in your own projects.

Then, in Section [Standard Validators], we turn to the default validators before we show you how to create custom validators in the [Custom Validators] section.

==== Bean validation according to JSR-303

JSF 2.0 was a big step forward for web application validation. 
Before that, validation across the layer boundaries has always led to redundancy. 
In many cases, the same validation rules were implemented in multiple layers of the application. 
In addition to an increased implementation effort, this approach also leads to a higher error rate. 
Validation was then applied, for example, through JSF validators in the view as well as persisting the entities in the service.

The combination of JSF version 2.0 and BeanValidation (JSR-303) changes that radically. 
Bean Validation defines a `metadata model` and a Java API to focus validation on the domain classes. 
Constraints are implemented in the form of `Validator` classes bound to `JavaBeans` with annotations. 

Using the example of MyGourmet, let's take a look at how bean validation is used in practice. 
For a property of a bean bound to an input component, JSR-303-compliant metadata will be automatically validated. 
Listing <<.Validation with bean validation, Validation with bean validation>> shows a snippet of the class `Customer` with bean validation metadata. 
With the annotation `@NotNull` Let's avoid one of the three properties taking on the value `null`. 
The `zipCode` property is additionally restricted to a value range of `1000 to 99999` with the annotations `@Min` and `@Max`.

.Validation with bean validation
[source,java]
----
public class Customer {
  @NotNull @Min(value = 1000) @Max(value = 99999)
  private Integer zipCode;
  @NotNull
  private String city;
  @NotNull
  private String street;
  ...
}
----

An important precondition is to be considered: In order for missing user input from JavaServer Faces to be interpreted as `null` values, the context parameter `javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL` must be set to `true` in the `web.xml`. 
By default, JSF ignores input components without user input during validation. 
This behavior then makes it impossible, for example, to use @NotNull. 

That's it! More is not necessary to use bean validation as of JSF 2.0 if an implementation of JSR-303 is available in the runtime environment. 
In MyGourmet this is due to a dependence on Hibernate Validator v4, the reference implementation of JSR-303, guaranteed in the Maven project file `pom.xml`. 
As you can see, we did not have to change any of the views to enable validation.

For the full example of MyGourmet 6, with all the validation changes, see section [section: MyGourmet 6 validation].

In the following list you will find a list of all standard constraints in bean validation:

* `@AssertFalse` +
The annotated element must be `false`.
* `@AssertTrue` +
The annotated element must be `true`.
* `@DecimalMax` +
The annotated element must be less than or equal to the value specified in `value`. 
Note that `value` is a `String` that is interpreted as `BigDecimal` (see the API documentation for BigDecimal for details).
* `@DecimalMin` +
The annotated element must be greater than or equal to the value specified in `value`. 
Note that `value` is a `String` that is interpreted as `BigDecimal` (see the API documentation for BigDecimal for details).
* `@Digits` +
The annotated element can not have more than integer digits before the comma and no more than fractional digits after the decimal point.
* `@Future` +
The annotated element must be a `date` in the future.
* `@Max` +
The annotated element must be less than or equal to the value specified in `value`. 
In contrast to `@DecimalMax`, value here has the type `long`.
* `@Min` +
The annotated element must be greater than or equal to the value specified in `value`. 
In contrast to `@DecimalMin`, value here has the type `long`.
* `@NotNull` +
The annotated element can not be `null`.
* `@Null` +
The annotated element must be `null`.
* `@Past` +
The annotated element must be a `date` in the past.
* `@Pattern` +
The annotated element must match the regular expression specified in `regexp`.
* `@Size` +
The size of the annotated element must be between `min` and `max`. 
`Strings` and all `Collection` types can be validated with this constraint.

MyFaces ExtVal: Unfortunately, JSF does not provide the full functionality of Bean-Validation. 
Alternatively, you can take a look at the project MyFaces Extensions Validator (aka ExtVal) Further information on the project MyFaces ExtVal see http://myfaces.apache.org/extensions/validator. 
Throw that an adapter for JSR-303 compliant implementations. 
This adapter also provides additional functionality and alternative concepts. 
For example, MyFaces becomes `ExtVal` for group validation (as an alternative to declarative in the view) provide annotations for the properties and action methods in the backing bean. 
This makes refactoring much easier and can be done reliably. 
Beyond the standard, MyFaces `ExtVal` offers its own validation module with additional functions especially for JSF. 
Among other things, cross-component validation is supported. 
MyFaces `ExtVal` can also be used with JSF 1.1 and JSF 1.2.

===== Custom Constraints with Bean Validation

With `Bean-Validation`, you can easily create your own Validators and Constraints. 
We want to use this feature in MyGourmet and create a Validator that checks the birth date for a specific period of time. 
The date can not be before 1.1.1900 and not in the future.

All we need is an annotation and a Validator class. 
Let's start with the annotation `@Birthday`. 
For this annotation to be used as a constraint for `Bean-Validation`, it must be annotated with `@Constraint`. 
The element `validatedBy` connects to the `Validator` class, in our case. 
A constraint annotation must be at least over the elements `message` to define an error message, `groups` to define validator groups, and `payload` to pass additional information. 
Listing <<.custom constraint annotation displays the code of @Birthday, custom constraint annotation displays the code of @Birthday>>.

.custom constraint annotation displays the code of @Birthday
[source,java]
----
@Constraint(validatedBy = BirthdayValidator.class)
@Retention(RUNTIME)
@Target({ANNOTATION_TYPE, METHOD, FIELD})
public @interface Birthday {
  String message() default "Wrong birthday";
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
}
----

The two annotations `@Retention` and `@Target` ensure that the annotation is evaluated at runtime and can be applied to other annotations, methods and fields. 
The element has a default value, which is output as an error message if it is not overwritten. 
The default value should ideally refer to a resource bundle, more in Section [Internationalization Section]. 

For the successful use of our constraint only the Validator class `BirthdayValidator` is missing. 
It must implement the `ConstraintValidator` `interface`, parameterized with the previously defined annotation and the data type to be validated. 
The method initialize gets the associated annotation as a parameter during the validation process and serves to initialize the validator. 
The actual validation then takes place in the method `isValid()`, which receives the `value` to be validated and the current context. 
In case of successful validation, it must return `true`. 
Listing <<.Validator for custom constraint, Validator for custom constraint>> shows the source code.

.Validator for custom constraint
[source,java]
----
public class BirthdayValidator
    implements ConstraintValidator<Birthday, Date> {
  public void initialize(Birthday birthday) {}

  public boolean isValid(Date date,
      ConstraintValidatorContext ctx) {
    boolean dateCorrect = true;
    if (date != null) {
      ctx.disableDefaultConstraintViolation();
      if (date.after(new Date())) {
        ctx.buildConstraintViolationWithTemplate(
            "Birthday is in the future.")
            .addConstraintViolation();
        dateCorrect = false;
      }
      Calendar cal = Calendar.getInstance();
      cal.set(Calendar.YEAR, 1900);
      cal.set(Calendar.MONTH, 0);
      cal.set(Calendar.DAY_OF_MONTH, 1);
      if (date.before(cal.getTime())) {
        ctx.buildConstraintViolationWithTemplate(
            "Birthday is before Jan 1, 1900.")
            .addConstraintViolation();
        dateCorrect = false;
      }
    }
    return dateCorrect;
  }
}
----

Since we perform two different checks in `isValid`, we also want to define two different error messages. 
The standard error message should not be displayed at all and is switched off by means of `ctx.disableDefaultConstraintViolation()`. 
Now we can add any error messages to the context with the following code, which are then converted into JSF messages:

----
ctx.buildConstraintViolationWithTemplate("Fehlermeldung")
    .addConstraintViolation();
----

Our custom constraint is now ready for use. 
The birthday property of the `Customer` class looks like this with the new annotation:

----
@Birthday
private Date birthday;
----

==== Standard Validators

After the brief introduction to `Bean-Validation` with JSF, we will focus on the remainder of the classic JSF validation section. 
For inclusion as a child tag, a list of validators is already available in the JSF standard:

* `f:validateLength`: + 
This Validator checks the `length of a string` based on the values ​​of the `minimum` and `maximum` attributes. 
The following example allows you to enter a string of minimum length three and maximum length seven:

[source,xhtml]
----
<h:inputText value="#{backingBean.property}">
  <f:validateLength minimum="3" maximum="7"/>
</h:inputText>
----

* `f: validateLongRange`: + 
To check if an `integer` is `within a certain range`, JSF offers the `LongRange` validator. 
Again, the valid attributes are `minimum` and `maximum`. 
An example of checking a number in the range 0-1000:

[source,xhtml]
----
<h:inputText value="#{backingBean.property}">
  <f:validateLongRange minimum="0"
        maximum="1000"/>
</h:inputText>
----

* `f: validateDoubleRange`: + 
JSF offers the `DoubleRange` `Validator` to check if a `floating-point` number is within a certain range. 
Again, the valid attributes are `minimum` and `maximum`. 
An example of checking a number in the range 0.0 - 1.0:

[source,xhtml]
----
<h:inputText value="#{backingBean.property}">
  <f:validateDoubleRange minimum="0.0"
        maximum="1.0"/>
</h:inputText>
----

* `f: validateRegex`: +
This Validator checks if the `String` value `matches the regular expression` specified in the `pattern` attribute. 
For a detailed explanation of regular expressions in Java, see the Java API documentation. 
Here is a small example where the value of a component must consist of a capital letter followed by any sequence of letters:

[source,xhtml]
----
<h:inputText value="#{backingBean.property}">
  <f:validateRegex pattern="[A-Z][a-zA-Z]*"/>
</h:inputText>
----

* `f: validateRequired`: + 
This Validator checks if the user has ever specified a value.

As you've probably noticed, the Validator is only available as of JSF 2.0. 
How did that work before? 
In older versions, the same effect was achieved by setting the `required` attribute on the individual input components. 
If the `attribute` is set to `true`, the validation of the component fails with a blank value. 
As of JSF 2.0, you can use both variants, but your own validator fits better into the validation concept. 

Until JSF 2.0, you can not check `null` in custom validators because JSF does not call validation at all unless the `required` attribute of a component is set `false` and the user has not entered anything. 
This behavior was necessary because Validators could not be made optional. 
As of JSF 2.0, this behavior can be controlled via the context parameter `javax.faces.VALIDATE_EMPTY_FIELDS`. 
A value of `true` (or `auto` in combination with `Bean-Validation`) instructs JSF to validate `empty` input components as well.

Validator Binding: As of JSF 1.2, the tags of the standard validators have an additional `attribute` `binding`, which can be used to link a validator instance with a property of a `Managed-Bean`. 
The linked property must be of type `javax.faces.validator.Validator` respectively.

As of JSF 2.0, all standard Validators have the `disabled` attribute, which takes a `Value-Expression`. 
If the expression evaluates to `true`, the Validator is not used in the lifecycle.

Combination of validators: It is possible to combine validators - for example, to ensure that a `String` is specified that is between three and six characters long and consists of a capital letter followed by a number of other letters (see Listing <<.combination of validators, combination of validators>>).

.combination of validators
[source,xhtml]
----
 <h:inputText value="#{backingBean.wert}">
  <f:validateRequired/>
  <f:validateLength minimum="3" maximum="6"/>
  <f:validateRegex pattern="[A-Z][a-zA-Z]*"/>
</h:inputText>
----

==== Custom validators

If you need reviews that are not covered by standard validators, you can write your own validators. 
The easiest way to do that is with validation methods. 
These are referenced with a `Method-Expression` in the `validator` `attribute` of the input component and must have the signature shown in the Listing <<.signature of a validation method, signature of a validation method>>. 
The name of the method is freely selectable.

.signature of a validation method
[source,java]
----
 public void validate(
    FacesContext ctx,
    UIComponent component,
    Object value) throws ValidatorException;
----

Let's look at a small example in detail. 
Our user-defined `Validator` should check a string for the values `yes` and `no` and generate an error message for all other inputs. 
Listing <<.example of a validation method, example of a validation method>> shows the corresponding method.

.example of a validation method
[source,java]
----
 public void yesNoValidate(FacesContext ctx, UIComponent comp,
    Object value) throws ValidatorException {
  if (value instanceof String) {
    String strValue = (String) value;
    if (!(strValue.equals("ja")
        && !(strValue.equals("nein")))) {
      throw new ValidatorException(
          new FacesMessage("messageText", null));
    }
  } else {
      throw new ValidatorException(
          new FacesMessage("messageText", null));
  }
}
----

In case of an error, the method throws a `ValidatorException` with an associated `FacesMessage`. 
It is displayed to the user. 
The handling of errors and error messages in the form of validation messages is explained in more detail in the section [Message section].

For this method to be called during the validation process, it must be connected to the input component:
----
<h:inputText value="#{backingBean.wert}"
  validator="#{backingBean.yesNoValidate}"/>
----

If, in addition to a validation method, additional validators with tags are integrated into the component, the validation method always comes last. 

Cross-Component Validation: Some use cases require validation methods that do not just validate the value of a component. 
The method must be linked to the last component to be validated - only then can the converted and validated values ​​of all other components be accessed. 
For an example of cross-component validation, see MyGourmet 6 in section [Section:  MyGourmet 6: Validation].

Custom validators can also be implemented as stand-alone classes that must then implement the `javax.faces.validator.Validator` interface. 
In a page declaration, such validators are integrated with the tag `f:validator` as a child element in an input component. 
The `validatorId` `attribute` of this tag refers to the identifier under which the validator class is registered in the system. 
The registration of a validator can also be done with an annotation as with converters in `faces-config.xml` or as of JSF 2.0. 
Listing <<.registration of a validator with identifier, registration of a validator with identifier>> shows the corresponding fragment of the configuration - is the equivalent annotation.

.registration of a validator with identifier
[source,xml]
----
<validator>
  <validator-id>at.irian.YesNo</validator-id>
  <validator-class>
    at.irian.jsfatwork.YesNoValidator
  </validator-class>
</validator>
----

JSF 2.2: As of JSF 2.2, the element `value` of the annotation @FacesValidator is `optional` and is supplemented with a naming convention. 
If not specified, JSF uses the class name with a small initial letter as `validatorID`. 
For our validator class `YesNoValidator` this would be the id `yesNoValidator`.

==== MyGourmet 6: Validation

MyGourmet 6 extends its predecessor MyGourmet 5 from section [Section:  MyGourmet 5: Conversion]. 
The focus of this example, as the previous section makes it easy to guess, is on standard and custom validators.

Most of the validation tasks in MyGourmet are handled by bean validation - as we saw in [JSR-303 bean validation section]. 
Listing <<.MyGourmet 6: Bean Customer with Annotations, MyGourmet 6: Bean Customer with Annotations>> shows all the properties of the class `Customer` with the bean validation annotations, but without the associated getters and setters.

.MyGourmet 6: Bean Customer with Annotations
[source,java]
----
public class Customer {
  @NotNull
  private String firstName;
  @NotNull
  private String lastName;
  @NotNull
  private String email;
  @NotNull @Min(value = 1000) @Max(value = 99999)
  private Integer zipCode;
  @NotNull
  private String city;
  @NotNull
  private String street;
  @Birthday
  private Date birthday;
  private Boolean useCreditCard = Boolean.FALSE;
  @NotNull
  private CreditCardType creditCardType;
  @NotNull
  private String creditCardNumber;
  ...
}
----

To introduce the use of the JSF default validators, the address zip code in `editCustomer.xhtml` could also be validated to range 1000 through 99999 instead of bean validation using the `f:validateLongRange` tag.

Listing MyGourmet 6: Validating the postcode with default validator shows the corresponding fragment of the page.

[source,xml]
----
<h:inputText id="zipCode" size="30" required="true"
    value="#{customerBean.customer.zipCode}">
  <f:converter converterId="at.irian.ZipCode"/>
  <f:validateLongRange minimum="1000" maximum="99999"/>
</h:inputText>
----

We also want to show you how the customer's date of birth is validated in the classic way. 
For this purpose the validator BirthdayValidator (not to be confused with the constraint validator from section [Section: bean validation according to JSR-303] !) Is used, which checks the date for the value range and in the system under the name `at.irian.Birthday` is registered. 
Listing MyGourmet 6: Date Validator shows the code.

[source,java]
----
@FacesValidator(value = BirthdayValidator.VALIDATOR_ID)
public class BirthdayValidator 
    implements Validator, Serializable {
  private static final long serialVersionUID = 1L;
  public static final String VALIDATOR_ID = "at.irian.Birthday";

  public void validate(FacesContext ctx, UIComponent component,
      Object value) throws ValidatorException {
    Date date = (Date)value;
    if (date.after(new Date())) {
      FacesMessage msg = new FacesMessage(
          FacesMessage.SEVERITY_ERROR,
          "Birthday is in the future.", null);
      throw new ValidatorException(msg);
    }
    Calendar cal = Calendar.getInstance();
    cal.set(Calendar.YEAR, 1900);
    cal.set(Calendar.MONTH, 0);
    cal.set(Calendar.DAY_OF_MONTH, 1);
    if (date.before(cal.getTime())) {
      FacesMessage msg = new FacesMessage(
          FacesMessage.SEVERITY_ERROR,
          "Birthday is before Jan 1, 1900.", null);
      throw new ValidatorException(msg);
    }
  }
}
----

If the user specifies a date outside this range, a ValidatorException is thrown with a corresponding FacesMessage. 
The inclusion of this custom validator in the page declaration can be seen in Listing MyGourmet 6: Birthdate Validation.

[source,xml]
----
<h:inputText id="birthday" size="30"
    value="#{customerBean.customer.birthday}">
  <f:convertDateTime pattern="dd.MM.yyyy"/>
  <f:validator validatorId="at.irian.Birthday"/>
</h:inputText>
----

As an example of a cross-component validation with a validation method, the credit card number is made dependent on the card type selected. 
If card A is selected, the card number must be four characters long, and card B must be five characters long. 
The extended tags for the type and the card number on the page editCustomer.xhtml shows listing MyGourmet 6: credit card data with validation .

[source,xml]
----
<h:selectOneListbox id="ccType"
    value="#{customerBean.customer.creditCardType}"
    rendered="#{customerBean.customer.useCreditCard}">
  <f:selectItems value="#{customerBean.creditCardTypes}"/>
  <f:event type="javax.faces.event.PostValidateEvent"
      listener="#{customerBean.postValidateCCType}"/>
</h:selectOneListbox>
<h:inputText id="ccNumber"
    value="#{customerBean.customer.creditCardNumber}"
    rendered="#{customerBean.customer.useCreditCard}"
    validator="#{customerBean.validateCreditNumber}"/>
----

In Listing MyGourmet 6: Credit Card Data with Validation, note that the components are shown or hidden by the rendered attribute, depending on the value of the `useCreditCard` property. 
Because JSF validates only rendered components, we can use it to control validation.

For validating the credit card number, the method `validateCreditNumber()` of the class `CustomerBean` is responsible. 
The number entered by the user is passed directly to the method as a `value` `argument`. 
However, reading the current credit card type requires a little more effort. 
Easy access to the `useCreditCard` property of the current customer does not always deliver the current value in this case. 
The reason for this is simple: The property in the model is updated only after the successful validation of all components and still has the old value at the time of calling the validation method. 
There are several ways to read the current value entered by the user.

On the one hand, the component for the credit card type can be linked with the binding attribute to a property of the backing bean - a process that also includes component binding is called. 
The binding provides direct access to the component in the validation method. 
However, if the bean is in the session scope as in our case, component binding can lead to unpleasant side effects because the component is created only once and then placed in the bean. 

JSF offers another very elegant way to read the current credit card type using the system event PostValidateEvent. 
This event is triggered immediately after validating a component. 
So we just need to register a listener method for this event with the `f:event` tag (see Listing MyGourmet 6: Credit Card Data with Validation) and then access the component and the current value in this method. 
Listing MyGourmet 6: System Event Listener for Validation shows the listener method for the PostValidateEvent system event in the CustomerBean class.

[source,java]
----
public void postValidateCCType(ComponentSystemEvent ev) {
  this.creditCardTypeInput = (UIInput)ev.getComponent();
}
----

See Listing MyGourmet 6: Credit Card Number Validation Method for the implementation of the validation method in the CustomerBean class. 
Note the access to the creditCardTypeInput field for reading the current credit card type. 
Since the order of validation of individual components in JSF is always determined by the component tree, this field is guaranteed to be set before the validation method is called.

[source,java]
----
public void validateCreditNumber(FacesContext ctx,
    UIComponent comp, Object value) throws ValidatorException {
  CreditCardType ccType =
      (CreditCardType)creditCardTypeInput.getValue();
  Boolean useCC = customer.getUseCreditCard();
  if (useCC != null && useCC && ccType != null) {
    String ccNumber = (String)value;
    int length;
    if (ccType == CreditCardType.CARD_A) length = 4;
    else length = 5;
    if (!ccNumber.matches("
d{" + length + "}")) {
      String msgText = MessageFormat.format(
          "Card number must consist of {0} digits.", length);
      FacesMessage msg = new FacesMessage(
          FacesMessage.SEVERITY_ERROR, msgText, null);
      throw new ValidatorException(msg);
    }
  }
}
----

=== Messages

The term message in JSF refers to an instance of the class `javax.faces.application.FacesMessage`, which is used internally for messages of all kinds. 
Messages are generated during the execution of the lifecycle or by the application and inserted in a queue in the `Faces-Context`. 
If there are any `h:messages` or `h:message` components on the page, the messages are rendered.

An example of using messages in the JSF lifecycle: If an error occurs during conversion or validation, the affected component creates a message and declares it invalid. 
In this case, execution of the lifecycle after conversion and validation jumps directly to the render-response phase and the page is redisplayed with the error messages. 

A message can have an overview message and detailed information. 
But messages do not always have to be error messages. 
JSF defines the following severities for FacesMessage instances:

* SEVERITY_FATAL
* SEVERITY_ERROR
* SEVERITY_WARN
* SEVERITY_INFO (default value )

In MyGourmet 6, we used messages in the custom converters or validators. 
Here's an example of the code that creates an error message for a birthdate in the future:

[source,java]
----
if (date.after(new Date())) {
  FacesMessage msg = new FacesMessage(
      FacesMessage.SEVERITY_ERROR,
      "Birthday is in the future.", null);
  throw new ValidatorException(msg);
}
----

However, messages can also be added when processing the application logic by calling the FacesContext.addMessage() method. 
Global and Local Messages: In the example above, the message is passed to the constructor. 
This is a local message. 
The message is connected directly to the affected component when the exception is caught in JSF. 
Where does that matter? 
We have already discussed this with the message components themselves - there are two tags for the output of the messages : One is the h: messagesTag that displays all messages, both component and global messages, the other is the <h: message for = "componentId" /> tag, which represents only the messages of a particular component. 
The first parameter of the addMessage () method can therefore be used to influence in which message areas the message will appear. 

The tags h: messages and h: message have the attributes show-summary and showDetail, These attributes can be used to set whether the detailed information or the overview message of the message is displayed. 
Since version 1.2 of JSF, there are additionally the attributes converterMessage , requiredMessage and validatorMessage for input components . 
These can be used to override specific error messages of individual components with user-defined character strings. 
The names are self-explanatory. 
Also, since JSF 1.2, there is a label attribute for input components whose value is used for error messages instead of IDs. 

When working with JSF, it makes sense to use a h: messagesTag on the side. 
If an error occurs during the conversion and validation of a page, the model is not changed and the application logic is not executed - so it is not possible to navigate to a new page. 
Without the h: messages tag, however, the occurrence of errors is incomprehensible to users (and of course also to application developers). 
Starting with JSF 2.0, an h: messages component will automatically be added to every page if it does not already exist - but only if the project stage is set to Development (as shown in Section Section: Project Stage ). 
In JSF versions prior to 2.0, you must use the h: messagesAlways install the tag yourself in the page. 
The text of the message is given in the example above directly in English. 
However, messages displayed to the user should be internationalized in any case. 
Section [Internationalization section] shows how this works.

=== Internationalization

An important topic in the development of web applications is internationalization. 
This includes, on the one hand, storing strings independently of the application, so that these strings can be transferred from translators to other languages. 
On the other hand, depending on the region, there may be a different conversion of dates, numbers, and currency. 
JSF is equipped to do that and makes locating your application a breeze.

==== Determination of the localization code

When running a JSF application, it runs for each user with a specific location code, also called `locale`. 
The `locale` is composed of two statements. 
On the one hand, the language is set to the code in which the application is to run, on the other hand the establishment of a state takes place 
There are significant differences in the application of one and the same language in different countries. 
Sometimes a division is also made in a third level, for example, dialects within the language of a state.

The definition of the supported localization codes of an application takes place in the `faces-config.xml` file. 
Listing Configuration for internationalization shows an example of a configuration. 
The configured application supports the languages German, English for the USA, English for Great Britain and French.

[source,xml]
----
<application>
  <locale-config>
    <default-locale>en</default-locale>
    <supported-locale>de</supported-locale>
    <supported-locale>en_US</supported-locale>
    <supported-locale>en_GB</supported-locale>
    <supported-locale>fr</supported-locale>
  </locale-config>
  <message-bundle>
    at.irian.jsfatwork.messages
  </message-bundle>
</application>
----

Localization in Request: Which localization code is actually selected is up to the user who connects to the system. 
The user's browser sends an `HTTP` header with the desired location. 
If the application supports this localization, it is selected - otherwise the default setting is used.

Localization in the view: If you want to select a locale not dependent on the `HTTP` request to make for example, a German user sitting at a Web client in a French internet café and wants to see in his language. the user interface, of course, the localization code on a page can the indication of the locale attribute is set centrally on the `f:view` tag. 
This attribute can be dynamically bound to the property of a managed bean. An example:
----
<f:view locale="#{userBean.userLocale}">
    ...
</f:view>
----
==== Internationalization of JSF Messages

The entry `message-bundle` in the `faces-config.xml` determines where the file for the messages of the application can be found. 
Therefore, for configuration from Listing Configuration for Internationalization, the following files in the package `at.irian.jsfatwork` are required to cover all the languages ​​specified:

* `messages.properties`
* `messages_de.properties`
* `messages_en_US.properties`
* `messages_en_GB.properties`
* `messages_fr.properties`

In these files, you can manage the texts for messages that your application generates in custom converters, validators, or even bean methods. 
Furthermore, the messages used by the system can be overwritten if needed.

Now that the bundles are configured and created, we want to use them. 
In the example of MyGourmet 6, we generated messages in the custom validation methods in the event of an error. 
The text is there, however, still specified. 
To change that, we create a helper method that creates an instance of the `FacesMessage` class with a localized text. 
Listing Internationalized messages in the backing bean demonstrates this method.

[source,java]
----
public static FacesMessage getFacesMessage(
    FacesContext ctx, FacesMessage.Severity severity,
    String msgKey, Object... args) {
  Locale loc = ctx.getViewRoot().getLocale();
  ResourceBundle bundle = ResourceBundle.getBundle(
      ctx.getApplication().getMessageBundle(), loc);
  String msg = bundle.getString(msgKey);
  if (args != null) {
    MessageFormat format = new MessageFormat(msg);
    msg = format.format(args);
  }
  return new FacesMessage(severity, msg, null);
}
----

The code is simple: The method `getMessageBundle()` returns the name of the bundle - the view root the current locale. 
With these two pieces of information the concrete bundle is loaded - from this the text for the indicated key is read out. 
This text will then be used as a summary message when creating the message. 
The detailed information is not given here.

Messages generated by standard components always provide an overview message and detailed information. 
In the `.properties` file, therefore, there is an entry with a suffix _detail appended to the key.

If you use Apache MyFaces, you can also use the class Use `org.apache.myfaces.shared_impl.util.MessageUtils` to create localized messages. 
With this class you also have the advantage that detailed information is automatically read out according to the above-mentioned scheme.

===== Messages for bean validation

If you create your own constraints for bean validation, you should also use internationalized messages. 
Bean Validation is a JSF independent system - so the texts are defined elsewhere. 
Error messages in curly brackets are resolved in the Resource Bundle ValidationMessages . 
For example, the text {validator.msg} is interpreted as the key for the resource bundle.

By default, the bean validator creates JSF messages in a slightly different format than other JSF validators. 
While other validators start the error message with the input component label and a colon, the bean validator returns the text that comes back from the bean validation API. 
This behavior can easily be changed. 
To do this, you must exchange the message format template of the bean validator in the message bundle of the application. 
Add the lines from Listing Bean Validator messages. 
The placeholder {0} indicates the actual error message and {1} the label.

[source,xml]
----
javax.faces.validator.BeanValidator.MESSAGE={1}: {0}
javax.faces.validator.BeanValidator.MESSAGE_detail={1}: {0}
----

A more detailed description of the internationalization of MyGourmet with examples follows in Section [Section:MyGourmet 7: Internationalization].

==== Internationalization of application texts

For the other texts in applications (for example, for descriptions or labels), the procedure is somewhat different - since JSF 1.2, there are two different ways to reference a resource bundle.

The first method is the `f:loadBundle` tag, which exposes a resource bundle for use on the same page. 
This tag should no longer be used as it will make the internationalized data available only from the render response phase.

These problems can be avoided with the newer method. 
The resource bundle in `faces-config.xml` is referenced with the resource-bundle element in the application section . 
Listing Internationalization through configuration with resource-bundle shows how the example was implemented earlier with this method, with the advantages that the texts are available in all pages and that they also work with Ajax.

----
<resource-bundle>
  <base-name>de.test.resource.text</base-name>
  <var>text</var>
</resource-bundle>
----

Access to the elements of the resource bundle is identical for both methods and is done via a value expression in the `value` attribute. 
An example:
----
<h:outputText value="#{text.description}"/>
----
For the first part of the value expression, the name of the variable assigned to the `.properties` file is used and, as an attribute name, the key of the entry in the file. 
The power hidden in JSF is shown by the ability to use that expression in almost every attribute of every tag, not just the value attribute. 

For the internationalization of applications, the `h:outputFormat` tag is of particular importance. 
The decisive advantage over `h:outputTexts` the support of message format templates. 
This makes it possible to define texts with placeholders already in the resource bundle of the application. 
The position of the placeholders can even be adapted to the respective language - an important step in the direction of maintainability and central internationalization of texts.

The following example displays a status message for the customer's profile with parameters:

----
<h:outputFormat value="#{msgs.profile_msg}" rendered=
    "#{customerBean.customer.firstName != null}">
  <f:param value="#{customerBean.customer.firstName}"/>
  <f:param value="#{msgs.profile_active}"/>
</h:outputFormat>
----

In the German Resource Bundle `profile_msg` and `profile_active` could be defined as follows:

----
profile_msg=Ihr Profil ist {1}, {0}.
profile_active=aktiv
----
In the English translation, the following strings could result:
----
profile_msg={0}, your profile is {1}.
profile_active=active
----
The adaptation of the example to different languages ​​only takes place in the resource bundle of the application. 
By using the OutputText component directly, such a flexible approach is impossible.

Access from the backing bean: As in the page declaration, the internationalized texts can also be accessed from the backing bean code. .
Prior to JSF 1.2, there was no specific solution - Java provides the necessary code. 
In version 1.2 this has changed. 
Texts embedded with resource-bundle can now be resolved directly with their application name using `Application.getResourceBundle()`. 
Listing Internationalized Texts in the Backing Bean shows a helper method to load texts from a resource bundle.

[source,java]
----
 public static String getResourceText(FacesContext ctx,
    String bundleName, String key, Object... args) {
  String text;
  try {
    Application app = ctx.getApplication();
    ResourceBundle bundle = app.getResourceBundle(
        ctx, bundleName);
    text = bundle.getString(key);
  } catch (MissingResourceException e) {
    return "???" + key + "???";
  }
  if (args != null) {
    text = MessageFormat.format(text, args);
  }
  return text;
}
----
The example MyGourmet 7 in the next section shows the practical use of message and resource bundle.

==== MyGourmet 7: Internationalization

The example MyGourmet 7 corresponds in functionality exactly to the predecessor example MyGourmet 6 from section [section: MyGourmet 6: Validation].
The changes relate only to the internationalization of the application.

The first step is to configure the localization in the `faces-config.xml` file. 
In our case, German is configured as the default value and English as the supported language (Listing <<.MyGourmet 7: Configuration, MyGourmet 7: Configuration>>).

.MyGourmet 7: Configuration
[source,xml]
----
 <application>
  <locale-config>
    <default-locale>de</default-locale>
    <supported-locale>en</supported-locale>
  </locale-config>
  <message-bundle>
    at.irian.jsfatwork.messages
  </message-bundle>
  <resource-bundle>
    <base-name>
      at.irian.jsfatwork.messages
    </base-name>
    <var>msgs</var>
  </resource-bundle>
</application>
----

The resource bundles are stored in the package `at.irian.jsfatwork` under the name of `messages` - a bundle with the name `messages_de` for the German language and a bundle with the name `messages_en` for the English language. 
By configuring the resource-bundle element, the bundle named `msgs` can be used in all pages of the application in `EL` expressions. 
In Listing <<.Extract from the German Bundle of MyGourmet, Extract from the German Bundle of MyGourmet>> you can find an excerpt from the bundle `messages_de.properties` for the German language.

.Extract from the German Bundle of MyGourmet
----
title_main=MyGourmet
title_show_customer=Kunde
title_edit_customer=Kunde bearbeiten
first_name=Vorname
last_name=Nachname
email=E-Mail-Adresse
birthday=Geburtstag
use_credit_card=Kreditkarte angeben
credit_card_type=Kreditkarten-Typ
credit_card_number=Kreditkarten-Nummer
profile_msg=Ihr Profil ist {1}, {0}.
profile_active=aktiv
credit_card_type_CARD_A=Card A
credit_card_type_CARD_B=Card B
validateBirthday.MAXIMUM=Geburtsdatum liegt in der Zukunft.
validateBirthday.MINIMUM=Geburtsdatum ist vor dem 1.1.1900.
validateCreditCardNumber.NUMBER=Kreditkartennummer muss aus {0} Ziffern bestehen.
javax.faces.validator.BeanValidator.MESSAGE={1}: {0}
----

The access to the localized texts should be demonstrated using the first name of the customer. 
All other texts in the page are treated analogously. 
Here is the localized label for the first name:

----
<h:outputLabel for="firstName" value="#{msgs.first_name}:"/>
-----

It references an EL expression in the `value` attribute, which consists of the name of the bundle and the `key` for the first name. 

In some cases it is necessary to access localized resources directly in Java. 
For this purpose, the class `GuiUtil` combines the method for reading a localized text from Listing <<.Internationalized Texts in the Backing Bean, Internationalized Texts in the Backing Bean>> and the method for creating a localized message from Listing <<.Internationalized Messages in the Backing Bean, Internationalized Messages in the Backing Bean>>. 
In MyGourmet comes `GuiUtil` in `CustomerBean` used. 
Listing <<.Use of GuiUtil in MyGourmet, Use of GuiUtil in MyGourmet>> exemplifies two methods from this `Managed-Bean`.

.Internationalized Texts in the Backing Bean
[source,java]
----
 public void validateCreditNumber(FacesContext ctx,
    UIComponent component,
    Object value) throws ValidatorException {
  CreditCardType ccType =
      (CreditCardType)creditCardTypeInput.getValue();
  Boolean useCC = customer.getUseCreditCard();
  if (useCC != null && useCC && ccType != null) {
    String ccNumber = (String)value;
    int length;
    if (ccType == CreditCardType.CARD_A) length = 4;
    else length = 5;
    if (!ccNumber.matches("
d{" + length + "}")) {
      FacesMessage msg = GuiUtil.getFacesMessage(
          ctx, FacesMessage.SEVERITY_ERROR,
          "validateCreditCardNumber.NUMBER", length);
      throw new ValidatorException(msg);
    }
  }
}

private String getCCTypeLabel(CreditCardType type) {
  FacesContext c = FacesContext.getCurrentInstance();
  String key = "credit_card_type_" + type.toString();
  return GuiUtil.getResourceText(c, "msgs", key);
}
----
The method `validateCreditNumber` is already known from MyGourmet 6: In contrast to the previous version, a localized message is created in case of an error. 
The `key` of the text used is `validateCreditCardNumber.NUMBER`. 
A look at Listing excerpt from the German Bundle of MyGourmet shows that this text is a message format template with a placeholder. 
When creating the message, this placeholder will be replaced with the length of the credit card number. 
The `getCCTypeLabel` method returns the localized name for fields of the Enum CreditCardType.
The bean validation resource bundles are filed under the name ValidationMessages - a bundle named ValidationMessages_de for the German language and a bundle named ValidationMessages_en for the English language.