:sectnums:
== The Custom JSF component

JavaServer Faces more than lives up to its reputation as a component framework: components are an essential part of JSF and form a central extension point. 
There is probably no other web framework with so many options for expanding and creating your own components that interact harmoniously with the framework. 
The standard components and various extensions and component libraries from the JSF environment already cover a considerable range of functions. 
However, most developers will sooner or later come across use cases that are not feasible. 
At the latest then a separate component makes sense.

Before version 2.0 of JSF the component development was however relatively expensive. 
It always had to be considered whether this step pays off in the specific case or whether the problem can not be solved otherwise. 
JSF took a big step towards the developers in version 2.0 in this area. 
With the new composite components, there is a really easy way to declare components declaratively-without writing a line of Java code or XML configuration. 
How this works is shown in section [Section: Composite Components].

As important as the composite components are, they can not solve every problem. 
More complex tasks can only be realized with the most flexible classical components. 
But that their creation is not rocket science, we show you in section [Classical Components]. 
With JSF as of version 2.0 and facelets, it has even become a bit easier in comparison.

In Section [Section: Combining composite components and classical components] Let's go one step further and combine composite components with classic components. 
With this approach, composite components can easily be extended with Java code as needed. 
You will see that the two concepts harmonize perfectly with each other, making the development of your own components even more flexible.

In section [Alternatives to Custom Component], we show you how to replace individual parts of an existing component: It does not always have to be a complete component. 
The MyGourmet 13 example summarizes all the changes made throughout the chapter and is covered in section [Section:  MyGourmet 13: Components and Services].

You want to create your own component library with all your components? No problem, section [The Own Component Library] shows how this works. 
In section [Section:  MyGourmet 13 with component library] you will find MyGourmet 13 again - but this time with a component library.

=== Composite components

Composite components were, in our view, one of the most important new features of JSF 2.0. 
By connecting facelets and resources, developers can build components from almost any page fragment - hence the name. 
Basically, a composite component is nothing more than an `XHTML` document stored in a resource library that declares the component.

After a brief introduction to an example in Section [Section: A First Composite Component], we will discuss the sections [Section: `cc:interface`] and [Section: `cc:implementation`] Take a closer look at the declaration of composite components and each tag of the composite tag library. 
Then, section [resources in composite components] shows the combination of composite components and resources. 
In the sections [Section: The component `mc:panelBox`] to [Section: The component `mc:inputSpinner`] you will find some practical examples and section [Section: Pitfalls in practice] finally shows some pitfalls when using composite components.

==== A first composite component

The definition of the `namespace` and the `tag of the component` results by convention from the resource library and the name of the `XHTML document`. 
As a first example we convert the box in the sidebar to a composite component called panelBox. 
As all of the components created in this section end up in the `mygourmet` library, we first create this directory under `/resources`. 
In it we then create the declaration of the component named `panelBox.xhtml`. 
Figure Resource of the composite component `panelBox` shows the directory tree. 
For more detailed information about resources, see Chapter [Chapter: Resource Management],

====
.Resource of the composite component `panelBox`
image::images/panel-box-tree.jpg[]
====

As soon as `panelBox.xhtml` exists in the `mygourmet` library, the component is ready for use. 
As with all components, integration takes place via the `namespace` and the `tag`. 
By convention, the `namespace` of composite components derives from the prefix `http://xmlns.jcp.org/jsf/composite/` followed by the library name - in our case `mygourmet`. 
The `tag` gets its name from the declaration and is `panelBox`. 
Listing <<.Integrating a composite component, Integrating a composite component>> shows how the component is used in a page declaration. 
The chosen prefix `mc` is as always `arbitrary`, but offers itself as an abbreviation of MyGourmet-Components.

.Integrating a composite component
[source,xhtml]
----
<html xmlns:mc="http://xmlns.jcp.org/jsf/composite/mygourmet">
  ...
  <mc:panelBox title="Panel-Header">
    <h:outputText value="Ein Text"/>
  </mc:panelBox>
  ...
</html>
----

Since we can already include the component, it's time to take a look at the declaration. 
Listing <<.Composite component `panelBox`, Composite component `panelBox`>> shows a first version of `panelBox.xhtml`, the content of which is very similar to the previously used template `sideBox.xhtml` (see section [section: Multiple templates per page]).

.Composite component `panelBox`
[source,xhtml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:cc="http://xmlns.jcp.org/jsf/composite"
    xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
<cc:interface>
  <cc:attribute name="title"/>
</cc:interface>
<cc:implementation>
  <div class="side_box">
    <p class="header">#{cc.attrs.title}</p>
    <cc:insertChildren/>
  </div>
</cc:implementation>
</ui:composition>
----
In the `namespace` http://xmlns.jcp.org/jsf/composite, JSF combines all the tags needed to declare a composite component. 
If you take a closer look at Listing Composite component `panelBox`, you will notice that, as with templating, it is an `XHTML` document with the root element `ui:composition`. 
For the declaration of the component, however, only the areas enclosed with `cc:interface` and `cc: implementation` are relevant. 
Facelets ignore the rest.

The scope within `cc:interface` defines the interface of the component to the outside. 
In our box, this area is relatively small and includes only one attribute named `title`. 
The `value` of this attribute is set via the component's tag, as Listing has already shown to include a composite component. 
How this attribute is used within the component, we show the same. 
The `cc:implementation` section is followed by the implementation of the component, which can be composed of any mix of JSF tags, HTML tags, and composite tag library tags. 
Our box consists of a `div` element in which the title is output as the first paragraph. 
Since the `title` is an `attribute` of the component, we somehow need to access its value. 
To do this, JSF 2.0 introduces the implicit object `cc` as a reference to the current composite component. 
The `attribute` is accessed using the `Value-Expression` #{cc.attrs.title}, with the `attrs` property returning a map of all attributes. 
The `cc:insertChildren` tag causes JSF to insert all content specified when the component is used within the tag. 
In the example of Listing <<.Incorporation of a composite component, Incorporation of a composite component>>, this is the `h:outputText` component with the value `Ein text`. 

Remains to be clarified, how JSF deals with composite components in a page declaration. 
Listing <<.sidebar MyGourmet with panel box, sidebar MyGourmet with panel box>> shows how the contents of the sidebar MyGourmet with component PanelBox looks.

.sidebar MyGourmet with panel box
[source,xhtml]
----
<mc:panelBox id="menu" title="#{msgs.menu_title}">
  <h:panelGrid columns="1">
    <h:link outcome="providerList"
        value="#{msgs.menu_provider_list}"/>
    <h:link outcome="showCustomer"
        value="#{msgs.menu_show_customer}"/>
  </h:panelGrid>
</mc:panelBox>
<mc:panelBox id="news" title="#{msgs.news_title}">
  <p>MyGourmet - jetzt mit Facelets und Templating</p>
</mc:panelBox>
----

If facelets meet a composite component when constructing the view in the page declaration, a component of type `UINamingContainer` is created and inserted into the component tree by default (section [Section: Combining Composite Components and Classic Components] shows how you can use your own component at this point). 
This component forms the root node for all other contents of the composite component. 
However, your children are created and added to the content of the composite component itself and the content of the tag in the calling page as the page declaration continues to process. 
This approach is similar to building a view with templates.

What does that mean concretely for our example? 
After creating the `root` node, Facelets continues processing with `panelBox.xhtml`. 
After the `div` element and the `paragraph` have been processed with the `title`, the `cc:insertChildren` tag takes its turn. 
As you can see in Listing <<.sidebar in MyGourmet with `panelBox`, sidebar in MyGourmet with `panelBox`>> both `panelBox` tags have content that will be included in the component tree at this point.

==== The cc:interface area

The `cc:interface` area defines the interface of the component to the outside and includes all features that are relevant for users of the finished component. 
In addition to the definition of `attributes` and `facets`, it is also possible to announce the behavior of individual internal components to the outside world. 

Here is a list of all tags that can be used in the interface of a composite component:

* `cc:attribute` +
This tag defines an `attribute` of the composite component.
* `cc:facet` +
This tag defines a `facet` of the composite component.
* `cc:valueHolder` +
This tag defines a `name` under which an internal component that implements `ValueHolder` is available.
* `cc:editableValueHolder` +
This tag defines a `name` under which an internal component that implements `EditableValueHolder` is available.
* `cc:actionSource` +
This tag defines a `name` under which an internal component that implements `ActionSource2` is available.

After this short overview, some details on the possibilities of the individual tags follow. 
For this purpose, in Listing <<.composite component `simpleInput`, composite component `simpleInput`>> you will find the composite component `simpleInput`, which consists of an input field and a submit button.
 
.composite component `simpleInput`
[source,xhtml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html"
    xmlns:cc="http://xmlns.jcp.org/jsf/composite"
    xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
  <cc:interface>
    <cc:attribute name="inputLabel" required="false"
        default="Input"/>
    <cc:attribute name="submitLabel" default="Submit"/>
    <cc:attribute name="action" required="true"
        targets="submit"/>
    <cc:attribute name="value" required="true"/>
    <cc:editableValueHolder name="input" targets="inputText"/>
    <cc:actionSource name="submit"/>
  </cc:interface>
  <cc:implementation>
    <h:outputLabel for="input" value="#{cc.attrs.inputLabel}"/>
    <h:inputText id="inputText" value="#{cc.attrs.value}"/>
    <h:commandButton id="submit"
        value="#{cc.attrs.submitLabel}"/>
  </cc:implementation>
</ui:composition>
----

===== Attributes

Let's first look at the definition of attributes with the `cc:attribute` tag. 
The `simpleInput` component defines a number of `attributes` of varying severity. 
With `required` you can control whether or not the `attribute` is mandatory when using the component. 
The attributes `inputLabel` and `submitLabel` are both `optional`, as in the one required explicitly set to `false` and the other at all is missing. 
For `optional` `attributes`, a `default` `value` can be defined in the `default` attribute. 

The `type` of an attribute can be specified in the attribute `type` in the form of a fully qualified class name. 
The `default` value for type is `java.lang.Object`. 

Attributes can also include `Method-Expressions` for action methods or `Event-Listeners`. 
All you have to do is specify the signature of the method in the `method-signature` attribute. 
It is important to always use `fully qualified class names` for the `return value` and `parameters`. 
As the example in Listing <<.Method Expressions, Method Expressions>> shows as attributes, the transferred `Method-Expression` is referenced directly via `cc.attrs` analogous to other attributes. 
It does not make sense, type and method-signature used concurrently in `cc:attribute`. 
If that is the case, the value of `method-signature` is simply ignored.

[source,xhtml]
----
<cc:interface>
  <cc:attribute name="submitAction"
      method-signature="java.lang.String action()"/>
</cc:interface>
<cc:implementation>
  <h:commandButton action="#{cc.attrs.submitAction}"/>
</cc:implementation>
----

Attributes with the names `action`, `actionListener`, `validator` and, which are already known from previous chapters, occupy a special position here. 
In such attributes, JSF automatically associates `Method-Expressions` with components in the `cc:implementation` area whose `IDs` are specified in the `target` attribute. 
The `value` of targets need not be limited to an `ID`, but may also include a `list of IDs separated by spaces`. 
The `method-signature` attribute can be left `blank` in these cases because the method signatures are already specified by JSF.

In the example from Listing <<.composite component `simpleInput`,composite component `simpleInput`>> is the attribute named `action`, bound by the value in targets to the component with the ID submit . 
The `action` `attribute` in tag `h:commandButton` must not be explicitly set in this case. 
The advantage of this variant is that users of the component can specify both a `String` and a `Method-Expression` in the `action` attribute - just as it does, for example, with `h:commandButton`. 

So far so good. 
The approach with the attribute `targets` has in JSF 2.0, however, a crucial disadvantage. 
The special handling of the above-mentioned attributes `action`, `actionListener`, `validator` and `valueChangeListener` only works if the attribute of the composite component has exactly one of these names. 
For this reason, with JSF 2.0, for example, it is not possible to define more than one real `action` attribute. 
Section [pitfalls in practice] shows how this problem can be bypassed with JSF 2.0 and resolved as of JSF 2.1.

At this point, let's remind you that facelets will drop all the attributes in the composite component that the user of the tag specifies - even if they are not defined with `cc:attribute`. 
We advise you to define all attributes. 
This gives users of the composite component a clear contract about the interface and the behavior in their hands.

===== Facets

With `cc:facet` a named Facet can be defined for a composite component. 
The name of the facet is specified in the `name` attribute. 
If the `required` attribute is explicitly set to `true`, the user must add the facet to the component. 
The example in Listing <<.composite component `simpleInput`, composite component `simpleInput`>> in deployment shows the `cc:interface` area of a composite component with two facet definitions. 
Section [Section: The `cc:implementation`] shows details about facets in composite components.

----
<cc:interface>
  <cc:facet name="header" required="true"/>
  <cc:facet name="footer"/>
</cc:interface>
----

===== Behavioral Definitions

Internal components in the `cc:implementation` area that implement a special behavioral interface (see section Section: Behavioral Interfaces for details) can be announced to the outside with the tags `cc:actionSource`, `cc:editableValueHolder` and `cc:valueHolder`. 
This gives users of the composite component the ability to `bind objects` such as `eventListeners`, `converters`, or `validators` to this component. 
The example from Listing <<.composite component `simpleInput`, composite component `simpleInput`>> defines an action source named `submit` and an editable value holder named `input`.

The `Editable-Value-Holder` with the name `input` is bound to the `input` field with the `ID` `inputText` via the value of the `target` attribute - here, a `list of IDs separated by blanks` is also possible. 
If the `name` and `ID` of the connected component are not different, the targets attribute may also be omitted. 
The action source named `submit` has exactly this: The button with the `ID` `submit` is bound to the `action source`. 
It remains to be clarified how users of composite components can attach `event listeners`, `converters` or `validators` to the composite component. 

In JSF 2.0 have for this purpose `f:actionListener`, `f:valueChangeListener` and all converter and validator tags in the core tag library get the attribute `for`. 
It can specify the name of an `Action-Listener`, `Value-Holders`, or `Editable-Value-Holders`. 
Listing <<.composite component `simpleInput`, composite component `simpleInput`>> in deployment shows an example of using the `simpleInput` component with an `Action-Listener`, a `Validator`, and a `Value-Change-Listener`.

.composite component `simpleInput`
[source,xhtml]
----
<mc:simpleInput action="#{customerBean.save}"
    value="#{customerBean.longValue}" submitLabel="Save">
  <f:actionListener for="submit"
      binding="#{customerBean.saveListener}"/>
  <f:validateLongRange for="input" minimum="10"/>
  <f:valueChangeListener for="input"
      binding="#{customerBean.valueChangeListener}"/>
</mc:simpleInput>
----

If a user activates the button in the browser, the validator is called first in the process validation phase. 
If the value is valid and has changed, then the value change listener comes into play. 
In the `Invoke-Application-Phase`, the listener is first executed with for = "submit" and then the action method specified in `action`.

==== The `cc:implementation` area

The `cc:implementation` area contains all the JSF tags, HTML elements, and other content that makes up the composite component. 
In the implementation part, there are several ways to insert contents that a user of the composite component specified within the component tags. 
The tags of the composite tag library are relevant for this:

* `cc:insertChildren` +
This tag causes JSF to take the content of the tag from the user's page declaration when constructing the component tree.
* `cc: renderFacet` +
This tag causes JSF to insert the content of the facet called `name` into the component tree. 
The facet must be a child of the composite component.
* `cc: insertFacet` +
This tag causes JSF to add the contents of the facet named `name` as facet to another component. 
The facet must be a child of the composite component.

In the implementation part, the implicit object `cc`, with which the current composite component can be referenced in `EL` expressions, plays an important role. 
The most important properties of this object are `cc.attrs` to access the composite component `attributes` and `cc.facets` to access `facets`. 
Since both `properties` are of type `Map`, individual items can be accessed directly using dot notation. 
The implicit object `cc` references the root component of the composite component and therefore has the type `UIComponent`. 
This of course makes it possible to use other properties of the component, such as `cc.clientId`.

We will not go into the practical aspect of the implementation part here. 
But that does not mean that we neglect it. 
For more examples, we would like to refer you to the next few sections where we will present some composite components.

==== Resources in composite components

Before we jump to the concrete examples in the next section, let's take a look at the use of JSF resources in composite components. 
After we're already in a library with the component, it's easy to put additional `pictures`, `stylesheets`, or `scripts` in there.

The resources are integrated into the component with the tags `h:graphicImage`, `h:outputScript` and `h:outputStylesheet`, as described in section [Section: Resources in use]. 
The advantage of this solution is that users of the component do not have to worry about it. 
If you have `h:head` and `h:body` use, the referenced resources are automatically included in the view. 
Listing <<.resources in a composite component, resources in a composite component>> shows an example using the `script.js` script and `style.css` style sheet, both of which are in addition to the composite component in the `mygourmet` library.

.resources in a composite component
[source,xhtml]
----
<cc:implementation>
  <h:outputScript library="mygourmet"
      name="script.js" target="head"/>
  <h:outputStylesheet name="style.css" library="mygourmet"/>
</cc:implementation>
----

As of JSF 2.1, there is the option to refer to the library of the current composite component with the `name` `this`. 
However, this only works if the resource is referenced via an `EL` expression in the attribute value (see section [Section: Resources in use]). 
This avoids having to specify the `name` of the library directly, and the component also works well with a changed `library name`. 
Listing <<Library name `this`, Library name `this`>> shows the example of listing resources in a composite component with the library `this`.

.Library name `this`
[source,xml]
----
<cc:implementation>
  <h:outputScript target="head" 
      value="#{resource['this:script.js']}"/>
  <h:outputStylesheet value="#{resource['this:style.css']}"/>
</cc:implementation>
----

Referencing resources with the library name `this` works only within composite components.

==== The component `mc:panelBox`

At the beginning of this section, we have already shown a simple version of the `panelBox` composite component, which we will extend by a few more aspects. 
Listing <<.final version of the composite component `panelBox`, final version of the composite component `panelBox`>> shows the complete component.

.final version of the composite component `panelBox`
[source,xml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
        xmlns:h="http://xmlns.jcp.org/jsf/html"
        xmlns:cc="http://xmlns.jcp.org/jsf/composite"
        xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
        xmlns:c="http://xmlns.jcp.org/jsp/jstl/core">
<cc:interface>
  <cc:attribute name="styleClass" default="box"/>
  <cc:attribute name="style" required="false"/>
  <cc:attribute name="headerClass" default="box-header"/>
  <cc:facet name="header" required="false"/>
</cc:interface>
<cc:implementation>
  <h:outputStylesheet library="mygourmet"
       name="components.css"/>
  <div class="#{cc.attrs.styleClass}"
      style="#{cc.attrs.style}">
    <c:if test="#{!empty cc.facets.header}">
      <p class="#{cc.attrs.headerClass}">
        <cc:renderFacet name="header"/>
      </p>
    </c:if>
  <cc:insertChildren/>
</div>
</cc:implementation>
</ui:composition>
----

In the simple variant of the component, the header was implemented as an attribute. 
For flexibility, the header is now a facet of the component. 
This also makes it possible to load more complex content into the header. 
The facet is defined in the interface area of ​​the component with the tag `cc:facet`. 
The rendered output should display the contents of the facet in a paragraph, but only if the user specified the facet. 
Let's take a look at this problem step by step. 
Inserting the `facet` is done with `cc:renderFacet` and will not cause any problems if the user has not specified anything. 
The problem is only the enclosing `p` element, which of course should not appear in the output if there is no facet. 
The solution is simple. 
With a `c:if` tag, the expression #{!Empty cc.facets.header} checks if the facet header has been specified. 
If this is not the case, the block is not inserted into the component tree within `c:if`.

The second interesting aspect of this composite component is styling with `CSS`. 
All components in the library `mygourmet` should receive a uniform styling, which, however, can be changed by. 
In the component we define a dependency on the stylesheet `components.css` with the tag `h:outputStylesheet`, for styling, the attributes `styleClass` and `headerClass` with default values ​​are used. 
This ensures that the internal CSS classes can be overwritten as needed.

The declaration of the two `panelBox` components in the sidebar of MyGourmet 13 can be seen in the Listing <<.composite component `panelBox`, composite component `panelBox`>>. 
Figure <<.Rendered output of panelBox in MyGourmet 13, Rendered output of panelBox in MyGourmet 13>> displays the rendered output with default styling.


.composite component `panelBox`
[source,xml]
----
<mc:panelBox id="menu">
  <f:facet name="header">
    <h:outputText value="#{msgs.menu_title}"/>
  </f:facet>
  <h:panelGrid columns="1">
    <h:link outcome="providerList"
        value="#{msgs.menu_provider_list}"/>
    <h:link outcome="showCustomer"
        value="#{msgs.menu_show_customer}"/>
  </h:panelGrid>
</mc:panelBox>
<mc:panelBox id="news">
  <f:facet name="header">
    <h:outputText value="#{msgs.news_title}"/>
  </f:facet>
  <p>MyGourmet - jetzt mit Facelets und Templating</p>
</mc:panelBox>
----

====
.Rendered output of panelBox in MyGourmet 13
image::images/mygourmet13-panelbox.jpg[]
====

==== The component `mc:dataTable`

The component `mc:dataTable` shows how composite components can facilitate the daily work with JSF. 
`mc:dataTable` does not provide any new functionality, but rather a kind of wrapper for `h:dataTable`. 
This makes it possible to extend the standard component with a default style. 
Listing <<.composite component `dataTable`, composite component `dataTable`>> shows the declaration of the component.

.composite component `dataTable`
[source,xml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html"
    xmlns:cc="http://xmlns.jcp.org/jsf/composite"
    xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
    xmlns:c="http://xmlns.jcp.org/jsp/jstl/core">
<cc:interface>
  <cc:attribute name="var"/>
  <cc:attribute name="value"/>
  <cc:facet name="header"/>
  <cc:facet name="footer"/>
</cc:interface>
<cc:implementation>
  <h:outputStylesheet library="mygourmet" 
      name="components.css"/>
  <h:dataTable id="table" value="#{cc.attrs.value}"
      styleClass="mygourmet-table" headerClass=
      "mygourmet-table-header" rowClasses=
      "mygourmet-table-rownobg, mygourmet-table-rowbg"
      columnClasses="mygourmet-table-cell">
    <c:set target="#{component}" property="var"
        value="#{cc.attrs.var}"/>
    <cc:insertFacet name="header"/>
    <cc:insertChildren/>
    <cc:insertFacet name="footer"/>
  </h:dataTable>
</cc:implementation>
</ui:composition>
----

So that the table also displays data, we need the `var` and `value` attributes in the interface of the composite component, which are then passed on to `h:dataTable` in the implementation part. 
Here, however, there is a problem. 
The `var` attribute of `h:dataTable` must not be set using a `Value-Expression`. 
That's why we have to do a little trick here. 
Facelets provides a tag to set bean properties using the JSTL `c:set` function. 
As of JSF 2.0, the current component is available directly with the implicit object component. 
With `c:set` as a direct child of `h:dataTable` it is thus possible to set the attribute `var`.

The CSS classes are set directly in `mc:dataTable`, but, as with the `panelBox` component, they could also be implemented with attributes that have default values. 
The stylesheet `components.css` is included as a resource just like before.

The implementation part clearly shows the difference between `cc:renderFacet` and `cc:insertFacet`. 
In the current example, `cc:insertFacet` is used to place the facets header and footer on `h:dataTable` pass on. 
They should not be rendered by the composite component, but by `h:dataTable`. 
Finally, the composite: `insertChildren` tag remains, with which the child elements of the tag in the calling declaration are sent to `h:dataTable`. 
`mc:dataTable` is thus used like `h:dataTable`, where content is declared using `h:column` tags.

Figure <<.Rendered output of dataTable, Rendered output of dataTable>> shows the rendered output of `mc:dataTable` from the view `providerList.xhtml`.

====
.Rendered output of dataTable
image::images/mygourmet13-datatable.jpg[]
====

==== The component `mc:collapsiblePanel`

The composite component `mc:collapsiblePanel` renders an area of ​​the page that can be toggled `on` and `off` using a button. 
This button is rendered as an icon, which changes depending on the state of the panel being folded. 
The content of the optional facet header is displayed next to the icon. 
Listing <<.composite component collapsiblePanel, composite component collapsiblePanel>> shows the declaration of the component.

.composite component collapsiblePanel
[source,xhtml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html"
    xmlns:cc="http://xmlns.jcp.org/jsf/composite"
    xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
<cc:interface>
  <cc:attribute name="model" required="true">
    <cc:attribute name="collapsed" required="true"/>
    <cc:attribute name="toggle" required="true"
        method-signature="java.lang.String f()"/>
  </cc:attribute>
  <cc:actionSource name="toggle"/>
  <cc:facet name="header"/>
</cc:interface>
<cc:implementation>
  <h:panelGroup layout="block"
      styleClass="collapsiblePanel-header">
    <h:commandButton id="toggle"
        action="#{cc.attrs.model.toggle}"
        styleClass="collapsiblePanel-img"
        image="#{resource[cc.attrs.model.collapsed
          ? 'mygourmet:toggle-plus.png'
          : 'mygourmet:toggle-minus.png']}"/>
    <cc:renderFacet name="header"/>
  </h:panelGroup>
  <h:panelGroup layout="block"
      rendered="#{!cc.attrs.model.collapsed}">
    <cc:insertChildren/>
  </h:panelGroup>
</cc:implementation>
</ui:composition>
----

The contents of the component are collapsed and expanded using the collapsed `attribute`, which control the collapse `state`, and `toggle`, which takes the collapse state action method. 
The two attributes are embedded in the model attribute, which requires users to submit only one bean to the component, which has the collapsed property and a method with the signature defined in toggle. 

The contents of the panel are embedded in a `h:panelGroup` component, with the rendered `attribute` being used to fade in and out. 
The `value` of this attribute is added with the expression #{!cc.attrs.model.collapsed} depends on the passed state. 
Please also note the access to the nested attribute of the composite component.

The switchover state button is rendered as images. 
Like the stylesheet from the last examples, the two images are also directly in the resource library. 
They are included in the image attribute of the `h:commandButton` tag via the implicit `resource` object. 
The button itself is available under the name `toggle` as action source to the outside.

Listing <<.composite component collapsiblePanel, composite component collapsiblePanel>> in use shows a deployment scenario of the component and in Figure <<.Rendered Output of collapsiblePanel, Rendered Output of collapsiblePanel>> you will find the rendered output of both collapsible states.

.composite component collapsiblePanel
[source,xhtml]
----
<mc:collapsiblePanel model="#{customerBean}">
  <f:facet name="header"><h3>Information</h3></f:facet>
  Diese Information ist klappbar.<br/>
  Diese Information ist klappbar.
</mc:collapsiblePanel>
----

====
.Rendered Output of collapsiblePanel
image::images/mygourmet13-collpanel.jpg[]
====

The composite component shown here collapsiblePanel works so well, but still has a crucial flaw. 
The logic for showing and hiding child components must be provided by the user of the component via the model attribute. 
This does not match our original definition of components as stand-alone and reusable building blocks. 
For this reason, in Section [Section: Combining Composite Components and Classic Components], we will extend the functionality of this component. 
For this we will show you the creation of classical components in section [Classical Components].

==== The component `mc:inputSpinner`

The composite component `mc:inputSpinner` renders an input component with two buttons, which increase or reduce the numeric value of the input field via JavaScript. 
The interface of the component to the outside is very clear. 
It includes the attributes `value` for the input component and `inc`, which defines the amount to be added or subtracted. 
In addition, the input component is available under the name `input`. 
Listing <<composite component `inputSpinner`, composite component `inputSpinner`>> displays the declaration.

.composite component `inputSpinner`
[source,xml]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
  xmlns:h="http://xmlns.jcp.org/jsf/html"
  xmlns:cc="http://xmlns.jcp.org/jsf/composite"
  xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
<cc:interface>
  <cc:attribute name="value" required="true"
      type="java.lang.Integer"/>
  <cc:attribute name="inc" default="1"/>
  <cc:editableValueHolder name="input"/>
</cc:interface>
<cc:implementation>
  <h:outputStylesheet library="mygourmet"
      name="components.css"/>
  <h:outputScript library="mygourmet"
      name="inputSpinner.js" target="head"/>
  <h:panelGroup>
    <h:inputText id="input" value="#{cc.attrs.value}"
        styleClass="inputSpinner-input"/>
    <h:panelGroup id="buttons"
        styleClass="inputSpinner-buttons">
      <h:graphicImage styleClass="inputSpinner-button"
          name="spin-up.png" library="mygourmet"
          onclick="return changeNumber(
          '#{cc.clientId}:input', #{cc.attrs.inc});"/>
      <h:graphicImage styleClass="inputSpinner-button"
          name="spin-down.png" library="mygourmet"
          onclick="return changeNumber(
          '#{cc.clientId}:input', #{-cc.attrs.inc});"/>
    </h:panelGroup>
  </h:panelGroup>
</cc:implementation>
</ui:composition>
----

The implementation part includes incorporating the required resources, the input component, and an `h:panelGroup` with two images that use JavaScript as a `Value-Changing` button. 
Thus, the component loads a total of four resources: First, the already known style sheet `components.css`, then the script `inputSpinner.js` to change the value and the two images `spin-up.png` and `spin-down.png`. 
Increasing and reducing the value of the input component occurs in the `changeNumber function` which receives as parameters the `clientID` of the input component and the `value` for adding. 
Passing the `clientID` makes it easy to use multiple input spinner components in one view. 
Listing <<.JavaScript for inputSpinner, JavaScript for inputSpinner>> shows the JavaScript function from resource `inputSpinner.js`.

.JavaScript for inputSpinner
[source,js]
----
function changeNumber(clientId, increment) {
  var inc = Number(increment);
  if (isNaN(inc) || inc == 0 ) inc = 1;
  var input = document.getElementById(clientId);
  var val = Number(input.value);
  if (isNaN(val)) val = 0;
  input.value = val + inc;
  return false;
}
----

The function is executed via the `onclick` attribute of the two images. 
It is interesting to calculate the `clientID` of the input component. 
Since the composite component itself is a naming container, its `ID` must also be taken into account. 
We get this with the expression `cc.clientId` and by appending : input results the clientID of the input component.

The component is used like any other input component. 
In <<.Rendered Output from inputSpinner, Rendered Output from inputSpinner>>, you can see the rendered output.
====
.Rendered Output from inputSpinner
image::images/mygourmet13-inputspinner.jpg[]
====

==== Pitfalls in practice

This section shows a number of pitfalls that need to be considered when using composite components.

===== Composite components in the component tree

When using composite components, a root component is always inserted in the component tree as described in section [Section: A First Composite Component]. 
In most cases, this behavior is also desirable, for example, to avoid duplicate `IDs` when using the component more than once. 
In a few special cases, however, this root component may have unexpected side effects. 

In the following example, let's consider the composite component `inputField`, which combines an `h:inputText` component with an associated `h:outputLabel` component:

----
<cc:interface>
  <cc:attribute name="value"/>
</cc:interface>
<cc:implementation>
  <h:outputLabel for="input" value="Input:"/>
  <h:inputText id="input" value="#{cc.attrs.value}"/>
</cc:implementation>
----

The following example arranges two of the inputField components shown above in a `h:panelGrid` component:
----
<h:panelGrid columns="2">
  <mc:inputField value="#{testBean.value1}"/>
  <mc:inputField value="#{testBean.value2}"/>
</h:panelGrid>
----

The expected output at this point would be to render a table with two rows containing the labels in the first column and the input fields in the second column. 
However, the actual result is different: JSF renders a table with only one line. 
This behavior is also correct from the perspective of JSF. 
The panel grid "sees" only the root component of the composite component and represents the complete content in a cell.

Currently (including JSF 2.2) there is unfortunately no way around this behavior.

===== Using Multiple Action Attributes

In Section [Section: The cc: interface], we showed how the `action`, `actionListener`, `validator`, and `valueChangeListener` attributes can be linked to internal components using the `target` attribute. 
However, the special handling of these attributes only works if the composite component attribute has exactly one of these names. 
However, since the name of the attribute must be unique, JSF 2.0 will not allow you to define more than one "real" action attribute. 

But at the latest when we want to add a second button to a composite component, we need a second one action attribute. 
As an emergency solution in JSF 2.0 in this case, an attribute with a corresponding method signature can be used as shown in Listing <<.Several Action Attributes with JSF 2.0, Several Action Attributes with JSF 2.0>>.

.Several Action Attributes with JSF 2.0
[source,xhtml]
----
<cc:interface>
  <cc:attribute name="action" targets="submit"/>
  <cc:attribute name="cancelAction"
      method-signature="java.lang.String action()"/>
</cc:interface>
<cc:implementation>
  <h:commandButton id="submit"/>
  <h:commandButton id="cancel"
      action="#{cc.attrs.cancelAction}"/>
</cc:implementation>
----
 
As of JSF 2.1, there is a more elegant solution to this problem. 
With the already known attribute `target` and the new attribute `targetAttributeName`, `cc:attribute` can be linked to a specific attribute of an internal component. 
Illustration <<.Several action attributes with JSF 2.1, Several action attributes with JSF 2.1>> shows this approach for the example above.

.Several action attributes with JSF 2.1
[source,xhtml]
----
<cc:interface>
  <cc:attribute name="submitAction" targets="save"
      targetAttributeName="action"/>
  <cc:attribute name="cancelAction" targets="cancel"
      targetAttributeName="action"/>
</cc:interface>
<cc:implementation>
  <h:commandButton id="submit"/>
  <h:commandButton id="cancel"/>
</cc:implementation>
----
The value of the `submitAction` attribute in this example is linked to the `action` attribute of the internal component with the `ID` `submit`. 
Similarly, the value of the `cancelAction` attribute is passed to the `action` attribute of the internal component with the `ID` `cancel`. 
So `targetAttributeName` always contains the name of the "target attribute" if it differs from name to name.

===== Resolution of the type of attributes

JSF 2.0 and 2.1 can cause problems with composite component attributes when passing `null` as an attribute value when using the component. 
In this case, JSF can not resolve the type of value passed, resulting in improper behavior in certain situations.

This misconduct can be demonstrated very simply by means of an example. 
The composite component `inputTest` has an attribute named `value`, which is used in the implementation part in an input component:
[source,xhtml]
----
<cc:interface>
  <cc:attribute name="value"/>
</cc:interface>
<cc:implementation>
  <h:inputText id="input" value="#{cc.attrs.value}"/>
</cc:implementation>
----

The error occurs when the component uses a value expression that evaluates to `null` (assuming the longValue property is `java.lang.Long` and not `long`):
----
<mc:inputTest value="#{testController.longValue}"/>
----
In version 2.0 and 2.1, JSF can not resolve the type in this case. 
Therefore, no corresponding converter is set in the input component - which would otherwise be done automatically based on the type java.lang.Long. 
The missing converter can lead to unexpected behavior in the life cycle. 
For example, an invalid user input throws a `ClassCastException` instead of displaying an error message. 

With JSF 2.2, this problem no longer occurs because the algorithm for resolving the type of attributes has changed (in Apache MyFaces this algorithm is already used from versions 2.0.10 and 2.1.4). 
For earlier JSF versions, you can prevent this problem by explicitly using a converter in `h:inputText` (if the type is unique) or by omitting the null value for these attributes.

=== Classic components

After introducing composite components, this section will show you how to use JSF to create a classic component for use with facelets. 
At first glance, this process may seem a bit complicated, as it involves a series of steps, especially because of the many web technologies that are used. 

Creating a component consists of the following steps:
* Define component family, component type and renderer type
* Write component class
* Write renderer class
* Register component class and renderer class
* Write tag definition and record in library
* Write tag handler class
* Include library in the page

Each and every one of these points will now be reviewed with a small example. 
For demonstration purposes, we rebuild the composite component `inputSpinner` as a classic JSF component.

==== Preliminary work: Defining the component family, component type and renderer type

Before we begin writing the component, we should be clear about whether and how the component is derivable from another component or whether we need to start completely "off the green". 
Usually it makes sense to derive from an existing base component.

===== The choice of the base class

Candidates for the base class are UIComponent- derived classes, that is, the following component classes by default:
* `UIOutput` : +
Component that represents a value (and does not allow input).
* `UIInput` : +
Component that allows you to enter a value.
* `UISelectOne` : +
Component that allows you to select exactly one value from a set of values.
* `UISelectMany` : +
Component that allows you to select multiple values ​​from a set of values.
* `UICommand` : +
Component that performs an action.
* `UIPanel` : +
Component that serves as a container for one or more other components.
* `UIMessage` : +
Component used to display a message.

Often, derives from one of the three components `UICommand`, `UIInput`, or `UIPanel` because these three classes already provide a great deal of logic for working with frequently recurring tasks. 

When does it make sense to derive UIInput? This is appropriate if the component is to present exactly one value from the model. 
Things like conversion, validation, writing and reading the value from and into the model are already done by this class. 
If the behavior of the component is even more special, you can possibly use the class `HtmlInputTextderive` - this class and the associated renderer also do the decoding of the value from the HTTP request, setting the value as a submitted value and writing the component view in the HTTP response.

The `UIInput` class is also useful if you want to store a user-initiated change to a component attribute. 
Thus, for example, a `collapsible` panel component can be realized, which stores its collapsed state in the attribute value. 
This can also bind the state to a bean property.

The `UICommandClass` will be used as a basis for your own component when it triggers "actions". 
Handling action methods, action listeners, and triggering events are already handled by this base class.

The choice of the base class for the input spinner is clear. 
After it is a "tuned" input field, UIInput urges itself .

===== Component Type, Component Family, and Renderer Type

Each component is uniquely identified in the system by its component type. 
There may not be another component with the same component type. 
Usually, the component type is defined as a static constant. 
Our input spinner component, whose component class `InputSpinner` we will create in the next section, has the following component type:

----
public static final String COMPONENT_TYPE =
    "at.irian.InputSpinner";
----

When registering the component in the system, its component type is used as the identifier. 
This is then used, for example, in the definition of the tag of the component in the tag library.

In addition, we can pass the component type, if we want to create a component, instead of calling the constructor directly instead of calling the factory method `createComponent()` of the application class. 
In fact, one should always go this way so that the implementation of a component can be exchanged centrally. 
Here's the example:
----
FacesContext.getCurrentInstance().getApplication()
    .createComponent(InputSpinner.COMPONENT_TYPE);
----

The next step is the definition of the component family - here either an existing family can be used or a new family can be defined. 
The family of a component is determined by calling `UIComponent.getFamily()`. 
If you want to create your own family for your component, you must override this method. 
One component family may contain multiple components. 
Our example component is an input field, we leave it with the `javax.faces.Input` family inherited from `UIInput`.

The component family is used in conjunction with the renderer type to select a renderer. 
If the component type were used here, a renderer could always render only one type of component - the definition of the component family means that the same renderer can be used for a whole group of components. 
When the tag is defined, the renderer type is specified together with the component type and set when the component is created - this overwrites the "default" renderer type often set in the component constructor. 

Below is the component type, component family, and renderer type for selected standard components:

* `javax.faces.component.html.HtmlCommandLink`: +
The component behind the tag `h:commandLink`. +
Component Type: `javax.faces.HtmlCommandLink` +
Component Family: `javax.faces.Command` +
Renderer Type: `javax.faces.Link`

* `javax.faces.component.html.HtmlCommandButton`: +
The component behind the `h:commandButton` tag. +
Component Type: `javax.faces.HtmlCommandButton` +
Component Family: `javax.faces.Command` +
Renderer Type: `javax.faces.Button`

* `javax.faces.component.html.HtmlInputText`: +
The component behind the tag `h:inputText`. +
Component Type: `javax.faces.HtmlInputText` +
Component Family: `javax.faces.Input` +
Renderer Type: `javax.faces.Text`

Our input spinner component gets its own renderer type `at.irian.InputSpinner`.

==== Write component class

The component class is the "heart" of the component architecture of JSF - the component class instance is stored in the JSF component tree and contains all the data of a component. 
The component class is actually the "driving force" in the execution of a JSF request. 
At each stage of the lifecycle, the component tree is traversed by recursive invocations of the appropriate treatment methods: one can control all events in JSF from here.

Two of the most important tasks are the reading out of the request parameters relevant for the component (decoding) and the rendering of the component (encoding). 
The component can - if so provided by the developer - take over these tasks or delegate them to a renderer. 
The biggest advantage of having your own renderer is the clear separation between the data contained in the component and the resulting output. 
The two approaches are not mutually exclusive. 
For example, it would be conceivable to have the rendering done by the component in a first version and later to create your own renderer.

We will take care of the component class in this section and only in section [Section: Write Renderer Class] take a closer look at the renderer class.

===== Component Attributes

A component class usually contains a property for each attribute of its tag. 
However, there may also attributes of the tag that do not explicitly exist in the component - these are then stored in a special map in the component.

The access methods to the properties of the component must ensure that the properties can be specified both directly and via value expressions.
It is true that the direct setting of attributes "pulls" more than setting a value expression. 
Of course, when reading the component attribute, it must be taken into account whether it was set directly. 
If so, the component value is returned directly, otherwise the value expression is evaluated. 
Sounds complicated - but with JSF 2.

As of JSF 2.0, component properties are no longer managed in private fields but in a map as the basis for the new partial state saving. 
For this purpose, each component has an instance of the `StateHelper` class that manages the state internally. 
What's up with the condition, we clarify a little further down, now we are interested in reading and writing the properties.

Listing <<.The InputSpinner class, The InputSpinner class>> shows the `InputSpinner` class of our example component. 
As you can see, the code is very manageable and basically just covers the definition of the `inc` property, the rest, such as state-saving or managing the other attributes, are handled by the base classes of JSF. 
After we have derived from `UIInput`, we can also use its already existing features.

.The InputSpinner class
[source,java]
----
public class InputSpinner extends UIInput {

  public static final String COMPONENT_TYPE =
      "at.irian.InputSpinner";

  enum PropertyKeys {inc}

  public InputSpinner() {
    setRendererType("at.irian.InputSpinner");
  }
  public int getInc() {
    return (Integer)getStateHelper().eval(
        PropertyKeys.inc, 1);
  }
  public void setInc(int inc) {
    getStateHelper().put(PropertyKeys.inc, inc);
  }
}
----

With the method `put()` the value of the property is set directly with the key `PropertyKeys.inc`. 
The `eval()` method, if present, returns the directly set value. 
If one does not exist, then a possibly existing value expression is evaluated. 
In our case, if one does not exist, the default value 1 is returned.

===== State-saving

In addition to the access methods to the properties of the component, the component class still has a very important task: it must be able to save its state until the next request. 
State-saving is relatively simple in earlier versions of JSF and follows the approach of always saving and restoring the complete state of the entire component tree. 
Since this approach is not optimal in terms of performance and memory consumption, JSF 2.0 has implemented a new approach with partial state saving.

As the name already suggests, only really relevant parts of the state are stored. 
After setting up the component tree, JSF marks an initial state, which is defined anyway by the page declaration. 
The partial state then consists of all changes to the component tree after reaching this state. 
The prerequisite for the correct initialization is the structure of the view from the page declaration before each state is restored. 

For state-saving, the `saveState()` and `restoreState()` methods are from the `StateHolder` interface responsible. 
Before JSF 2.0, these two methods had to be painstakingly crafted for each component class - an error-prone process that we can not cry for. 
As of JSF 2.0, these methods are already implemented in `UIComponentBase` and need only be overridden for special requirements.

How does this work? The basis for recording the state is formed by the `StateHelper` presented in the last section, which manages the state of the component internally. 
This has already laid the foundation for partial state saving. 
The "centralized" state management makes it possible to record changes after reaching the initial state.

Any component that wants to use partial state saving must implement the `StateHolder`- derived interface, which is extended by Initial State Markers, to the PartialStateHolder interface. 
Since these methods are already implemented in the class `UIComponentBase` and extended in some other base classes, you do not have to worry about it either.

===== Composition of classical components

An interesting aspect of component development is the composition of components into a larger whole: to this end, find the appropriate place to add child components to the parent component. 
In essence, there are two possibilities here: The simpler option is to add transient child components when rendering the page. 
Transient means that the attribute `transient` of the component has been set to `true`, and the component therefore disappears in the state-saving process. 
Although this type of composition works, it is not optimal in all cases because some kind of component functionality is outsourced to the renderer.

With JSF 2.0 or later, it is possible to add child components to a composite component using the `PostAddToViewEvent` system event. 
This event is fired after a component has been inserted into the component tree. 
We'll create a listener for this event by adding the extra components.

Listing <<.composition of classic components with system events, composition of classic components with system events>> shows a section of a component class that is registered as a listener for the system event `PostAddToViewEvent` via the `@ListenerFor` annotation. 
If the event occurs when the component is inserted into the view, calls the `processEvent` method defined in the `ComponentSystemEventListener` interface. 
Since this interface is already implemented by the `UIComponent` class, we only need to override and extend the corresponding method.

.composition of classic components with system events
[source,java]
----
@FacesComponent("at.irian.MyPanel")
@ListenerFor(systemEventClass = PostAddToViewEvent.class)
public class MyPanel extends HtmlPanelGroup {

  public void processEvent(ComponentSystemEvent ev)
  throws AbortProcessingException {
    if (ev instanceof PostAddToViewEvent) {
      addComponents();
    }
    super.processEvent(ev);
  }
  ...
}
----
==== Write renderer class

The term renderer in JSF stands for a class that maps to a component (or component family) and creates the view for that component, but also retrieves the value of a component from the HTTP request and transmits it to the component instance. 
Each renderer class must be derived from the abstract class `javax.faces.render.Renderer` and override the methods that should not have the default functionality.

The renderer is ultimately the class whose writing means the most work, because it has to program the entire view logic - with the variety of technologies used in web application development, such as HTML, JavaScript, CSS, and XML, this view logic is very complex for larger components. 
This is also the reason for specifying the JSF standard - the "normal" web developer no longer has to worry about developing this view logic.

The following list shows the methods of the class `Renderer`:

* `void decode (FacesContext ctx, UIComponent comp)` +
Reads the value of the component from the request parameters.

* `void encodeBegin (FacesContext ctx, UIComponent comp)` +
Called first when rendering the component.

* `void encodeChildren (FacesContext ctx, UIComponent comp)` +
Called after `encodeBegin()` when rendering the component, if `getRendersChildren()` returns `true`.

* `void encodeEnd (FacesContext ctx, UIComponent comp)` +
Called last when rendering the component.

* `boolean getRendersChildren ()` +
Returns `true` if the renderer renders all child components themselves. The default value is `false`.

* `Object getConvertedValue (FacesContext ctx, UIComponent comp, Object submittedValue)` +
Converts the submitted value of a string to the value required for the component.

* `String convertClientId (FacesContext ctx, String clientId)` +
Converts the `clientID` into a form valid for the client.

Some of these methods need to be overridden by (almost) any custom component developer. 
Depending on the type of component, this is either `encodeBegin()` or `encodeEnd()`. 
These methods are called when the associated tag is opened or closed in the page declaration. 
This is where the HTML code associated with the component should be written - if it is at all a renderer for HTML. 
In principle, of course, renderers for other output formats such as WML, XML, XUL or SVG are conceivable.

The renderer for our input spinner component is implemented in the `InputSpinnerRenderer` class.

===== Rendering (Encoding)

Listing <<.The `encodeBegin()` method of the sample renderer, The `encodeBegin()` method of the sample renderer>> shows the `encodeBegin()` method of the `InputSpinnerRenderer` renderer class. 
The parameters are passed to method the Faces-Context and the component for which rendering is to take place. 
The view is written in the two private methods `encodeInput()` to render the input field and `encodeButtons()` to render the two spin buttons. 
At the moment we are only interested in `encodeInput()`, because there the input element is written via calls of the class `ResponseWriter` - which in turn is obtained from the current `Faces-Context` calling the `getResponseWriter()` method.

.The `encodeBegin()` method of the sample renderer
[source,java]
----
public void encodeBegin(FacesContext ctx,
    UIComponent component) throws IOException {
  InputSpinner spinner = (InputSpinner)component;
  String clientId = spinner.getClientId();
  encodeInput(ctx, spinner, clientId);
  encodeButtons(ctx, spinner, clientId);
}
private void encodeInput(FacesContext ctx,
    InputSpinner spinner, String clientId)
    throws IOException {
  ResponseWriter writer = ctx.getResponseWriter();
  writer.startElement("input", spinner);
  writer.writeAttribute("id", clientId, null);
  writer.writeAttribute("name", clientId, null);
  Object value = getValue(ctx, spinner);
  if (value != null) {
    writer.writeAttribute("value", value.toString(), null);
  }
  writer.writeAttribute("class", "inputSpinner-input", null);
  writer.endElement("input");
}
----
Many existing components typically override the `encodeEnd()` method, not the `encodeBegin()` method. 
This is due to historical reasons in connection with JSF 1.1 - it is only in the `encodeEnd()` method that all child elements of the currently written JSF component have already been created and mounted in the component tree - hence the `encodeEnd()` method is usually used for components with child elements. 
In JSF versions 1.2 and above, this is no longer necessary because the entire tree is already set up in the `Render-Response-Phase`.

By default, the component tree in JSF is recursively traversed, and each component is rendered by a single call to the `encodeAll()` method. 
The method `encodeAll()` first calls the method `encodeBegin()` of the current component and then checks whether the method `getRendersChildren()` returns the value `true`. 
If so, not the individual child components are gone through, but the method `encodeChildren()` called - so that the component itself can write their children in the view. 
Otherwise, the method `encodeAll()` called on the individual children and thus recursively the tree written one step deeper into the view. 
For components that manage their child elements themselves and want to write to the HTML view, so it's important that you renderer method overrides `getRendersChildren()` and returns `true`.

*ResponseWriter:* Back to writing the edition of our component. 
This process works for HTML (and all SGML-derived dialects are similar) by opening, closing, and writing attributes from the component's tags. 
Opening a tag is a simple call to the `ResponseWriter`:
----
writer.startElement("input", spinner);
----
*startElement():* First, pass the string to be used as the name of the tag to the method `startElement()` - in our case `input`. 
The second attribute is the component itself. 
Very important - here should not be null but always the associated component. 
If the HTML tag of a component is not one-to-one-for example, if a renderer for a component generates multiple HTML tags-the component should be passed to each of these tags, as well as any child tags. 
The information about the associated component is evaluated by graphical development environments in order, for example, to mark all tags of a component with a special class during rendering at design time. 

*writeAttribute():* In the next step, the attributes of the tag are written to the HTML view using the `writeAttribute()` method. 
Again, the name of the attribute is passed first:

----
writer.writeAttribute("id", clientId, "id");
----

The attribute name is followed by the value to be written, followed by the corresponding attribute of the component. 
This connection is also used by development environments and should be set if possible if a corresponding component attribute exists. 
An example of an attribute where this is not possible is the `onclick` attribute. 
This attribute has no equivalent in the component, it is only entered in the map of the attributes.
----
writer.writeAttribute(HTML.ONCLICK_ATTR,
    onClick.toString(), null);
----

*value attribute:* Important (and slightly different than the treatment of the other attributes) is the handling of the value attribute. 
When a JSF request arrives at the server, the value of a component is decoded and this value is first written to the submittedValue field. 
If an error occurs during the conversion or validation of a component of the component tree, further processing of the request is aborted and jumped directly to the `Render-Response-Phase`. 
Instead of outputting now the value of the component, which is obtained by calling `getValue()`, you first have to check during rendering, if only the `Submitted-Value` has been set. 
If this condition is `true`, you may only write this `Submitted-Value`.

*Conversion:* If the component value is not decisive, but a value is actually set for the component, then before the value is rendered, a possibly specified converter must be called to convert the value into a character string. 
Listing <<.Reading the value of a component while rendering, Reading the value of a component while rendering>> shows the `getValue()` method of the `InputSpin-nerRenderer` class, which returns the value of the component for the display, using the algorithm just described.

[source,java]
----
private Object getValue(FacesContext ctx,
    InputSpinner spinner) {
  Object submittedValue = spinner.getSubmittedValue();
  if (submittedValue != null) {
    return submittedValue;
  }
  Object value = spinner.getValue();
  Converter converter = getConverter(ctx, spinner);
  if (converter != null) {
    return converter.getAsString(ctx, spinner, value);
  } else if (value != null) {
    return value.toString();
  } else {
    return "";
  }
}
private Converter getConverter(FacesContext ctx,
    UIComponent comp) {
  Converter conv = ((UIInput)comp).getConverter();
  if (conv != null) return conv;
  ValueExpression exp = comp.getValueExpression("value");
  if (exp == null) return null;
  Class valueType = exp.getType(ctx.getELContext());
  if (valueType == null) return null;
  return ctx.getApplication().createConverter(valueType);
}
----
*Independence from JSF Implementation:* You can usually take over functionality from the underlying JSF API without any problems. 
But you should be careful not to depend on the specific JSF implementation you are developing the component on - so you really should only use the functionality of the `javax.faces.*` API.

===== Decoding

*Continue in the program:* Just as the component is written to the HTML page, the value of the component must be read back from the HTTP request during a postback. 
This is done by the renderer, using the method `decode()`. 
Listing <<.Decoding a value, Decoding a value>> shows the method of our example renderer.

.Decoding a value
[source,java]
----
public void decode(FacesContext ctx, UIComponent component) {
  Map<String, String> params = ctx
      .getExternalContext().getRequestParameterMap();
  String clientId = component.getClientId();
  String value = params.get(clientId);
  ((UIInput)component).setSubmittedValue(value);
}
----
*The procedure is quite simple:* the map of the request parameters is searched for the `clientID` of the component, and the returned value is set as the `Submitted-Value` of the component. 

*Conversion and Validation:* Let's move on to the lifecycle of the HTTP request: The component must now convert the `Submitted-Value` and then validate. 
To convert the value, call the `getConvertedValue()` method of the renderer (see Listing <<.Converting the Value in the Sample Renderer, Converting the Value in the Sample Renderer>>).

.Converting the Value in the Sample Renderer
[source,java]
----
public Object getConvertedValue(FacesContext ctx,
    UIComponent component, Object submittedValue)
    throws ConverterException {
  Converter converter = getConverter(ctx, component);
  if (converter != null ) {
    return converter.getAsObject(
        ctx, component, (String) submittedValue);
  } else {
    return submittedValue;
  }
}
----
===== Rendering resources

Rendering resources such as images, stylesheets or scripts is an important aspect of many components. 
As of JSF 2.0, there is now finally a standardized solution, which greatly simplifies the creation of components. 
The topic of resources has already been dealt with in detail in Chapter [Chapter: Resource Management]. 
It was briefly mentioned here that dependencies between resources and components can be mapped in the form of annotations on the component or renderer class.

Let's take a closer look at this for our input spinner component. 
For the sake of simplicity we will use the resources of the composite component `inputSpinner` from the mygourmet library. 
In order for the component to render properly and function properly, we need the stylesheet `components.css` and the script `inputSpinner.js`. 
We will take care of the two pictures to increase and decrease the value later. 
For each of the two resources, annotate the renderer class with `@ResourceDependency`, specifying the library and name. 
The script is additionally loaded with target = "head" in the header of the rendered output. 
Listing <<.Resource annotations on the renderer class, Resource annotations on the renderer class>> shows the renderer class with the annotations. 
More is not necessary to let JSF manage the resources automatically - assuming of course you use it `h:head` and `h:body`. 
You can also use the component multiple times on one page, JSF will always render it only once.

.Resource annotations on the renderer class
[source,java]
----
@ResourceDependencies({
  @ResourceDependency(library = "mygourmet",
      name = "inputSpinner.js", target = "head"),
  @ResourceDependency(library = "mygourmet",
      name = "components.css")}
)
public class InputSpinnerRenderer extends Renderer {
...
}
----
Automatic Resource Management also ensures that resources in the rendered output always end up exactly where they should. 
For example, a stylesheet has no place in an HTML document outside of head. 
Of course, the two images `spin-up.png` and `spin-down.png`, which we also take from the mygourmet library of the composite component, can not simply be linked to the component via an annotation. 
After they form part of the rendered output of the component, they must be inserted manually. 
Then there is the class `ResourceHandler` to use, with which JSF internally manages resources. 
Access to the resource handler responsible for the application takes place via the application object. 

Rendering the resource itself is then relatively easy. 
The most important step is generating the resource using the `createResource()` method of the resource handler. 
This method takes as parameters either only the `name` or the `name` and the `library` of the resource and returns an instance of the class `Resource`, which gives us full access. 
The image is rendered via the response writer as an img element whose src attribute is set to a specific resource URL. 
This URL is provided by the method `Resource.getRequestPath()` is calculated. 
If the browser reloads the image with this URL when displaying the page, JSF delivers the content of the resource to the client. 
Listing <<.Direct rendering of resources, Direct rendering of resources>> shows how the rendering of either image looks like with the associated JavaScript code.

.Direct rendering of resources
[source,java]
----
Application app = ctx.getApplication();
ResourceHandler handler = app.getResourceHandler();
Resource spinUpRes = handler.createResource(
    "spin-up.png", "mygourmet");
String onclickUp = MessageFormat.format(
    "return changeNumber(''{0}'', {1});",
    clientId, spinner.getInc());
writer.startElement("img", spinner);
writer.writeAttribute("class", "inputSpinner-button", null);
writer.writeAttribute("src", spinUpRes.getRequestPath(), null);
writer.writeAttribute("onclick", onclickUp, null);
writer.endElement("img");
----

If you are writing a large number of components, you will probably pack them into component libraries as jar files. 
With the use of JSF resources, this is no longer a problem, as the required classes and resources can be summarized in a jar file. 
A detailed description can be found in section [Section: The Custom Component Library].

==== Registering the Component and Renderer Classes

The component and renderer classes just written must now be registered with an entry in `faces-config.xml` in the Faces environment. 
Listing <<.registration of a component class, registration of a component class>> shows the registration of the component class of the example under the `at.irian.InputSpinner` component type.

.registration of a component class
[source,xml]
----
<component>
  <component-type>
    at.irian.InputSpinner
  </component-type>
  <component-class>
    at.irian.jsfatwork.gui.jsf.component.InputSpinner
  </component-class>
</component>
----
As with converters and validators, JSF 2.0 or higher allows you to register components with an annotation. 
Annotating the component class with `@FacesComponent` is enough to register the component under the component type specified in the `value` element. 
Listing <<.registration of a component class by annotation, registration of a component class by annotation>> shows the matching code.

.registration of a component class by annotation
[source,java]
----
@FacesComponent("at.irian.InputSpinner")
public class InputSpinner extends UIInput {
...
}
----

JSF 2.2: As of JSF 2.2, the element value of the annotation `@FacesComponent` is optional and is supplemented with a naming convention. 
If not specified, JSF uses the class name with a small initial letter as the component ID. 
For the example of Listing <<.a component class using annotation, a component class using annotation>>, this would be the ID `inputSpinner`. 

When registering the renderer, you must first select a rendering kit that will register the additional renderer class. 
The choice is usually simple, and almost always remains with the use of the standard render-kit with the `render-kit-id` `HTML_BASIC`.

Listing <<.Registering a Renderer Class, Registering a Renderer Class>> shows the registration of the sample renderer under the component family `javax.faces.Input` and the renderer type `at.irian.InputSpinner`.

[source,xml]
----
<render-kit>
  <render-kit-id>HTML_BASIC</render-kit-id>
  <renderer>
    <component-family>javax.faces.Input</component-family>
    <renderer-type>at.irian.InputSpinner</renderer-type>
    <renderer-class>
      at.irian.jsfatwork.gui.jsf.component.InputSpinnerRenderer
    </renderer-class>
  </renderer>
</render-kit>
----
A renderer can also be registered in the system with the `@FacesRenderer` annotation as of JSF version 2.0. 
The necessary data is specified in the elements `renderKitId`, `componentFamily` and `rendererType`. 
The `renderKitId` can also be omitted, and then set to the default render-kit. 
Listing <<.registration of a renderer class by annotation, registration of a renderer class by annotation>> shows the code.

.registration of a renderer class by annotation
[source,java]
----
@FacesRenderer(componentFamily = "javax.faces.Input",
    rendererType = "at.irian.InputSpinner")
public class InputSpinnerRenderer extends Renderer {
  ...
}
----

==== Writing Tag Definition

All previous steps, the creation of the component and renderer class and the registration of the two classes in the system, are always the same regardless of the page declaration language used. 
Unfortunately, this is no longer possible when defining the tag of the component. 

With JSP, defining the tag and then creating the tag class is a tedious task. 
With Version 2.0 of the specification, the focus has clearly been put on facelets and JSP plays only a minor role, we will not go into more detail here.

With facelets, creating a tag definition does not require much effort. 
If a matching tag library already exists, specifying the tag name, component type, and renderer type will specify the tag. 
If this is not the case, a new tag library must first be created and made known to the system. 
How to do this is shown in Section [Section: Creating Tag Libraries with Facelets]. 
The complete definition of the tag for our example component shown in the Listing <<.definition of the example component tag, definition of the example component tag>>.

.definition of the example component tag
[source,xml]
----
<tag>
  <tag-name>inputSpinner</tag-name>
  <component>
    <component-type>at.irian.InputSpinner</component-type>
    <renderer-type>at.irian.InputSpinner</renderer-type>
  </component>
</tag>
----

JSF 2.2: JSF 2.2 reduces the overhead of creating a component tag to an absolute minimum. 
In the simplest case, it is sufficient to set the element createTag of `@FacesComponent` to `true`. 
JSF provides the component by convention in the namespace http://xmlns.jcp.org/jsf/component. 
The name of the tag derives automatically from the class name (with a lower initial letter).

If you want to use your own values ​​for the namespace or the tag name, you must specify these explicitly. 
The tag name can be in element `tagName` and the namespace in element `namespace` be set. 
Illustration <<.Definition of the tag using annotation, Definition of the tag using annotation>> shows a concrete example.

.Definition of the tag using annotation
[source,java]
----
@FacesComponent(value="at.irian.InputSpinner",
    createTag=true, tagName="inputSpinner",
    namespace="http://at.irian/test")
public class InputSpinner extends UIInput {
...
}
----

This method works well for quickly defining tags for individual components. 
At the latest, if you have more than a handful of components, consider a full tag library, including XML configuration.

Attributes about Reflection: How does Facelets know which attributes are available for the tag? 
Through Reflection, facelets access the component class and determine the possible attributes from that class.

==== Write Tag Treatment Class

In rare cases, a treatment class is needed for facelet tags as well. 
This is the case, for example, if there is no component behind the tag, as is the case for `c:if` from the JSTL library of facelets. 
Listing <<.tag handler for `c:if`, tag handler for `c:if`>> shows the code of this tag handler.

.tag handler for `c:if`
[source,java]
----
public final class IfHandler extends TagHandler {
  private final TagAttribute test;
  private final TagAttribute var;

  public IfHandler(TagConfig config) {
    super(config);
    this.test = this.getRequiredAttribute("test");
    this.var = this.getAttribute("var");
  }
  public void apply(FaceletContext ctx, UIComponent parent)
      throws IOException, FacesException, ELException {
    boolean b = this.test.getBoolean(ctx);
    if (this.var != null) {
      ctx.setAttribute(var.getValue(ctx), new Boolean(b));
    }
    if (b) this.nextHandler.apply(ctx, parent);
  }
}
----

In the constructor, the tag handler is initialized with the values ​​from the page. 
Calling `getRequiredAttribute()` guarantees that the attribute is set in the page declaration. 
If this is not the case, facelets throw an exception. 
Essential is the method apply - which is called whenever the tag is called internally when building the component tree. 
Here, the actual logic takes place, which, in the case of `c:if`, inserts the child components of the tag into the component tree depending on the value of the `test` attribute. 
Because the child components are explicitly called by a call to `this.nextHandler.apply()` it is easy to influence this process.

Tag handlers such as those just described are used in the tag library directly in a tag definition and can thus be used in the page declaration as a component. 
Here, however, it should be noted that a tag handler is called only when the component tree is created. 
The definition of the tag in this case looks like this:

[source,xml]
----
<tag>
  <tag-name>if</tag-name>
  <handler-class>IfHandler</handler-class>
</tag>
----

Tag handlers can also be used on components that require special behavior. 
As a demonstration, we create a tag handler for our input spinner component, which makes the `inc` attribute mandatory. 
For the source code of the tag handler, see Listing <<.Tag Handlers for the sample component, Tag Handlers for the sample component>>.

[source,java]
----
public class InputSpinnerTagHandler extends ComponentHandler {
  private TagAttribute inc;
  public InputSpinnerTagHandler(ComponentConfig conf) {
    super(conf);
    this.inc = getRequiredAttribute("inc");
  }
}
----

This tag handler can now also be specified when defining the component tag. 
Listing <<.Definition of the tag of the example component with tag handler, Definition of the tag of the example component with tag handler>> shows the definition extended by the tag handler.

.Definition of the tag of the example component with tag handler
[source,xml]
----
<tag>
  <tag-name>inputSpinner</tag-name>
  <component>
    <component-type>at.irian.InputSpinner</component-type>
    <renderer-type>at.irian.InputSpinner</renderer-type>
    <handler-class>
      at.irian.jsfatwork.gui.jsf.component.InputSpinnerTagHandler
    </handler-class>
  </component>
</tag>
----

==== Include tag library

Finally, there is only one step left: Before the component can be used in a declaration, the tag library must be included. 
How this works, we have already shown in the standard components and various other opportunities and need not be repeated here.

At this point we would like to illustrate once again how JSF resolves the component and renderer class for one tag when building the component tree. 
For example, if JSF encounters the `mg:inputSpinner` tag, the definition in the tag library is already the `at.irian.InputSpinner` component type and the `at.irian.InputSpinner` renderer type known. 
The component instance can now be used to create the component instance and insert it into the tree. 
This information can also be used to resolve the renderer class. 
Assuming that the standard rendering kit is named `HTML_BASIC`, the renderer's class and component family can be used to determine the class of the renderer from the configuration. 
The component family can always be called up by calling the `getFamily()` method of the component.

That's all you need to know about writing your own components - good luck creating the most dynamic, interactive, and beautiful JSF components.

=== Combine composite components and classical components

In the last two sections, we have introduced you to the development of composite components and classic components. 
In this section, we will show you that these concepts are not mutually exclusive, but on the contrary even harmonize very well.

In the development of composite components, the case always occurs that a desired behavior can only be achieved with Java code. 
So we need an extension point to integrate this code. 
As we have already shown, composite components are built internally from classical components. 
The most obvious idea is therefore to implement this Java code in the form of a classic component.

JSF follows exactly this idea and allows composite components to freely choose the type of root component. 
The `componentType` attribute in the `cc:interface` element can be used to explicitly specify the component type of this component. 
The component class used must be the only prerequisite to implement the interface and in `getFamily()` return the component family `javax.faces.NamingContainer`. 
If `componentType` is not set, JSF will automatically create a component of Type.

This is exactly what we are going to do now for the composite component presented in Section [Section: The component `mc:collapsiblePanel`] make collapsiblepanel. 
There, we have already noted critically that users of the component must provide the logic for showing and hiding themselves. 
We will implement this functionality in the `CollapsiblePanel` component, which we then associate with the composite component. 
The component itself can be kept very simple. 
It just needs to have the collapsed property and an fade-in event-handling method. 
Listing <<.Component CollapsiblePanel, Component CollapsiblePanel>> shows the component class registered with `@FacesComponent` under the `at.irian.CollapsiblePanel` component type.

.Component CollapsiblePanel
[source,java]
----
@FacesComponent("at.irian.CollapsiblePanel")
public class CollapsiblePanel extends UINamingContainer {
  enum PropertyKeys {collapsed}

  public boolean isCollapsed() {
    return (Boolean)getStateHelper().eval(
        PropertyKeys.collapsed, Boolean.FALSE);
  }
  public void setCollapsed(boolean collapsed) {
    getStateHelper().put(PropertyKeys.collapsed, collapsed);
  }
  public void toggle(ActionEvent e) {
    setCollapsed(!isCollapsed());
    setCollapsedValueExpression();
  }
  private void setCollapsedValueExpression() {
    ELContext ctx = FacesContext.getCurrentInstance()
        .getELContext();
    ValueExpression ve = getValueExpression(
        PropertyKeys.collapsed.name());
    if (ve != null) ve.setValue(ctx, isCollapsed());
  }
}
----
Since the component class is derived from UINamingContainer , we do not need to take any further precautions and can use them directly in the composite component . If your component is derived from another class, such as UIInput , it must also implement the NamingContainer interface and return the value javax.faces.NamingContainer in getFamily () . The value of the collapsed property is managed internally with the already known StateHelper . A call to the toggle event handling method just change the value of this property. If the user of the composite component has specified a value expression in the collapsed attribute , the method setCollapsedValueExpression () also restores the current collapsed state. 
Let us now turn to the composite component itself. The internals change only minimally compared to section [section: the component mc: collapsiblePanel] and are wired a little differently. Listing composite component collapsiblePanelmit custom root component of the updated component CollapsiblePanel with gesetzem componentType attribute.

[source,xhmtl]
----
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html"
    xmlns:cc="http://xmlns.jcp.org/jsf/composite"
    xmlns:ui="http://xmlns.jcp.org/jsf/facelets">
<cc:interface componentType="at.irian.CollapsiblePanel">
  <cc:attribute name="collapsed"/>
  <cc:actionSource name="toggle"/>
  <cc:facet name="header"/>
</cc:interface>
<cc:implementation>
  <h:panelGroup layout="block"
      styleClass="collapsiblePanel-header">
    <h:commandButton actionListener="#{cc.toggle}"
        id="toggle" styleClass="collapsiblePanel-img"
        image="#{resource[cc.collapsed 
          ? 'mygourmet:toggle-plus.png'
          : 'mygourmet:toggle-minus.png']}"/>
    <cc:renderFacet name="header"/>
  </h:panelGroup>
  <h:panelGroup layout="block" rendered="#{!cc.collapsed}">
    <cc:insertChildren/>
  </h:panelGroup>
</cc:implementation>
</ui:composition>
----
As a first step, the obligatory attribute `model` is replaced by the optional attribute `collapsed`. 
This allows the collapse state to be linked externally via a value expression with a bean property. 
This gives the user the opportunity to set an initial value and to save the current collapsed state. 
The evaluation of the initial state from the collapsed attribute is done internally automatically by the StateHelper of the component.

The second change affects the toggle event handler and the collapsed property, since both are now provided directly by the root component, the EL expressions change to access cc.toggle and cc.collapsed. 
This is possible because the `cc` referenced component is now an instance of the previously created CollapsiblePanel class. 

Thus, the improved version of the composite component collapsiblePanel is already ready for use. 
Now we can actually talk about a standalone and reusable building block. 
The next logical step would be to make the component including all available as a jar file. 
Section [Section: The Custom Component Library] shows how it works.

=== Alternatives to your own component

A component consists of the parts component class, the renderer class, and an optional tag handler. 
All these parts are connected to each other, but can also be replaced separately. 
The easiest way to change a component without having to write a new component is to replace the renderer class.

==== Replacing the Renderer Class

To change the renderer class you have to change the configuration in `faces-config.xml` first. 
Listing configuration of a renderer shows an example.

[source,xml]
----
<render-kit>
  <render-kit-id>HTML_BASIC</render-kit-id>
  <renderer>
    <component-family>javax.faces.Output</component-family>
    <renderer-type>javax.faces.Label</renderer-type>
    <renderer-class>
      mypackage.RequiredLabelRenderer
    </renderer-class>
  </renderer>
</render-kit>
----
Example: RequiredLabel: Overrides the renderer for the Label component with the class `mypackage.RequiredLabelRenderer`. 
All that remains is to implement this class. 
Listing <<.Rendering a label with an obligatory field star, Rendering a label with an obligatory field star>> shows an implementation that evaluates the required attribute of the component that belongs to the label.

.Rendering a label with an obligatory field star
[source,java]
----
public class RequiredLabelRenderer extends HtmlLabelRenderer {
  protected void encodeBeforeEnd(FacesContext facesContext,
      ResponseWriter writer, UIComponent uiComponent)
      throws IOException {
    String forAttr = getFor(uiComponent);
    if (forAttr != null) {
      UIComponent forComponent =
          uiComponent.findComponent(forAttr);
      if (forComponent instanceof UIInput &&
          ((UIInput) forComponent).isRequired()) {
        writer.startElement(HTML.SPAN_ELEM, null);
        writer.writeAttribute(HTML.ID_ATTR,
            uiComponent.getClientId(facesContext)+
            "RequiredLabel", null);
        writer.writeAttribute(HTML.CLASS_ATTR,
            "requiredLabel", null);
        writer.writeText("*", null);
        writer.endElement(HTML.SPAN_ELEM);
      }
    }
  }
}
----
Depending on the value of this attribute, an asterisk is added to the label description. 
For this purpose, the mandatory field renderer is derived from `HtmlLabelRenderer` and overrides the `encodeBeforeEnd()` method of the base class. 
In this method, first the component belonging to the label is searched; then the attribute of this component is queried. 
If the component is required, a span tag is output with a CSS class and a * content. 
Very simple and very effective! 
Please note, however, that the `HtmlLabelRenderer` class comes from Apache MyFaces and is not included in the standard. 
Nonetheless, even if you use Mojarra the basic functionality does not change.

==== Replacement of the component class

Just as the replacement of the renderer class, the replacement of the component class is possible - in the `faces-config.xml` file, an additional entry must be made as follows:

[source,xml]
----
<component>
  <component-type>javax.faces.HtmlInputText</component-type>
  <component-class>
    mypackage.SpecialHtmlInputText
  </component-class>
</component>
----
Auto-Converter: This procedure, for example, automatically connects a converter to the component without using its own converter tag. 
An example of such a class:

[source,java]
----
public class SpecialHtmlInputText extends HtmlInputText {
  public SpecialHtmlInputText() {
    super();
    setConverter(ConverterFactory.getSpecialConverter());
  }
}
----

This means that this special converter is used for all elements of these components.

==== Custom component from the backing beans - component binding

The two tricks used so far apply to all elements of a component type - what can be done if you only want to distinguish individual components with this special behavior and others do not?

Example: Newline: An example from the practice: For an application, a connection to a legacy database running on an AS400 server was developed. 
The data returned by the server was marked with an r to mark the line break - on the frontend this mark should also lead to a line break in the HTML markup, so it had to be output as <br/>. 
Since not all text edits should be parsed, the rendering behavior has been replaced only for some of the components.

To make this substitution, you can either create your own tag and set a new renderer for the component over that tag, but you can also use component binding, but this second way is much easier. 
First of all, all components that should have a special rendering behavior have to be given a binding attribute. 
In the next step, this attribute is linked to the underlying business logic. 
The following example shows a section of such a modified page declaration:

[source,xhtml]
----
<h:outputText value="#{limitDetail.limitView.comment}"
    binding="#{componentBean.outputWithBreaks}"/>
----
The referenced method looks like this:
[source,java]
----
UIComponent getOutputWithBreaks() {
  return new OutputTextWithBreaks();
}
----
All we need now is an implementation of this component - this is shown in Listing <<.modifying the rendering behavior of a component by componentBinding, modifying the rendering behavior of a component by componentBinding>>. 
It overrides the `encodeEnd()` method - where usually a renderer is searched for the component and its `encodeEnd()` method is called. 
In this case, we do the rendering right in the component itself. 
The actual rendering is hidden in the figure because it should correspond exactly to the functionality in the renderer class.

.modifying the rendering behavior of a component by componentBinding
[source,java]
----
public static final class OutputText extends HtmlOutputText {
  public OutputText() {
    super();
  }
  public void encodeEnd(FacesContext context)
      throws IOException {
    String text = RendererUtils.getStringValue(context, this);
    text = HTMLEncoder.encode(text, true, true);
    text = text.replaceAll("\r","<br/>");
    renderOutputText(context, this, text, false);
  }
  public static void renderOutputText(
      FacesContext ctx, UIComponent component,
      String text, boolean escape)
      throws IOException {
    ...
  }
}
----
=== MyGourmet 13: Components and Services

The example MyGourmet 13 integrates all the components developed in this chapter - the composite components from section [Section: composite components] as well as the classic component from section [Classical components] and their combination from section [Section: Combining composite components and classical components]. 
In addition to the many new components, there is the new view `editProvider.xhtml` to edit a provider. 
As part of this change, we have slightly tweaked the architecture of the application and introduced a service class for provider- type objects. 
Listing <<.MyGourmet 13: ProviderService, MyGourmet 13: ProviderService>> shows the Interface `ProviderService` of the service class.

.MyGourmet 13: ProviderService
[source,java]
----
public interface ProviderService {
  Provider createNew();
  boolean save(Provider entity);
  void delete(Provider entity);
  List<Provider> findAll();
  Provider findById(long id);
}
----
The reason for this optimization is explained quickly. 
After the managed bean `ProviderBean` is stored in the view scope, it is recreated for each view. 
This also means that the list of providers is reinitialized each time. 
In the last example this was not a problem, because the provider data was not changeable. 
With the new view `editProvider.xhtml` however, it is a problem because the data changed by the user when leaving the page are lost - they are only stored in the bean. 
With a service in the application scope, a database is virtually simulated and the problem no longer occurs. 
As an added benefit, an existing service class makes switching to a real database very easy. 
With this change, it is also possible to outsource the functionality required for the view `providerList.xhtml` to the managed bean `ProviderListBean` in the request scope.

The `ProviderServiceImpl` class implements the `ProviderService` interface and represents the actual service. 
It is available as a managed bean under the name `providerService` in the application scope. 
Listing <<.MyGourmet 13: Implementation of the service, MyGourmet 13: Implementation of the service>> shows the hull of the class with the annotations. 
The implementation is very simple and is based internally on a list which is initialized when creating the bean with three objects of type `Provider`.

.MyGourmet 13: Implementation of the service
[source,java]
----
@ManagedBean(name = "providerService")
@ApplicationScoped
public class ProviderServiceImpl implements ProviderService {
  ...
}
----
Much more interesting is the automatic setting of the service in the managed bean `ProviderBean` via a managed property. 
Listing <<.MyGourmet 13: Setting the Service in `ProviderBean`, MyGourmet 13: Setting the Service in `ProviderBean`>> shows the corresponding code snippet. 
You do not have to worry about the service in this case. 
After creating a `ProviderBean` managed bean, JSF automatically sets the service - and this is guaranteed before the user's first access.

.MyGourmet 13: Setting the Service in `ProviderBean`
[source,java]
----
@ManagedProperty(value = "#{providerService}")
private ProviderService providerService;
public void setProviderService(
    ProviderService providerService) {
  this.providerService = providerService;
}
----
But now back to the actual topic of this chapter: Components. 
The list of available composite components includes `mc:panelBox`, `mc:dataTable`, `mc:collapsiblePanel`, and `mc:inputSpinner`. 
The prefix `mc` stands for the namespace http://at.irian/mygourmet of the MyGourmet-Tag library. 
Figure <<MyGourmet 13: Resources of the library mygourmet, MyGourmet 13: Resources of the library mygourmet>> displays the contents of the resource library `mygourmet` with all composite components, stylesheets, pictures and scripts.

====
.MyGourmet 13: Resources of the library mygourmet
image::images/mygourmet13-resources.jpg[]
====

The component `mg:inputSpinner`, which is the classic version of our input spinner component, can be used in the same way as the composite component.

=== The own component library

In this section, we'll show how easy it is to create your own component library with JSF 2.0. 
For this purpose, we pack the composite component `collapsiblePanel` from section [Section: Combining Composite Components and Classic Components] including all required artifacts into a jar file. 
After making the component itself reusable, this jar file can be used in any JSF application.

A first version of our component library is created quickly. 
All we have to do is add the mygourmet resource library and the `CollapsiblePanel` class of the custom root component to the jar file.

Since the `CollapsiblePanel` component is registered with the `@FacesComponent` annotation in the system, we do not really need an XML configuration. 
But in the end we have to create an empty `faces-config.xml`. 
JSF only considers annotations in those jar files that contain a file named `faces-config.xml` or with the extension `.faces-config.xml` in the directory `META-INF`. 
Listing <<.faces-config.xml for the component library, faces-config.xml for the component library>> shows the empty faces-config.xml for JSF 2.2.

.faces-config.xml for the component library
[source,XML]
----
<faces-config xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
      http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
    version="2.2">
</faces-config>
----
For JSF to be able to resolve the resources of our mygourmet library from the jar files in the classpath, it must be located in the `META-INF/resources` directory. 
The component library is now ready for use and can be used in any JSF application as soon as the jar archive is available in the classpath. 
The use of the composite component `collapsiblePanel` has not changed. 
As before, it will be integrated via the namespace http://xmlns.jcp.org/jsf/composite/mygourmet and the tag name `collapsiblePanel`.

This admittedly very simple component library lends itself as the basis for extensions. 
In addition to other composite components, it can also be supplemented with classic components, converters and validators. 
However, the tags for these artifacts must be configured in a tag library (see section Section: Creating tag libraries with facelets). 
For our example we create the tag library `mygourmet.taglib.xml` in the directory `META-INF` with the namespace http://at.irian/mygourmet.

The tags of the composite components and the tags of the tag library are accessible via different namespaces. 
To avoid this, JSF allows you to import composite components into tag libraries. 
For this, the name of the library - in our case mygourmet - must be specified in the element `composite-library-name`. 
Although this approach works, you can only include one complete resource library per tag library. 
JSF 2.2: JSF 2.2 solves this problem and allows you to define tags for individual composite components from different libraries. 
To do this, the tag library must have a tag for a component with a resource ID in the `resource-id` element to be added. 
This resource ID consists of the library name and the compound component's resource name separated by a slash ( / ). 
Listing <<.The tag library configuration for the component library, The tag library configuration for the component library>> shows the configuration of the tag for the composite component collapsiblePanel from our tag library.

.The tag library configuration for the component library
[source,XML]
----
<facelet-taglib version="2.2"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
      http://xmlns.jcp.org/xml/ns/javaee/
      web-facelettaglibrary_2_2.xsd">
  <namespace>http://at.irian/mygourmet</namespace>
  <tag>
    <tag-name>collapsiblePanel</tag-name>
    <component>
      <resource-id>mygourmet/collapsiblePanel.xhtml</resource-id>
    </component>
  </tag>
</facelet-taglib>
----
JSF automatically includes tag libraries from jar files in the classpath - but only if there is a configuration file in the `META-INF` directory whose name ends with the extension `.taglib.xml`. 
The tag `collapsiblePanel` is now available in applications under the namespace http://at.irian/mygourmet.

Figure <<.structure of the custom component library, structure of the custom component library>> finally shows the structure and the contents of the jar file for our example.

====
.structure of the custom component library
image::images/cc-taglib-jar.jpg[]
====

In section [Section:  MyGourmet 13 with component library] you will find again the example MyGourmet 13 - but this time with a tag library that combines all composite components, components, validators and converters into a separate jar file.

=== MyGourmet 13 with component library

This section provides a brief description of an alternate version of MyGourmet 13. 
In this version, the composite components and all components of the tag library are combined in a component library.

This component library contains the resource library mygourmet in the directory `META-INF/resources` as well as the tag library `mygourmet.taglib.xml` in the directory `META-INF`.
There are also a number of Java classes such as component and renderer classes, converters, and validators. 
The composite components are imported into the tag library as described in the last section. 
Thus, all artifacts are available under the namespace http://at.irian/mygourmet.

At the source code level, the component library is implemented as a Maven module. 
The project description `pom.xml` of the example MyGourmet 13 with component library consists of two modules: `mygourmet13-taglib` contains all components of the component library and `mygourmet13-webapp` contains the rest of the application. 
The connection between the two modules is in `mygourmet13-webapp` defines a dependency on `mygourmet13-taglib`.

To start the application, you must call `mvn jetty: run` in the directory of the mygourmet13-webapp module. 
Before that, however, the module `mygourmet13-taglib` or the whole project mygourmet13 has to be built. 
The result of creating `mygourmet13-taglib` is a jar file containing all parts of the component library.